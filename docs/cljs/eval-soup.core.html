<!doctype html>
<html>
    <head>
        <meta charset="UTF-8">
        <link rel="stylesheet" type="text/css" href="../style.css">
        <link rel="stylesheet" type="text/css" href="../paren-soup-light.css">
    </head>
    <body>
        <span id="app"><div data-reactroot="" data-reactid="1" data-react-checksum="-1468005275"><div data-reactid="2"><div class="nses" data-reactid="3"><div data-reactid="4"><a href="../clj/eval-soup.core.html" data-reactid="5">eval-soup.core</a></div><div data-reactid="6"><div class="tag" data-reactid="7">CLJS</div><a href="../cljs/eval-soup.core.html" data-reactid="8">eval-soup.core</a></div></div></div><div style="left:300px;" class="vars" data-reactid="9"><!-- react-empty: 10 --><div data-reactid="11"><center data-reactid="12"><h1 data-reactid="13">eval-soup.core</h1></center></div><div class="var-info" data-reactid="14"><a href="../cljs/eval-soup.core/code-&#x27;g&#x27;results.html" data-reactid="15"><h2 data-reactid="16">(code-&gt;results forms cb)</h2><h2 data-reactid="17">(code-&gt;results forms cb {:keys [*current-ns *state custom-load timeout disable-timeout?], :or {*current-ns (atom (quote cljs.user)), *state *cljs-state, custom-load custom-load!, timeout 4000, disable-timeout? false}, :as opts})</h2></a><div class="section doc" data-reactid="18">Evaluates each form, providing the results in a callback.
  If any of the forms are strings, it will read them first.</div><div class="section" data-reactid="19"><h2 data-reactid="20">Example</h2><div class="section" data-reactid="21"><div class="section doc" data-reactid="22">You can reference vars you previously made.</div><div class="paren-soup" data-reactid="23"><div style="display:list-item;" class="instarepl" data-reactid="24"></div><div class="content" data-reactid="25"><span class='collection list'><span class='delimiter'>(</span><span class='symbol'>code-&gt;results</span> <span class='collection vector'><span class='delimiter'>[</span>&apos;<span class='collection list'><span class='delimiter'>(</span><span class='symbol'>def</span> <span class='symbol'>n</span> <span class='number'>4</span><span class='delimiter'>)</span></span> &apos;<span class='collection list'><span class='delimiter'>(</span><span class='symbol'>conj</span> <span class='collection vector'><span class='delimiter'>[</span><span class='number'>1</span> <span class='number'>2</span> <span class='number'>3</span><span class='delimiter'>]</span></span> <span class='symbol'>n</span><span class='delimiter'>)</span></span><span class='delimiter'>]</span></span> <span class='symbol'>callback</span><span class='delimiter'>)</span></span>
</div></div></div><div class="section" data-reactid="26"><div class="section doc" data-reactid="27">You can pass the code as strings too.</div><div class="paren-soup" data-reactid="28"><div style="display:list-item;" class="instarepl" data-reactid="29"></div><div class="content" data-reactid="30"><span class='collection list'><span class='delimiter'>(</span><span class='symbol'>code-&gt;results</span> <span class='collection vector'><span class='delimiter'>[</span><span class='string'>&quot;(def n 4)&quot;</span> <span class='string'>&quot;(conj [1 2 3] n)&quot;</span><span class='delimiter'>]</span></span> <span class='symbol'>callback</span><span class='delimiter'>)</span></span>
</div></div></div><div class="section" data-reactid="31"><div class="section doc" data-reactid="32">If your code exceeds the timeout, you&#x27;ll see an exception.
   
   You can turn off timeout protection by passing `:disable-timeout? true`
   in the options map.</div><div class="paren-soup" data-reactid="33"><div style="display:list-item;" class="instarepl" data-reactid="34"></div><div class="content" data-reactid="35"><span class='collection list'><span class='delimiter'>(</span><span class='symbol'>code-&gt;results</span> <span class='collection vector'><span class='delimiter'>[</span>&apos;<span class='collection list'><span class='delimiter'>(</span><span class='symbol'>while</span> <span class='boolean'>true</span><span class='delimiter'>)</span></span><span class='delimiter'>]</span></span> <span class='symbol'>callback</span> <span class='collection map'><span class='delimiter'>{</span><span class='keyword'>:timeout</span> <span class='number'>1000</span><span class='delimiter'>}</span></span><span class='delimiter'>)</span></span>
</div></div></div></div><div class="section" data-reactid="36"><a href="../cljs/eval-soup.core/code-&#x27;g&#x27;results.html" data-reactid="37"><h3 data-reactid="38">+ Source</h3></a></div></div><div class="footer" data-reactid="39"><!-- react-text: 40 -->Generated by <!-- /react-text --><a href="https://github.com/oakes/Dynadoc" target="_blank" data-reactid="41">Dynadoc</a></div></div></div></span>
        <script type="text/edn" id="initial-state">{:type :cljs, :ns-sym eval-soup.core, :static? true, :cljs-nses-and-vars {eval-soup.core ({:sym code->results, :meta {:doc "Evaluates each form, providing the results in a callback.\n  If any of the forms are strings, it will read them first.", :arglists [[forms cb] [forms cb {:keys [*current-ns *state custom-load timeout disable-timeout?], :or {*current-ns (atom (quote cljs.user)), *state *cljs-state, custom-load custom-load!, timeout 4000, disable-timeout? false}, :as opts}]]}, :source "(defn\n code->results\n \"Evaluates each form, providing the results in a callback.\\n  If any of the forms are strings, it will read them first.\"\n ([forms cb] (code->results forms cb {}))\n ([forms\n   cb\n   {:keys [*current-ns *state custom-load timeout disable-timeout?],\n    :or\n    {*current-ns (atom 'cljs.user),\n     *state *cljs-state,\n     custom-load custom-load!,\n     timeout 4000,\n     disable-timeout? false},\n    :as opts}]\n  (let\n   [forms\n    (mapv\n     (fn*\n      [p1__18099#]\n      (if\n       (string? p1__18099#)\n       (str->form @*current-ns p1__18099#)\n       p1__18099#))\n     forms)\n    init-forms\n    (vec\n     (concat\n      ['(ns cljs.user)]\n      (when-not\n       disable-timeout?\n       ['(def ps-last-time (atom 0))\n        '(defn\n          ps-reset-timeout!\n          []\n          (reset! ps-last-time (.getTime (js/Date.))))\n        '(defn\n          ps-check-for-timeout!\n          [timeout]\n          (when\n           (> (- (.getTime (js/Date.)) @ps-last-time) timeout)\n           (throw (js/Error. \"Execution timed out.\"))))])\n      ['(set! *print-err-fn* (fn [_])) (list 'ns @*current-ns)]))\n    timeout-cb\n    (fn\n     [results]\n     (eval-forms\n      (add-timeouts-if-necessary timeout forms results)\n      cb\n      *state\n      *current-ns\n      custom-load))\n    init-cb\n    (fn\n     [results]\n     (eval-forms\n      (if disable-timeout? forms (map wrap-macroexpand forms))\n      (if disable-timeout? cb timeout-cb)\n      *state\n      *current-ns\n      custom-load))]\n   (eval-forms init-forms init-cb *state *current-ns custom-load))))\n", :examples [{:doc "You can reference vars you previously made.", :with-callback callback, :body (code->results [(quote (def n 4)) (quote (conj [1 2 3] n))] callback), :body-str "(code->results ['(def n 4) '(conj [1 2 3] n)] callback)\n", :id "eval-soup.core/code->results/0"} {:doc "You can pass the code as strings too.", :with-callback callback, :body (code->results ["(def n 4)" "(conj [1 2 3] n)"] callback), :body-str "(code->results [\"(def n 4)\" \"(conj [1 2 3] n)\"] callback)\n", :id "eval-soup.core/code->results/1"} {:doc "If your code exceeds the timeout, you'll see an exception.\n   \n   You can turn off timeout protection by passing `:disable-timeout? true`\n   in the options map.", :with-callback callback, :body (code->results [(quote (while true))] callback {:timeout 1000}), :body-str "(code->results ['(while true)] callback {:timeout 1000})\n", :id "eval-soup.core/code->results/2"}]})}, :nses ({:var-syms [wrap-security code->results wrap-timeout eval_soup.core.proxy$java.lang.SecurityManager$ff19274a with-security], :type :clj, :sym eval-soup.core} {:var-syms [code->results], :type :cljs, :sym eval-soup.core}), :ns-meta nil, :vars [{:sym code->results, :meta {:doc "Evaluates each form, providing the results in a callback.\n  If any of the forms are strings, it will read them first.", :arglists [[forms cb] [forms cb {:keys [*current-ns *state custom-load timeout disable-timeout?], :or {*current-ns (atom (quote cljs.user)), *state *cljs-state, custom-load custom-load!, timeout 4000, disable-timeout? false}, :as opts}]]}, :source "(defn\n code->results\n \"Evaluates each form, providing the results in a callback.\\n  If any of the forms are strings, it will read them first.\"\n ([forms cb] (code->results forms cb {}))\n ([forms\n   cb\n   {:keys [*current-ns *state custom-load timeout disable-timeout?],\n    :or\n    {*current-ns (atom 'cljs.user),\n     *state *cljs-state,\n     custom-load custom-load!,\n     timeout 4000,\n     disable-timeout? false},\n    :as opts}]\n  (let\n   [forms\n    (mapv\n     (fn*\n      [p1__18099#]\n      (if\n       (string? p1__18099#)\n       (str->form @*current-ns p1__18099#)\n       p1__18099#))\n     forms)\n    init-forms\n    (vec\n     (concat\n      ['(ns cljs.user)]\n      (when-not\n       disable-timeout?\n       ['(def ps-last-time (atom 0))\n        '(defn\n          ps-reset-timeout!\n          []\n          (reset! ps-last-time (.getTime (js/Date.))))\n        '(defn\n          ps-check-for-timeout!\n          [timeout]\n          (when\n           (> (- (.getTime (js/Date.)) @ps-last-time) timeout)\n           (throw (js/Error. \"Execution timed out.\"))))])\n      ['(set! *print-err-fn* (fn [_])) (list 'ns @*current-ns)]))\n    timeout-cb\n    (fn\n     [results]\n     (eval-forms\n      (add-timeouts-if-necessary timeout forms results)\n      cb\n      *state\n      *current-ns\n      custom-load))\n    init-cb\n    (fn\n     [results]\n     (eval-forms\n      (if disable-timeout? forms (map wrap-macroexpand forms))\n      (if disable-timeout? cb timeout-cb)\n      *state\n      *current-ns\n      custom-load))]\n   (eval-forms init-forms init-cb *state *current-ns custom-load))))\n", :examples [{:doc "You can reference vars you previously made.", :with-callback callback, :body (code->results [(quote (def n 4)) (quote (conj [1 2 3] n))] callback), :body-str "(code->results ['(def n 4) '(conj [1 2 3] n)] callback)\n", :id "eval-soup.core/code->results/0"} {:doc "You can pass the code as strings too.", :with-callback callback, :body (code->results ["(def n 4)" "(conj [1 2 3] n)"] callback), :body-str "(code->results [\"(def n 4)\" \"(conj [1 2 3] n)\"] callback)\n", :id "eval-soup.core/code->results/1"} {:doc "If your code exceeds the timeout, you'll see an exception.\n   \n   You can turn off timeout protection by passing `:disable-timeout? true`\n   in the options map.", :with-callback callback, :body (code->results [(quote (while true))] callback {:timeout 1000}), :body-str "(code->results ['(while true)] callback {:timeout 1000})\n", :id "eval-soup.core/code->results/2"}]}], :rel-path "../", :check-for-updates? false}</script>
        <script type="text/javascript" src="../main.js"></script>
    </body>
</html>
