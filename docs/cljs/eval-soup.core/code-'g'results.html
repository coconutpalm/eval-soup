<!doctype html>
<html>
    <head>
        <meta charset="UTF-8">
        <link rel="stylesheet" type="text/css" href="../../style.css">
        <link rel="stylesheet" type="text/css" href="../../paren-soup-light.css">
    </head>
    <body>
        <span id="app"><div data-reactroot="" data-reactid="1" data-react-checksum="1381926480"><div data-reactid="2"><div class="nses" data-reactid="3"><div data-reactid="4"><a href="../../clj/eval-soup.core.html" data-reactid="5">eval-soup.core</a></div><div data-reactid="6"><div class="tag" data-reactid="7">CLJS</div><a href="../../cljs/eval-soup.core.html" data-reactid="8">eval-soup.core</a></div></div></div><div style="left:300px;" class="vars" data-reactid="9"><!-- react-empty: 10 --><div class="var-info" data-reactid="11"><div data-reactid="12"><h2 data-reactid="13">(code-&gt;results forms cb)</h2><h2 data-reactid="14">(code-&gt;results forms cb {:keys [*current-ns *state custom-load timeout disable-timeout?], :or {*current-ns (atom (quote cljs.user)), *state *cljs-state, custom-load custom-load!, timeout 4000, disable-timeout? false}, :as opts})</h2></div><div class="section doc" data-reactid="15">Evaluates each form, providing the results in a callback.
  If any of the forms are strings, it will read them first.</div><div class="section" data-reactid="16"><h2 data-reactid="17">Example</h2><div class="section" data-reactid="18"><div class="section doc" data-reactid="19">Define a var and then use it.</div><div class="paren-soup" data-reactid="20"><div style="display:list-item;" class="instarepl" data-reactid="21"></div><div class="content" data-reactid="22"><span class='collection list'><span class='delimiter'>(</span><span class='symbol'>code-&gt;results</span> <span class='collection vector'><span class='delimiter'>[</span>&apos;<span class='collection list'><span class='delimiter'>(</span><span class='symbol'>def</span> <span class='symbol'>n</span> <span class='number'>4</span><span class='delimiter'>)</span></span> &apos;<span class='collection list'><span class='delimiter'>(</span><span class='symbol'>conj</span> <span class='collection vector'><span class='delimiter'>[</span><span class='number'>1</span> <span class='number'>2</span> <span class='number'>3</span><span class='delimiter'>]</span></span> <span class='symbol'>n</span><span class='delimiter'>)</span></span><span class='delimiter'>]</span></span> <span class='symbol'>callback</span><span class='delimiter'>)</span></span>
</div></div></div><div class="section" data-reactid="23"><div class="section doc" data-reactid="24">You can use strings too.</div><div class="paren-soup" data-reactid="25"><div style="display:list-item;" class="instarepl" data-reactid="26"></div><div class="content" data-reactid="27"><span class='collection list'><span class='delimiter'>(</span><span class='symbol'>code-&gt;results</span> <span class='collection vector'><span class='delimiter'>[</span><span class='string'>&quot;(def n 4)&quot;</span> <span class='string'>&quot;(conj [1 2 3] n)&quot;</span><span class='delimiter'>]</span></span> <span class='symbol'>callback</span><span class='delimiter'>)</span></span>
</div></div></div><div class="section" data-reactid="28"><div class="section doc" data-reactid="29">Timeout after two seconds.
   
   You can turn off timeout protection by passing `:disable-timeout? true`
   in the options map.</div><div class="paren-soup" data-reactid="30"><div style="display:list-item;" class="instarepl" data-reactid="31"></div><div class="content" data-reactid="32"><span class='collection list'><span class='delimiter'>(</span><span class='symbol'>code-&gt;results</span> <span class='collection vector'><span class='delimiter'>[</span>&apos;<span class='collection list'><span class='delimiter'>(</span><span class='symbol'>while</span> <span class='boolean'>true</span><span class='delimiter'>)</span></span><span class='delimiter'>]</span></span> <span class='symbol'>callback</span> <span class='collection map'><span class='delimiter'>{</span><span class='keyword'>:timeout</span> <span class='number'>1000</span><span class='delimiter'>}</span></span><span class='delimiter'>)</span></span>
</div></div></div></div><div class="section" data-reactid="33"><h2 data-reactid="34">Source</h2><div class="paren-soup" data-reactid="35"><div class="content" data-reactid="36"><span class='collection list'><span class='delimiter'>(</span><span class='symbol'>defn</span>
 <span class='symbol'>code-&gt;results</span>
 <span class='string'>&quot;Evaluates each form, providing the results in a callback.\n  If any of the forms are strings, it will read them first.&quot;</span>
 <span class='collection list'><span class='delimiter'>(</span><span class='collection vector'><span class='delimiter'>[</span><span class='symbol'>forms</span> <span class='symbol'>cb</span><span class='delimiter'>]</span></span> <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>code-&gt;results</span> <span class='symbol'>forms</span> <span class='symbol'>cb</span> <span class='collection map'><span class='delimiter'>{</span><span class='delimiter'>}</span></span><span class='delimiter'>)</span></span><span class='delimiter'>)</span></span>
 <span class='collection list'><span class='delimiter'>(</span><span class='collection vector'><span class='delimiter'>[</span><span class='symbol'>forms</span>
   <span class='symbol'>cb</span>
   <span class='collection map'><span class='delimiter'>{</span><span class='keyword'>:keys</span> <span class='collection vector'><span class='delimiter'>[</span><span class='symbol'>*current-ns</span> <span class='symbol'>*state</span> <span class='symbol'>custom-load</span> <span class='symbol'>timeout</span> <span class='symbol'>disable-timeout?</span><span class='delimiter'>]</span></span>,
    <span class='keyword'>:or</span>
    <span class='collection map'><span class='delimiter'>{</span><span class='symbol'>*current-ns</span> <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>atom</span> &apos;<span class='symbol'>cljs.user</span><span class='delimiter'>)</span></span>,
     <span class='symbol'>*state</span> <span class='symbol'>*cljs-state</span>,
     <span class='symbol'>custom-load</span> <span class='symbol'>custom-load!</span>,
     <span class='symbol'>timeout</span> <span class='number'>4000</span>,
     <span class='symbol'>disable-timeout?</span> <span class='boolean'>false</span><span class='delimiter'>}</span></span>,
    <span class='keyword'>:as</span> <span class='symbol'>opts</span><span class='delimiter'>}</span></span><span class='delimiter'>]</span></span>
  <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>let</span>
   <span class='collection vector'><span class='delimiter'>[</span><span class='symbol'>init-forms</span>
    <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>vec</span>
     <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>concat</span>
      <span class='collection vector'><span class='delimiter'>[</span>&apos;<span class='collection list'><span class='delimiter'>(</span><span class='symbol'>ns</span> <span class='symbol'>cljs.user</span><span class='delimiter'>)</span></span><span class='delimiter'>]</span></span>
      <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>when-not</span>
       <span class='symbol'>disable-timeout?</span>
       <span class='collection vector'><span class='delimiter'>[</span>&apos;<span class='collection list'><span class='delimiter'>(</span><span class='symbol'>def</span> <span class='symbol'>ps-last-time</span> <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>atom</span> <span class='number'>0</span><span class='delimiter'>)</span></span><span class='delimiter'>)</span></span>
        &apos;<span class='collection list'><span class='delimiter'>(</span><span class='symbol'>defn</span>
          <span class='symbol'>ps-reset-timeout!</span>
          <span class='collection vector'><span class='delimiter'>[</span><span class='delimiter'>]</span></span>
          <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>reset!</span> <span class='symbol'>ps-last-time</span> <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>.getTime</span> <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>js/Date.</span><span class='delimiter'>)</span></span><span class='delimiter'>)</span></span><span class='delimiter'>)</span></span><span class='delimiter'>)</span></span>
        &apos;<span class='collection list'><span class='delimiter'>(</span><span class='symbol'>defn</span>
          <span class='symbol'>ps-check-for-timeout!</span>
          <span class='collection vector'><span class='delimiter'>[</span><span class='symbol'>timeout</span><span class='delimiter'>]</span></span>
          <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>when</span>
           <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>&gt;</span> <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>-</span> <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>.getTime</span> <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>js/Date.</span><span class='delimiter'>)</span></span><span class='delimiter'>)</span></span> @<span class='symbol'>ps-last-time</span><span class='delimiter'>)</span></span> <span class='symbol'>timeout</span><span class='delimiter'>)</span></span>
           <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>throw</span> <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>js/Error.</span> <span class='string'>&quot;Execution timed out.&quot;</span><span class='delimiter'>)</span></span><span class='delimiter'>)</span></span><span class='delimiter'>)</span></span><span class='delimiter'>)</span></span><span class='delimiter'>]</span></span><span class='delimiter'>)</span></span>
      <span class='collection vector'><span class='delimiter'>[</span>&apos;<span class='collection list'><span class='delimiter'>(</span><span class='symbol'>set!</span> <span class='symbol'>*print-err-fn*</span> <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>fn</span> <span class='collection vector'><span class='delimiter'>[</span><span class='symbol'>_</span><span class='delimiter'>]</span></span><span class='delimiter'>)</span></span><span class='delimiter'>)</span></span> <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>list</span> &apos;<span class='symbol'>ns</span> @<span class='symbol'>*current-ns</span><span class='delimiter'>)</span></span><span class='delimiter'>]</span></span><span class='delimiter'>)</span></span><span class='delimiter'>)</span></span>
    <span class='symbol'>timeout-cb</span>
    <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>fn</span>
     <span class='collection vector'><span class='delimiter'>[</span><span class='symbol'>results</span><span class='delimiter'>]</span></span>
     <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>eval-forms</span>
      <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>add-timeouts-if-necessary</span> <span class='symbol'>timeout</span> <span class='symbol'>forms</span> <span class='symbol'>results</span><span class='delimiter'>)</span></span>
      <span class='symbol'>cb</span>
      <span class='symbol'>*state</span>
      <span class='symbol'>*current-ns</span>
      <span class='symbol'>custom-load</span><span class='delimiter'>)</span></span><span class='delimiter'>)</span></span>
    <span class='symbol'>init-cb</span>
    <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>fn</span>
     <span class='collection vector'><span class='delimiter'>[</span><span class='symbol'>results</span><span class='delimiter'>]</span></span>
     <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>eval-forms</span>
      <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>if</span> <span class='symbol'>disable-timeout?</span> <span class='symbol'>forms</span> <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>map</span> <span class='symbol'>wrap-macroexpand</span> <span class='symbol'>forms</span><span class='delimiter'>)</span></span><span class='delimiter'>)</span></span>
      <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>if</span> <span class='symbol'>disable-timeout?</span> <span class='symbol'>cb</span> <span class='symbol'>timeout-cb</span><span class='delimiter'>)</span></span>
      <span class='symbol'>*state</span>
      <span class='symbol'>*current-ns</span>
      <span class='symbol'>custom-load</span><span class='delimiter'>)</span></span><span class='delimiter'>)</span></span><span class='delimiter'>]</span></span>
   <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>eval-forms</span> <span class='symbol'>init-forms</span> <span class='symbol'>init-cb</span> <span class='symbol'>*state</span> <span class='symbol'>*current-ns</span> <span class='symbol'>custom-load</span><span class='delimiter'>)</span></span><span class='delimiter'>)</span></span><span class='delimiter'>)</span></span><span class='delimiter'>)</span></span>
</div></div></div></div><div class="footer" data-reactid="37"><!-- react-text: 38 -->Generated by <!-- /react-text --><a href="https://github.com/oakes/Dynadoc" target="_blank" data-reactid="39">Dynadoc</a></div></div></div></span>
        <script type="text/edn" id="initial-state">{:type :cljs, :ns-sym eval-soup.core, :var-sym code->results, :static? true, :cljs-nses-and-vars {eval-soup.core ({:sym chan?, :meta {}, :source "(def\n chan?\n (partial instance? cljs.core.async.impl.channels.ManyToManyChannel))\n"} {:sym code->results, :meta {:doc "Evaluates each form, providing the results in a callback.\n  If any of the forms are strings, it will read them first.", :arglists [[forms cb] [forms cb {:keys [*current-ns *state custom-load timeout disable-timeout?], :or {*current-ns (atom (quote cljs.user)), *state *cljs-state, custom-load custom-load!, timeout 4000, disable-timeout? false}, :as opts}]]}, :source "(defn\n code->results\n \"Evaluates each form, providing the results in a callback.\\n  If any of the forms are strings, it will read them first.\"\n ([forms cb] (code->results forms cb {}))\n ([forms\n   cb\n   {:keys [*current-ns *state custom-load timeout disable-timeout?],\n    :or\n    {*current-ns (atom 'cljs.user),\n     *state *cljs-state,\n     custom-load custom-load!,\n     timeout 4000,\n     disable-timeout? false},\n    :as opts}]\n  (let\n   [init-forms\n    (vec\n     (concat\n      ['(ns cljs.user)]\n      (when-not\n       disable-timeout?\n       ['(def ps-last-time (atom 0))\n        '(defn\n          ps-reset-timeout!\n          []\n          (reset! ps-last-time (.getTime (js/Date.))))\n        '(defn\n          ps-check-for-timeout!\n          [timeout]\n          (when\n           (> (- (.getTime (js/Date.)) @ps-last-time) timeout)\n           (throw (js/Error. \"Execution timed out.\"))))])\n      ['(set! *print-err-fn* (fn [_])) (list 'ns @*current-ns)]))\n    timeout-cb\n    (fn\n     [results]\n     (eval-forms\n      (add-timeouts-if-necessary timeout forms results)\n      cb\n      *state\n      *current-ns\n      custom-load))\n    init-cb\n    (fn\n     [results]\n     (eval-forms\n      (if disable-timeout? forms (map wrap-macroexpand forms))\n      (if disable-timeout? cb timeout-cb)\n      *state\n      *current-ns\n      custom-load))]\n   (eval-forms init-forms init-cb *state *current-ns custom-load))))\n", :examples [{:doc "Define a var and then use it.", :with-callback callback, :body (code->results [(quote (def n 4)) (quote (conj [1 2 3] n))] callback), :body-str "(code->results ['(def n 4) '(conj [1 2 3] n)] callback)\n", :id "eval-soup.core/code->results/0"} {:doc "You can use strings too.", :with-callback callback, :body (code->results ["(def n 4)" "(conj [1 2 3] n)"] callback), :body-str "(code->results [\"(def n 4)\" \"(conj [1 2 3] n)\"] callback)\n", :id "eval-soup.core/code->results/1"} {:doc "Timeout after two seconds.\n   \n   You can turn off timeout protection by passing `:disable-timeout? true`\n   in the options map.", :with-callback callback, :body (code->results [(quote (while true))] callback {:timeout 1000}), :body-str "(code->results ['(while true)] callback {:timeout 1000})\n", :id "eval-soup.core/code->results/2"}]}), cljs.source-map.base64 ({:sym chars64, :meta {}, :source "(def\n chars64\n \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\")\n"} {:sym char->int, :meta {}, :source "(def char->int (zipmap chars64 (range 0 64)))\n"} {:sym int->char, :meta {}, :source "(def int->char (zipmap (range 0 64) chars64))\n"} {:sym encode, :meta {:doc nil, :arglists ([n])}, :source "(defn\n encode\n [n]\n (let\n  [e (find int->char n)]\n  (if\n   e\n   (second e)\n   (throw (js/Error. (str \"Must be between 0 and 63: \" n))))))\n"} {:sym decode, :meta {:doc nil, :arglists ([c])}, :source "(defn\n decode\n [c]\n (let\n  [e (find char->int c)]\n  (if\n   e\n   (second e)\n   (throw (js/Error. (str \"Not a valid base 64 digit: \" c))))))\n"}), cljs.core.async.impl.channels ({:sym box, :meta {:doc nil, :arglists ([val])}, :source "(defn box [val] (reify cljs.core/IDeref (-deref [_] val)))\n"} {:sym put-active?, :meta {:doc nil, :arglists ([box])}, :source "(defn put-active? [box] (impl/active? (.-handler box)))\n"} {:sym MAX_DIRTY, :meta {}, :source "(def MAX_DIRTY 64)\n"} {:sym abort, :meta {:doc nil, :arglists ([this])}, :protocol MMC} {:sym MMC, :meta {:doc nil}, :methods (abort)} {:sym chan, :meta {:doc nil, :arglists [[buf] [buf xform] [buf xform exh]]}, :source "(defn\n chan\n ([buf] (chan buf nil))\n ([buf xform] (chan buf xform nil))\n ([buf xform exh]\n  (ManyToManyChannel.\n   (buffers/ring-buffer 32)\n   0\n   (buffers/ring-buffer 32)\n   0\n   buf\n   false\n   (let\n    [add! (if xform (xform impl/add!) impl/add!)]\n    (fn\n     ([buf] (try (add! buf) (catch :default t (handle buf exh t))))\n     ([buf val]\n      (try (add! buf val) (catch :default t (handle buf exh t)))))))))\n"}), cljs.core.async.impl.dispatch ({:sym tasks, :meta {}, :source "(def tasks (buffers/ring-buffer 32))\n"} {:sym running?, :meta {}, :source "(def running? false)\n"} {:sym queued?, :meta {}, :source "(def queued? false)\n"} {:sym TASK_BATCH_SIZE, :meta {}, :source "(def TASK_BATCH_SIZE 1024)\n"} {:sym process-messages, :meta {:doc nil, :arglists ([])}, :source "(defn\n process-messages\n []\n (set! running? true)\n (set! queued? false)\n (loop\n  [count 0]\n  (let\n   [m (.pop tasks)]\n   (when-not\n    (nil? m)\n    (m)\n    (when (< count TASK_BATCH_SIZE) (recur (inc count))))))\n (set! running? false)\n (when (> (.-length tasks) 0) (queue-dispatcher)))\n"} {:sym queue-dispatcher, :meta {:doc nil, :arglists ([])}, :source "(defn\n queue-dispatcher\n []\n (when-not\n  (and queued? running?)\n  (set! queued? true)\n  (goog.async.nextTick process-messages)))\n"} {:sym run, :meta {:doc nil, :arglists ([f])}, :source "(defn run [f] (.unbounded-unshift tasks f) (queue-dispatcher))\n"} {:sym queue-delay, :meta {:doc nil, :arglists ([f delay])}, :source "(defn queue-delay [f delay] (js/setTimeout f delay))\n"}), cljs.tools.reader.impl.commons ({:sym match-number, :meta {:doc nil, :arglists ([s])}, :source "(defn\n match-number\n [s]\n (if\n  (matches? int-pattern s)\n  (match-int s)\n  (if\n   (matches? float-pattern s)\n   (match-float s)\n   (when (matches? ratio-pattern s) (match-ratio s)))))\n"} {:sym skip-line, :meta {:doc "Advances the reader to the end of a line. Returns the reader", :arglists ([reader])}, :source "(defn\n skip-line\n \"Advances the reader to the end of a line. Returns the reader\"\n [reader]\n (loop [] (when-not (newline? (read-char reader)) (recur)))\n reader)\n"} {:sym int-pattern, :meta {}, :source "(def\n int-pattern\n #\"^([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?$\")\n"} {:sym read-comment, :meta {:doc nil, :arglists ([rdr & _])}, :source "(defn read-comment [rdr & _] (skip-line rdr))\n"} {:sym parse-symbol, :meta {:doc "Parses a string into a vector of the namespace and symbol", :arglists ([token])}, :source "(defn\n parse-symbol\n \"Parses a string into a vector of the namespace and symbol\"\n [token]\n (when-not\n  (or\n   (identical? \"\" token)\n   (true? (.test #\":$\" token))\n   (true? (.test #\"^::\" token)))\n  (let\n   [ns-idx\n    (.indexOf token \"/\")\n    ns\n    (when (pos? ns-idx) (subs token 0 ns-idx))]\n   (if-not\n    (nil? ns)\n    (let\n     [ns-idx (inc ns-idx)]\n     (when-not\n      (== ns-idx (count token))\n      (let\n       [sym (subs token ns-idx)]\n       (when\n        (and\n         (not (numeric? (nth sym 0)))\n         (not (identical? \"\" sym))\n         (false? (.test #\":$\" ns))\n         (or (identical? sym \"/\") (== -1 (.indexOf sym \"/\"))))\n        [ns sym]))))\n    (when\n     (or (identical? token \"/\") (== -1 (.indexOf token \"/\")))\n     [nil token])))))\n"} {:sym number-literal?, :meta {:doc "Checks whether the reader is at the start of a number literal", :arglists ([reader initch])}, :source "(defn\n number-literal?\n \"Checks whether the reader is at the start of a number literal\"\n [reader initch]\n (or\n  (numeric? initch)\n  (and\n   (or (identical? \\+ initch) (identical? \\- initch))\n   (numeric? (peek-char reader)))))\n"} {:sym read-past, :meta {:doc "Read until first character that doesn't match pred, returning\n   char.", :arglists ([pred rdr])}, :source "(defn\n read-past\n \"Read until first character that doesn't match pred, returning\\n   char.\"\n [pred rdr]\n (loop [ch (read-char rdr)] (if (pred ch) (recur (read-char rdr)) ch)))\n"} {:sym float-pattern, :meta {}, :source "(def float-pattern #\"([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?\")\n"} {:sym matches?, :meta {:doc nil, :arglists ([pattern s])}, :source "(defn\n matches?\n [pattern s]\n (let [[match] (re-find pattern s)] (identical? match s)))\n"} {:sym throwing-reader, :meta {:doc nil, :arglists ([msg])}, :source "(defn throwing-reader [msg] (fn [rdr & _] (reader-error rdr msg)))\n"} {:sym ratio-pattern, :meta {}, :source "(def ratio-pattern #\"([-+]?[0-9]+)/([0-9]+)\")\n"}), cljs.tools.reader.edn ({:sym read, :meta {:doc "Reads the first object from an IPushbackReader.\n   Returns the object read. If EOF, throws if eof-error? is true otherwise returns eof.\n   If no reader is provided, *in* will be used.\n\n   Reads data in the edn format (subset of Clojure data):\n   http://edn-format.org\n\n   clojure.tools.reader.edn/read doesn't depend on dynamic Vars, all configuration\n   is done by passing an opt map.\n\n   opts is a map that can include the following keys:\n   :eof - value to return on end-of-file. When not supplied, eof throws an exception.\n   :readers  - a map of tag symbols to data-reader functions to be considered before default-data-readers.\n              When not supplied, only the default-data-readers will be used.\n   :default - A function of two args, that will, if present and no reader is found for a tag,\n              be called with the tag and the value.", :arglists [[reader] [{:keys [eof], :as opts} reader] [reader eof-error? eof opts]]}, :source "(defn\n read\n \"Reads the first object from an IPushbackReader.\\n   Returns the object read. If EOF, throws if eof-error? is true otherwise returns eof.\\n   If no reader is provided, *in* will be used.\\n\\n   Reads data in the edn format (subset of Clojure data):\\n   http://edn-format.org\\n\\n   clojure.tools.reader.edn/read doesn't depend on dynamic Vars, all configuration\\n   is done by passing an opt map.\\n\\n   opts is a map that can include the following keys:\\n   :eof - value to return on end-of-file. When not supplied, eof throws an exception.\\n   :readers  - a map of tag symbols to data-reader functions to be considered before default-data-readers.\\n              When not supplied, only the default-data-readers will be used.\\n   :default - A function of two args, that will, if present and no reader is found for a tag,\\n              be called with the tag and the value.\"\n ([reader] (read {} reader))\n ([{:keys [eof], :as opts} reader]\n  (let\n   [eof-error? (not (contains? opts :eof))]\n   (read reader eof-error? eof opts)))\n ([reader eof-error? eof opts]\n  (try\n   (loop\n    []\n    (let\n     [ch (read-char reader)]\n     (cond\n      (whitespace? ch)\n      (recur)\n      (nil? ch)\n      (if eof-error? (err/throw-eof-error reader nil) eof)\n      (number-literal? reader ch)\n      (read-number reader ch opts)\n      :else\n      (let\n       [f (macros ch)]\n       (if\n        f\n        (let\n         [res (f reader ch opts)]\n         (if (identical? res reader) (recur) res))\n        (read-symbol reader ch))))))\n   (catch\n    js/Error\n    e\n    (if\n     (ex-info? e)\n     (let\n      [d (ex-data e)]\n      (if\n       (= :reader-exception (:type d))\n       (throw e)\n       (throw\n        (ex-info\n         (.-message e)\n         (merge\n          {:type :reader-exception}\n          d\n          (if\n           (indexing-reader? reader)\n           {:line (get-line-number reader),\n            :column (get-column-number reader),\n            :file (get-file-name reader)}))\n         e))))\n     (throw\n      (ex-info\n       (.-message e)\n       (merge\n        {:type :reader-exception}\n        (if\n         (indexing-reader? reader)\n         {:line (get-line-number reader),\n          :column (get-column-number reader),\n          :file (get-file-name reader)}))\n       e)))))))\n"} {:sym read-string, :meta {:doc "Reads one object from the string s.\n   Returns nil when s is nil or empty.\n\n   Reads data in the edn format (subset of Clojure data):\n   http://edn-format.org\n\n   opts is a map as per clojure.tools.reader.edn/read", :arglists [[s] [opts s]]}, :source "(defn\n read-string\n \"Reads one object from the string s.\\n   Returns nil when s is nil or empty.\\n\\n   Reads data in the edn format (subset of Clojure data):\\n   http://edn-format.org\\n\\n   opts is a map as per clojure.tools.reader.edn/read\"\n ([s] (read-string {:eof nil} s))\n ([opts s]\n  (when (and s (not= s \"\")) (read opts (string-push-back-reader s)))))\n"}), cljs.source-map.base64-vlq ({:sym vlq-base-shift, :meta {}, :source "(def vlq-base-shift 5)\n"} {:sym vlq-base, :meta {}, :source "(def vlq-base (bit-shift-left 1 vlq-base-shift))\n"} {:sym vlq-base-mask, :meta {}, :source "(def vlq-base-mask (dec vlq-base))\n"} {:sym vlq-continuation-bit, :meta {}, :source "(def vlq-continuation-bit vlq-base)\n"} {:sym to-vlq-signed, :meta {:doc nil, :arglists ([v])}, :source "(defn\n to-vlq-signed\n [v]\n (if\n  (neg? v)\n  (inc (bit-shift-left (- v) 1))\n  (+ (bit-shift-left v 1) 0)))\n"} {:sym from-vlq-signed, :meta {:doc nil, :arglists ([v])}, :source "(defn\n from-vlq-signed\n [v]\n (let\n  [neg? (= (bit-and v 1) 1) shifted (bit-shift-right v 1)]\n  (if neg? (- shifted) shifted)))\n"} {:sym encode-val, :meta {:doc nil, :arglists ([n])}, :source "(defn\n encode-val\n [n]\n (let\n  [sb (StringBuffer.) vlq (to-vlq-signed n)]\n  (loop\n   [digit\n    (bit-and vlq vlq-base-mask)\n    vlq\n    (bit-shift-right-zero-fill vlq vlq-base-shift)]\n   (if\n    (pos? vlq)\n    (let\n     [digit (bit-or digit vlq-continuation-bit)]\n     (.append sb (base64/encode digit))\n     (recur\n      (bit-and vlq vlq-base-mask)\n      (bit-shift-right-zero-fill vlq vlq-base-shift)))\n    (.append sb (base64/encode digit))))\n  (str sb)))\n"} {:sym encode, :meta {:doc nil, :arglists ([v])}, :source "(defn encode [v] (apply str (map encode-val v)))\n"} {:sym decode, :meta {:doc nil, :arglists ([s])}, :source "(defn\n decode\n [s]\n (let\n  [l (.-length s)]\n  (loop\n   [i 0 result 0 shift 0]\n   (when\n    (>= i l)\n    (throw (js/Error. \"Expected more digits in base 64 VLQ value.\")))\n   (let\n    [digit (base64/decode (.charAt s i))]\n    (let\n     [i\n      (inc i)\n      continuation?\n      (pos? (bit-and digit vlq-continuation-bit))\n      digit\n      (bit-and digit vlq-base-mask)\n      result\n      (+ result (bit-shift-left digit shift))\n      shift\n      (+ shift vlq-base-shift)]\n     (if\n      continuation?\n      (recur i result shift)\n      (lazy-seq\n       (cons\n        (from-vlq-signed result)\n        (let\n         [s (.substring s i)]\n         (when-not (string/blank? s) (decode s)))))))))))\n"}), cljs.tools.reader ({:sym bool?, :meta {:doc nil, :arglists ([x])}, :source "(defn bool? [x] (or (instance? js/Boolean x) (true? x) (false? x)))\n"} {:sym *suppress-read*, :meta {}, :source "(def *suppress-read* false)\n"} {:sym *default-data-reader-fn*, :meta {}, :source "(def\n *default-data-reader-fn*\n \"When no data reader is found for a tag and *default-data-reader-fn*\\n  is non-nil, it will be called with two arguments, the tag and the value.\\n  If *default-data-reader-fn* is nil (the default value), an exception\\n  will be thrown for the unknown tag.\"\n nil)\n"} {:sym read, :meta {:doc "Reads the first object from an IPushbackReader.\n   Returns the object read. If EOF, throws if eof-error? is true.\n   Otherwise returns sentinel. If no stream is providen, *in* will be used.\n\n   Opts is a persistent map with valid keys:\n    :read-cond - :allow to process reader conditionals, or\n                 :preserve to keep all branches\n    :features - persistent set of feature keywords for reader conditionals\n    :eof - on eof, return value unless :eofthrow, then throw.\n           if not specified, will throw\n\n   To read data structures only, use clojure.tools.reader.edn/read\n\n   Note that the function signature of clojure.tools.reader/read and\n   clojure.tools.reader.edn/read is not the same for eof-handling", :arglists [[reader] [{eof :eof, :as opts, :or {eof :eofthrow}} reader] [reader eof-error? sentinel]]}, :source "(defn\n read\n \"Reads the first object from an IPushbackReader.\\n   Returns the object read. If EOF, throws if eof-error? is true.\\n   Otherwise returns sentinel. If no stream is providen, *in* will be used.\\n\\n   Opts is a persistent map with valid keys:\\n    :read-cond - :allow to process reader conditionals, or\\n                 :preserve to keep all branches\\n    :features - persistent set of feature keywords for reader conditionals\\n    :eof - on eof, return value unless :eofthrow, then throw.\\n           if not specified, will throw\\n\\n   To read data structures only, use clojure.tools.reader.edn/read\\n\\n   Note that the function signature of clojure.tools.reader/read and\\n   clojure.tools.reader.edn/read is not the same for eof-handling\"\n {:arglists '([] [reader] [opts reader] [reader eof-error? eof-value])}\n ([reader] (read reader true nil))\n ([{eof :eof, :as opts, :or {eof :eofthrow}} reader]\n  (read* reader (= eof :eofthrow) eof nil opts (to-array [])))\n ([reader eof-error? sentinel]\n  (read* reader eof-error? sentinel nil {} (to-array []))))\n"} {:sym default-data-readers, :meta {}, :source "(def\n default-data-readers\n \"Default map of data reader functions provided by Clojure.\\n  May be overridden by binding *data-readers*\"\n {})\n"} {:sym *data-readers*, :meta {}, :source "(def\n *data-readers*\n \"Map from reader tag symbols to data reader Vars.\\n  Reader tags without namespace qualifiers are reserved for Clojure.\\n  This light version of tools.reader has no implementation for default\\n  reader tags such as #inst and #uuid.\"\n {})\n"} {:sym *read-delim*, :meta {}, :source "(def *read-delim* false)\n"} {:sym resolve-symbol, :meta {:doc "Resolve a symbol s into its fully qualified namespace version", :arglists ([s])}, :source "(defn\n resolve-symbol\n \"Resolve a symbol s into its fully qualified namespace version\"\n [s]\n (throw (ex-info \"resolve-symbol is not implemented\" {:sym s})))\n"} {:sym *alias-map*, :meta {}, :source "(def\n *alias-map*\n \"Map from ns alias to ns, if non-nil, it will be used to resolve read-time\\n   ns aliases.\\n\\n   Defaults to nil\"\n nil)\n"} {:sym read-regex, :meta {:doc nil, :arglists ([rdr ch opts pending-forms])}, :source "(defn\n read-regex\n [rdr ch opts pending-forms]\n (let\n  [sb (StringBuffer.)]\n  (loop\n   [ch (read-char rdr)]\n   (if\n    (identical? \\\" ch)\n    (re-pattern (str sb))\n    (if\n     (nil? ch)\n     (err/throw-eof-reading rdr :regex sb)\n     (do\n      (.append sb ch)\n      (when\n       (identical? \\\\ ch)\n       (let\n        [ch (read-char rdr)]\n        (if (nil? ch) (err/throw-eof-reading rdr :regex sb))\n        (.append sb ch)))\n      (recur (read-char rdr))))))))\n"} {:sym sb, :meta {}, :source "(def sb (StringBuffer.))\n"} {:sym read-string, :meta {:doc "Reads one object from the string s.\n   Returns nil when s is nil or empty.\n\n   To read data structures only, use clojure.tools.reader.edn/read-string\n\n   Note that the function signature of clojure.tools.reader/read-string and\n   clojure.tools.reader.edn/read-string is not the same for eof-handling", :arglists [[s] [opts s]]}, :source "(defn\n read-string\n \"Reads one object from the string s.\\n   Returns nil when s is nil or empty.\\n\\n   To read data structures only, use clojure.tools.reader.edn/read-string\\n\\n   Note that the function signature of clojure.tools.reader/read-string and\\n   clojure.tools.reader.edn/read-string is not the same for eof-handling\"\n ([s] (read-string {} s))\n ([opts s]\n  (when\n   (and s (not (identical? s \"\")))\n   (read opts (string-push-back-reader s)))))\n"} {:sym map-func, :meta {:doc "Decide which map type to use, array-map if less than 16 elements", :arglists ([coll])}, :source "(defn\n map-func\n \"Decide which map type to use, array-map if less than 16 elements\"\n [coll]\n (if (>= (count coll) 16) 'cljs.core/hash-map 'cljs.core/array-map))\n"}), cljs.tools.reader.impl.errors ({:sym throw-bad-dispatch, :meta {:doc nil, :arglists ([rdr ch])}, :source "(defn\n throw-bad-dispatch\n [rdr ch]\n (reader-error rdr \"No dispatch macro for \" ch \".\"))\n"} {:sym throw-invalid-unicode-escape, :meta {:doc nil, :arglists ([rdr ch])}, :source "(defn\n throw-invalid-unicode-escape\n [rdr ch]\n (reader-error rdr \"Invalid unicode escape: \\\\u\" ch \".\"))\n"} {:sym throw-dup-keys, :meta {:doc nil, :arglists ([rdr kind ks])}, :source "(defn\n throw-dup-keys\n [rdr kind ks]\n (reader-error\n  rdr\n  (duplicate-keys-error\n   (str (s/capitalize (name kind)) \" literal contains duplicate key\")\n   ks)))\n"} {:sym throw-bad-ns, :meta {:doc nil, :arglists ([rdr ns-name])}, :source "(defn\n throw-bad-ns\n [rdr ns-name]\n (reader-error\n  rdr\n  \"Invalid value used as namespace in namespaced map: \"\n  ns-name\n  \".\"))\n"} {:sym throw-unknown-reader-tag, :meta {:doc nil, :arglists ([rdr tag])}, :source "(defn\n throw-unknown-reader-tag\n [rdr tag]\n (reader-error rdr \"No reader function for tag \" (i/inspect tag) \".\"))\n"} {:sym throw-eof-at-dispatch, :meta {:doc nil, :arglists ([rdr])}, :source "(defn\n throw-eof-at-dispatch\n [rdr]\n (eof-error rdr \"Unexpected EOF while reading dispatch character.\"))\n"} {:sym throw-bad-metadata-target, :meta {:doc nil, :arglists ([rdr target])}, :source "(defn\n throw-bad-metadata-target\n [rdr target]\n (reader-error\n  rdr\n  \"Metadata can not be applied to \"\n  (i/inspect target)\n  \". \"\n  \"Metadata can only be applied to IMetas.\"))\n"} {:sym throw-invalid-number, :meta {:doc nil, :arglists ([rdr token])}, :source "(defn\n throw-invalid-number\n [rdr token]\n (reader-error rdr \"Invalid number: \" token \".\"))\n"} {:sym reader-error, :meta {:doc "Throws an ExceptionInfo with the given message.\n   If rdr is an IndexingReader, additional information about column and line number is provided", :arglists ([rdr & msgs])}, :source "(defn\n reader-error\n \"Throws an ExceptionInfo with the given message.\\n   If rdr is an IndexingReader, additional information about column and line number is provided\"\n [rdr & msgs]\n (throw-ex rdr :reader-error (apply str msgs)))\n"} {:sym throw-invalid-unicode-literal, :meta {:doc nil, :arglists ([rdr token])}, :source "(defn\n throw-invalid-unicode-literal\n [rdr token]\n (throw\n  (illegal-arg-error rdr \"Invalid unicode literal: \\\\\" token \".\")))\n"} {:sym throw-ns-map-no-map, :meta {:doc nil, :arglists ([rdr ns-name])}, :source "(defn\n throw-ns-map-no-map\n [rdr ns-name]\n (reader-error\n  rdr\n  \"Namespaced map with namespace \"\n  ns-name\n  \" does not specify a map.\"))\n"} {:sym throw-unsupported-character, :meta {:doc nil, :arglists ([rdr token])}, :source "(defn\n throw-unsupported-character\n [rdr token]\n (reader-error rdr \"Unsupported character: \" token \".\"))\n"} {:sym throw-feature-not-keyword, :meta {:doc nil, :arglists ([rdr feature])}, :source "(defn\n throw-feature-not-keyword\n [rdr feature]\n (reader-error\n  rdr\n  \"Feature cannot be \"\n  (i/inspect feature)\n  \" Features must be keywords.\"))\n"} {:sym throw-eof-delimited, :meta {:doc nil, :arglists [[rdr kind column line] [rdr kind line column n]]}, :source "(defn\n throw-eof-delimited\n ([rdr kind column line]\n  (throw-eof-delimited rdr kind line column nil))\n ([rdr kind line column n]\n  (eof-error\n   rdr\n   \"Unexpected EOF while reading \"\n   (if n (str \"item \" n \" of \"))\n   (name kind)\n   (if line (str \", starting at line \" line \" and column \" column))\n   \".\")))\n"} {:sym throw-eof-in-character, :meta {:doc nil, :arglists ([rdr])}, :source "(defn\n throw-eof-in-character\n [rdr]\n (eof-error rdr \"Unexpected EOF while reading character.\"))\n"} {:sym throw-bad-char, :meta {:doc nil, :arglists ([rdr kind ch])}, :source "(defn\n throw-bad-char\n [rdr kind ch]\n (reader-error\n  rdr\n  \"Invalid character: \"\n  ch\n  \" found while reading \"\n  (name kind)\n  \".\"))\n"} {:sym eof-error, :meta {:doc "Throws an ExceptionInfo with the given message.\n   If rdr is an IndexingReader, additional information about column and line number is provided", :arglists ([rdr & msgs])}, :source "(defn\n eof-error\n \"Throws an ExceptionInfo with the given message.\\n   If rdr is an IndexingReader, additional information about column and line number is provided\"\n [rdr & msgs]\n (throw-ex rdr :eof (apply str msgs)))\n"} {:sym throw-bad-metadata, :meta {:doc nil, :arglists ([rdr x])}, :source "(defn\n throw-bad-metadata\n [rdr x]\n (reader-error\n  rdr\n  \"Metadata cannot be \"\n  (i/inspect x)\n  \". Metadata must be a Symbol, Keyword, String or Map.\"))\n"} {:sym throw-eof-reading, :meta {:doc nil, :arglists ([rdr kind & start])}, :source "(defn\n throw-eof-reading\n [rdr kind & start]\n (let\n  [init (case kind :regex \"#\\\"\" :string \\\")]\n  (eof-error\n   rdr\n   \"Unexpected EOF reading \"\n   (name kind)\n   \" starting \"\n   (apply str init start)\n   \".\")))\n"} {:sym throw-eof-error, :meta {:doc nil, :arglists ([rdr line])}, :source "(defn\n throw-eof-error\n [rdr line]\n (if\n  line\n  (eof-error rdr \"EOF while reading, starting at line \" line \".\")\n  (eof-error rdr \"EOF while reading.\")))\n"} {:sym illegal-arg-error, :meta {:doc "Throws an ExceptionInfo with the given message.\n   If rdr is an IndexingReader, additional information about column and line number is provided", :arglists ([rdr & msgs])}, :source "(defn\n illegal-arg-error\n \"Throws an ExceptionInfo with the given message.\\n   If rdr is an IndexingReader, additional information about column and line number is provided\"\n [rdr & msgs]\n (throw-ex rdr :illegal-argument (apply str msgs)))\n"} {:sym throw-invalid-octal-len, :meta {:doc nil, :arglists ([rdr token])}, :source "(defn\n throw-invalid-octal-len\n [rdr token]\n (reader-error\n  rdr\n  \"Invalid octal escape sequence in a character literal:\"\n  token\n  \". Octal escape sequences must be 3 or fewer digits.\"))\n"} {:sym throw-invalid-unicode-digit, :meta {:doc nil, :arglists ([rdr ch])}, :source "(defn\n throw-invalid-unicode-digit\n [rdr ch]\n (illegal-arg-error rdr \"Invalid digit \" ch \" in unicode character.\"))\n"} {:sym throw-invalid-unicode-digit-in-token, :meta {:doc nil, :arglists ([rdr ch token])}, :source "(defn\n throw-invalid-unicode-digit-in-token\n [rdr ch token]\n (illegal-arg-error\n  rdr\n  \"Invalid digit \"\n  ch\n  \" in unicode character \\\\\"\n  token\n  \".\"))\n"} {:sym throw-invalid-unicode-len, :meta {:doc nil, :arglists ([rdr actual expected])}, :source "(defn\n throw-invalid-unicode-len\n [rdr actual expected]\n (illegal-arg-error\n  rdr\n  \"Invalid unicode literal. Unicode literals should be \"\n  expected\n  \"characters long.  \"\n  \"value suppled is \"\n  actual\n  \"characters long.\"))\n"} {:sym throw-single-colon, :meta {:doc nil, :arglists ([rdr])}, :source "(defn\n throw-single-colon\n [rdr]\n (reader-error rdr \"A single colon is not a valid keyword.\"))\n"} {:sym throw-odd-map, :meta {:doc nil, :arglists ([rdr line col elements])}, :source "(defn\n throw-odd-map\n [rdr line col elements]\n (reader-error\n  rdr\n  \"The map literal starting with \"\n  (i/inspect (first elements))\n  (if line (str \" on line \" line \" column \" col))\n  \" contains \"\n  (count elements)\n  \" form(s). Map literals must contain an even number of forms.\"))\n"} {:sym throw-bad-octal-number, :meta {:doc nil, :arglists ([rdr])}, :source "(defn\n throw-bad-octal-number\n [rdr]\n (reader-error rdr \"Octal escape sequence must be in range [0, 377].\"))\n"} {:sym throw-bad-reader-tag, :meta {:doc nil, :arglists ([rdr tag])}, :source "(defn\n throw-bad-reader-tag\n [rdr tag]\n (reader-error\n  rdr\n  \"Invalid reader tag: \"\n  (i/inspect tag)\n  \". Reader tags must be symbols.\"))\n"} {:sym throw-unmatch-delimiter, :meta {:doc nil, :arglists ([rdr ch])}, :source "(defn\n throw-unmatch-delimiter\n [rdr ch]\n (reader-error rdr \"Unmatched delimiter \" ch \".\"))\n"} {:sym throw-invalid-character-literal, :meta {:doc nil, :arglists ([rdr token])}, :source "(defn\n throw-invalid-character-literal\n [rdr token]\n (reader-error rdr \"Invalid character literal \\\\u\" token \".\"))\n"} {:sym throw-invalid-unicode-char, :meta {:doc nil, :arglists ([rdr token])}, :source "(defn\n throw-invalid-unicode-char\n [rdr token]\n (reader-error rdr \"Invalid unicode character \\\\\" token \".\"))\n"} {:sym throw-bad-escape-char, :meta {:doc nil, :arglists ([rdr ch])}, :source "(defn\n throw-bad-escape-char\n [rdr ch]\n (reader-error rdr \"Unsupported escape character: \\\\\" ch \".\"))\n"} {:sym throw-no-dispatch, :meta {:doc nil, :arglists ([rdr ch])}, :source "(defn throw-no-dispatch [rdr ch] (throw-bad-dispatch rdr ch))\n"} {:sym throw-eof-at-start, :meta {:doc nil, :arglists ([rdr kind])}, :source "(defn\n throw-eof-at-start\n [rdr kind]\n (eof-error\n  rdr\n  \"Unexpected EOF while reading start of \"\n  (name kind)\n  \".\"))\n"} {:sym throw-invalid, :meta {:doc nil, :arglists ([rdr kind token])}, :source "(defn\n throw-invalid\n [rdr kind token]\n (reader-error rdr \"Invalid \" (name kind) \": \" token \".\"))\n"}), cljs.js ({:sym *load-fn*, :meta {:doc "Each runtime environment provides a different way to load a library.\n  Whatever function *load-fn* is bound to will be passed two arguments - a\n  map and a callback function: The map will have the following keys:\n\n  :name   - the name of the library (a symbol)\n  :macros - modifier signaling a macros namespace load\n  :path   - munged relative library path (a string)\n\n  It is up to the implementor to correctly resolve the corresponding .cljs,\n  .cljc, or .js resource (the order must be respected). If :macros is true\n  resolution should only consider .clj or .cljc resources (the order must be\n  respected). Upon resolution the callback should be invoked with a map\n  containing the following keys:\n\n  :lang       - the language, :clj or :js\n  :source     - the source of the library (a string)\n  :file       - optional, the file path, it will be added to AST's :file keyword\n                (but not in :meta)\n  :cache      - optional, if a :clj namespace has been precompiled to :js, can\n                give an analysis cache for faster loads.\n  :source-map - optional, if a :clj namespace has been precompiled to :js, can\n                give a V3 source map JSON\n\n  If the resource could not be resolved, the callback should be invoked with\n  nil."}, :source "(defonce *load-fn* (fn [m cb] (throw (js/Error. \"No *load-fn* set\"))))\n"} {:sym eval, :meta {:doc "Evaluate a single ClojureScript form. The parameters:\n\n   state (atom)\n     the compiler state\n\n   form (s-expr)\n     the ClojureScript source\n\n   opts (map)\n     compilation options.\n\n      :eval             - eval function to invoke, see *eval-fn*\n      :load             - library resolution function, see *load-fn*\n      :source-map       - set to true to generate inline source map information\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\n                          (if set to true) or the def init value (if false). Default\n                          is false.\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                          to aget/aset. Logs for incorrect values if :warn, throws if\n                          :error. Defaults to false.\n      :static-fns       - employ static dispatch to specific function arities in\n                          emitted JavaScript, as opposed to making use of the\n                          `call` construct. Defaults to false.\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                          unknown functions, but instead direct invokes via\n                          `f(a0,a1...)`. Defaults to `false`.\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                          at the moment.\n      :ns               - optional, the namespace in which to evaluate the source.\n      :verbose          - optional, emit details from compiler activity. Defaults to\n                          false.\n      :context          - optional, sets the context for the source. Possible values\n                          are `:expr`, `:statement` and `:return`. Defaults to\n                          `:expr`.\n\n   cb (function)\n     callback, will be invoked with a map. If successful the map will contain\n     a key :value with the result of evalution. If unsuccessful the map will\n     contain a key :error with an ex-info instance describing the cause of\n     failure.", :arglists [[state form cb] [state form opts cb]]}, :source "(defn\n eval\n \"Evaluate a single ClojureScript form. The parameters:\\n\\n   state (atom)\\n     the compiler state\\n\\n   form (s-expr)\\n     the ClojureScript source\\n\\n   opts (map)\\n     compilation options.\\n\\n      :eval             - eval function to invoke, see *eval-fn*\\n      :load             - library resolution function, see *load-fn*\\n      :source-map       - set to true to generate inline source map information\\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\\n                          (if set to true) or the def init value (if false). Default\\n                          is false.\\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\\n                          to aget/aset. Logs for incorrect values if :warn, throws if\\n                          :error. Defaults to false.\\n      :static-fns       - employ static dispatch to specific function arities in\\n                          emitted JavaScript, as opposed to making use of the\\n                          `call` construct. Defaults to false.\\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\\n                          unknown functions, but instead direct invokes via\\n                          `f(a0,a1...)`. Defaults to `false`.\\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\\n                          at the moment.\\n      :ns               - optional, the namespace in which to evaluate the source.\\n      :verbose          - optional, emit details from compiler activity. Defaults to\\n                          false.\\n      :context          - optional, sets the context for the source. Possible values\\n                          are `:expr`, `:statement` and `:return`. Defaults to\\n                          `:expr`.\\n\\n   cb (function)\\n     callback, will be invoked with a map. If successful the map will contain\\n     a key :value with the result of evalution. If unsuccessful the map will\\n     contain a key :error with an ex-info instance describing the cause of\\n     failure.\"\n ([state form cb] (eval state form nil cb))\n ([state form opts cb]\n  (eval*\n   {:*compiler* state,\n    :*data-readers* tags/*cljs-data-readers*,\n    :*analyze-deps* (:analyze-deps opts true),\n    :*cljs-dep-set* ana/*cljs-dep-set*,\n    :*load-macros* (:load-macros opts true),\n    :*load-fn* (or (:load opts) *load-fn*),\n    :*eval-fn* (or (:eval opts) *eval-fn*)}\n   form\n   opts\n   cb)))\n"} {:sym compile-str, :meta {:doc "Compile ClojureScript source into JavaScript. The parameters:\n\n   state (atom)\n     the compiler state\n\n   source (string)\n     the ClojureScript source\n\n   name (symbol or string)\n     optional, the name of the source\n\n   opts (map)\n     compilation options.\n\n      :eval             - eval function to invoke, see *eval-fn*\n      :load             - library resolution function, see *load-fn*\n      :source-map       - set to true to generate inline source map information\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\n                          (if set to true) or the def init value (if false). Default\n                          is false.\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                          to aget/aset. Logs for incorrect values if :warn, throws if\n                          :error. Defaults to false.\n      :static-fns       - employ static dispatch to specific function arities in\n                          emitted JavaScript, as opposed to making use of the\n                          `call` construct. Defaults to false.\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                          unknown functions, but instead direct invokes via\n                          `f(a0,a1...)`. Defaults to `false`.\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                          at the moment.\n      :ns               - optional, the namespace in which to evaluate the source.\n      :verbose          - optional, emit details from compiler activity. Defaults to\n                          false.\n      :context          - optional, sets the context for the source. Possible values\n                          are `:expr`, `:statement` and `:return`. Defaults to\n                          `:expr`.\n\n   cb (function)\n     callback, will be invoked with a map. If successful the map will contain\n     a key :value with the compilation result (string). If unsuccessful the map\n     will contain a key :error with an ex-info instance describing the cause\n     of failure.", :arglists [[state source cb] [state source name cb] [state source name opts cb]]}, :source "(defn\n compile-str\n \"Compile ClojureScript source into JavaScript. The parameters:\\n\\n   state (atom)\\n     the compiler state\\n\\n   source (string)\\n     the ClojureScript source\\n\\n   name (symbol or string)\\n     optional, the name of the source\\n\\n   opts (map)\\n     compilation options.\\n\\n      :eval             - eval function to invoke, see *eval-fn*\\n      :load             - library resolution function, see *load-fn*\\n      :source-map       - set to true to generate inline source map information\\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\\n                          (if set to true) or the def init value (if false). Default\\n                          is false.\\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\\n                          to aget/aset. Logs for incorrect values if :warn, throws if\\n                          :error. Defaults to false.\\n      :static-fns       - employ static dispatch to specific function arities in\\n                          emitted JavaScript, as opposed to making use of the\\n                          `call` construct. Defaults to false.\\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\\n                          unknown functions, but instead direct invokes via\\n                          `f(a0,a1...)`. Defaults to `false`.\\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\\n                          at the moment.\\n      :ns               - optional, the namespace in which to evaluate the source.\\n      :verbose          - optional, emit details from compiler activity. Defaults to\\n                          false.\\n      :context          - optional, sets the context for the source. Possible values\\n                          are `:expr`, `:statement` and `:return`. Defaults to\\n                          `:expr`.\\n\\n   cb (function)\\n     callback, will be invoked with a map. If successful the map will contain\\n     a key :value with the compilation result (string). If unsuccessful the map\\n     will contain a key :error with an ex-info instance describing the cause\\n     of failure.\"\n ([state source cb] (compile-str state source nil cb))\n ([state source name cb] (compile-str state source name nil cb))\n ([state source name opts cb]\n  {:pre\n   [(atom? state)\n    (string? source)\n    (valid-name? name)\n    (valid-opts? opts)\n    (fn? cb)]}\n  (compile-str*\n   {:*compiler* state,\n    :*data-readers* tags/*cljs-data-readers*,\n    :*cljs-dep-set* ana/*cljs-dep-set*,\n    :*analyze-deps* (:analyze-deps opts true),\n    :*load-macros* (:load-macros opts true),\n    :*load-fn* (or (:load opts) *load-fn*),\n    :*eval-fn* (or (:eval opts) *eval-fn*),\n    :*sm-data* (when (:source-map opts) (sm-data))}\n   source\n   name\n   opts\n   cb)))\n"} {:sym ns->relpath, :meta {:doc "Given a namespace as a symbol return the relative path sans extension", :arglists ([ns-sym])}, :source "(defn\n ns->relpath\n \"Given a namespace as a symbol return the relative path sans extension\"\n [ns-sym]\n (string/replace (ana/munge-path ns-sym) \\. \\/))\n"} {:sym *loaded*, :meta {}, :source "(def *loaded* (atom #{}))\n"} {:sym require, :meta {:doc nil, :arglists [[name cb] [name opts cb] [bound-vars name opts cb] [bound-vars name reload opts cb]]}, :source "(defn\n require\n ([name cb] (require name nil cb))\n ([name opts cb] (require nil name opts cb))\n ([bound-vars name opts cb] (require bound-vars name nil opts cb))\n ([bound-vars name reload opts cb]\n  (let\n   [bound-vars\n    (merge\n     {:*compiler* (env/default-compiler-env),\n      :*data-readers* tags/*cljs-data-readers*,\n      :*load-macros* (:load-macros opts true),\n      :*analyze-deps* (:analyze-deps opts true),\n      :*load-fn* (or (:load opts) *load-fn*),\n      :*eval-fn* (or (:eval opts) *eval-fn*)}\n     bound-vars)\n    aname\n    (cond-> name (:macros-ns opts) ana/macro-ns-name)]\n   (when (= :reload reload) (swap! *loaded* disj aname))\n   (when (= :reload-all reload) (reset! *loaded* #{}))\n   (when\n    (:verbose opts)\n    (debug-prn\n     (str\n      \"Loading \"\n      name\n      (when (:macros-ns opts) \" macros\")\n      \" namespace\")))\n   (if-not\n    (contains? @*loaded* aname)\n    (let\n     [env (:*env* bound-vars)]\n     (try\n      ((:*load-fn* bound-vars)\n       {:name name,\n        :macros (:macros-ns opts),\n        :path (ns->relpath name)}\n       (fn\n        [resource]\n        (assert\n         (or (map? resource) (nil? resource))\n         \"*load-fn* may only return a map or nil\")\n        (if\n         resource\n         (let\n          [{:keys [lang source cache source-map file]} resource]\n          (condp\n           keyword-identical?\n           lang\n           :clj\n           (do\n            (pre-file-side-effects\n             (:*compiler* bound-vars)\n             aname\n             file\n             opts)\n            (eval-str*\n             bound-vars\n             source\n             name\n             (assoc opts :cljs-file file)\n             (fn\n              [res]\n              (post-file-side-effects file opts)\n              (if\n               (:error res)\n               (cb res)\n               (do (swap! *loaded* conj aname) (cb {:value true}))))))\n           :js\n           (process-macros-deps\n            bound-vars\n            cache\n            opts\n            (fn\n             [res]\n             (if\n              (:error res)\n              (cb res)\n              (process-libs-deps\n               bound-vars\n               cache\n               opts\n               (fn\n                [res]\n                (if\n                 (:error res)\n                 (cb res)\n                 (let\n                  [res\n                   (try\n                    ((:*eval-fn* bound-vars) resource)\n                    (when\n                     cache\n                     (load-analysis-cache!\n                      (:*compiler* bound-vars)\n                      aname\n                      cache)\n                     (ana/register-specs cache))\n                    (when\n                     source-map\n                     (load-source-map!\n                      (:*compiler* bound-vars)\n                      aname\n                      source-map))\n                    (catch\n                     :default\n                     cause\n                     (wrap-error\n                      (ana/error\n                       env\n                       (str \"Could not require \" name)\n                       cause))))]\n                  (if\n                   (:error res)\n                   (cb res)\n                   (do\n                    (swap! *loaded* conj aname)\n                    (cb {:value true}))))))))))\n           (cb\n            (wrap-error\n             (ana/error\n              env\n              (str\n               \"Invalid :lang specified \"\n               lang\n               \", only :clj or :js allowed\"))))))\n         (cb\n          (wrap-error\n           (ana/error\n            env\n            (ana/error-message\n             (if\n              (:macros-ns opts)\n              :undeclared-macros-ns\n              :undeclared-ns)\n             {:ns-sym name, :js-provide (cljs.core/name name)})))))))\n      (catch\n       :default\n       cause\n       (cb\n        (wrap-error\n         (ana/error env (str \"Could not require \" name) cause))))))\n    (cb {:value true})))))\n"} {:sym file->ns, :meta {:doc nil, :arglists ([file])}, :source "(defn\n file->ns\n [file]\n (let\n  [lib-name (subs (string/replace file \"/\" \".\") 0 (- (count file) 5))]\n  (symbol (demunge lib-name))))\n"} {:sym eval-str, :meta {:doc "Evalute ClojureScript source given as a string. The parameters:\n\n  state (atom)\n    the compiler state\n\n  source (string)\n    the ClojureScript source\n\n  name (symbol or string)\n    optional, the name of the source\n\n  opts (map)\n    compilation options.\n\n    :eval             - eval function to invoke, see *eval-fn*\n    :load             - library resolution function, see *load-fn*\n    :source-map       - set to true to generate inline source map information\n    :cache-source     - optional, a function to run side-effects with the\n                        compilation result prior to actual evalution. This function\n                        takes two arguments, the first is the eval map, the source\n                        will be under :source. The second argument is a callback of\n                        one argument. If an error occurs an :error key should be\n                        supplied.\n    :def-emits-var    - sets whether def (and derived) forms return either a Var\n                        (if set to true) or the def init value (if false). Default\n                        is false.\n    :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                        to aget/aset. Logs for incorrect values if :warn, throws if\n                        :error. Defaults to false.\n    :static-fns       - employ static dispatch to specific function arities in\n                        emitted JavaScript, as opposed to making use of the\n                        `call` construct. Defaults to false.\n    :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                        unknown functions, but instead direct invokes via\n                        `f(a0,a1...)`. Defaults to `false`.\n    :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                        at the moment.\n    :ns               - optional, the namespace in which to evaluate the source.\n    :verbose          - optional, emit details from compiler activity. Defaults to\n                        false.\n    :context          - optional, sets the context for the source. Possible values\n                     are `:expr`, `:statement` and `:return`. Defaults to\n                      `:expr`.\n\n  cb (function)\n    callback, will be invoked with a map. If succesful the map will contain\n    a :value key with the result of evaluation and :ns the current namespace.\n    If unsuccessful will contain a :error key with an ex-info instance describing\n    the cause of failure.", :arglists [[state source cb] [state source name cb] [state source name opts cb]]}, :source "(defn\n eval-str\n \"Evalute ClojureScript source given as a string. The parameters:\\n\\n  state (atom)\\n    the compiler state\\n\\n  source (string)\\n    the ClojureScript source\\n\\n  name (symbol or string)\\n    optional, the name of the source\\n\\n  opts (map)\\n    compilation options.\\n\\n    :eval             - eval function to invoke, see *eval-fn*\\n    :load             - library resolution function, see *load-fn*\\n    :source-map       - set to true to generate inline source map information\\n    :cache-source     - optional, a function to run side-effects with the\\n                        compilation result prior to actual evalution. This function\\n                        takes two arguments, the first is the eval map, the source\\n                        will be under :source. The second argument is a callback of\\n                        one argument. If an error occurs an :error key should be\\n                        supplied.\\n    :def-emits-var    - sets whether def (and derived) forms return either a Var\\n                        (if set to true) or the def init value (if false). Default\\n                        is false.\\n    :checked-arrays   - if :warn or :error, checks inferred types and values passed\\n                        to aget/aset. Logs for incorrect values if :warn, throws if\\n                        :error. Defaults to false.\\n    :static-fns       - employ static dispatch to specific function arities in\\n                        emitted JavaScript, as opposed to making use of the\\n                        `call` construct. Defaults to false.\\n    :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\\n                        unknown functions, but instead direct invokes via\\n                        `f(a0,a1...)`. Defaults to `false`.\\n    :target           - use `:nodejs` if targeting Node.js. Takes no other options\\n                        at the moment.\\n    :ns               - optional, the namespace in which to evaluate the source.\\n    :verbose          - optional, emit details from compiler activity. Defaults to\\n                        false.\\n    :context          - optional, sets the context for the source. Possible values\\n                     are `:expr`, `:statement` and `:return`. Defaults to\\n                      `:expr`.\\n\\n  cb (function)\\n    callback, will be invoked with a map. If succesful the map will contain\\n    a :value key with the result of evaluation and :ns the current namespace.\\n    If unsuccessful will contain a :error key with an ex-info instance describing\\n    the cause of failure.\"\n ([state source cb] (eval-str state source nil cb))\n ([state source name cb] (eval-str state source name nil cb))\n ([state source name opts cb]\n  {:pre\n   [(atom? state)\n    (string? source)\n    (valid-name? name)\n    (valid-opts? opts)\n    (fn? cb)]}\n  (eval-str*\n   {:*compiler* state,\n    :*data-readers* tags/*cljs-data-readers*,\n    :*analyze-deps* (:analyze-deps opts true),\n    :*cljs-dep-set* ana/*cljs-dep-set*,\n    :*load-macros* (:load-macros opts true),\n    :*load-fn* (or (:load opts) *load-fn*),\n    :*eval-fn* (or (:eval opts) *eval-fn*)}\n   source\n   name\n   opts\n   cb)))\n"} {:sym js-eval, :meta {:doc "A default JavaScript evaluation function.", :arglists ([{:keys [source], :as resource}])}, :source "(defn\n js-eval\n \"A default JavaScript evaluation function.\"\n [{:keys [source], :as resource}]\n (js/eval source))\n"} {:sym load-source-map!, :meta {:doc nil, :arglists ([state ns sm-json])}, :source "(defn\n load-source-map!\n [state ns sm-json]\n (let\n  [sm (sm/decode (.parse js/JSON sm-json))]\n  (swap! state assoc-in [:source-maps ns] sm)))\n"} {:sym analyze-str, :meta {:doc "Analyze ClojureScript source. The compiler state will be populated with\n   the results of analyzes. The parameters:\n\n   state (atom)\n     the compiler state\n\n   source (string)\n     the ClojureScript source\n\n   name (symbol or string)\n     optional, the name of the source\n\n   opts (map)\n     compilation options.\n\n      :eval             - eval function to invoke, see *eval-fn*\n      :load             - library resolution function, see *load-fn*\n      :source-map       - set to true to generate inline source map information\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\n                          (if set to true) or the def init value (if false).\n                          Defaults to false.\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                          to aget/aset. Logs for incorrect values if :warn, throws if\n                          :error. Defaults to false.\n      :static-fns       - employ static dispatch to specific function arities in\n                          emitted JavaScript, as opposed to making use of the\n                          `call` construct. Defaults to false.\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                          unknown functions, but instead direct invokes via\n                          `f(a0,a1...)`. Defaults to `false`.\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                          at the moment.\n      :ns               - optional, the namespace in which to evaluate the source.\n      :verbose          - optional, emit details from compiler activity. Defaults to\n                          false.\n      :context          - optional, sets the context for the source. Possible values\n                          are `:expr`, `:statement` and `:return`. Defaults to\n                          `:expr`.\n\n   cb (function)\n     callback, will be invoked with a map. If successful the map will contain\n     a key :value, the actual value is not meaningful. If unsuccessful the\n     map will contain a key :error with an ex-info instance describing the cause\n     of failure.", :arglists [[state source cb] [state source name cb] [state source name opts cb]]}, :source "(defn\n analyze-str\n \"Analyze ClojureScript source. The compiler state will be populated with\\n   the results of analyzes. The parameters:\\n\\n   state (atom)\\n     the compiler state\\n\\n   source (string)\\n     the ClojureScript source\\n\\n   name (symbol or string)\\n     optional, the name of the source\\n\\n   opts (map)\\n     compilation options.\\n\\n      :eval             - eval function to invoke, see *eval-fn*\\n      :load             - library resolution function, see *load-fn*\\n      :source-map       - set to true to generate inline source map information\\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\\n                          (if set to true) or the def init value (if false).\\n                          Defaults to false.\\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\\n                          to aget/aset. Logs for incorrect values if :warn, throws if\\n                          :error. Defaults to false.\\n      :static-fns       - employ static dispatch to specific function arities in\\n                          emitted JavaScript, as opposed to making use of the\\n                          `call` construct. Defaults to false.\\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\\n                          unknown functions, but instead direct invokes via\\n                          `f(a0,a1...)`. Defaults to `false`.\\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\\n                          at the moment.\\n      :ns               - optional, the namespace in which to evaluate the source.\\n      :verbose          - optional, emit details from compiler activity. Defaults to\\n                          false.\\n      :context          - optional, sets the context for the source. Possible values\\n                          are `:expr`, `:statement` and `:return`. Defaults to\\n                          `:expr`.\\n\\n   cb (function)\\n     callback, will be invoked with a map. If successful the map will contain\\n     a key :value, the actual value is not meaningful. If unsuccessful the\\n     map will contain a key :error with an ex-info instance describing the cause\\n     of failure.\"\n ([state source cb] (analyze-str state source nil cb))\n ([state source name cb] (analyze-str state source name nil cb))\n ([state source name opts cb]\n  {:pre\n   [(atom? state)\n    (string? source)\n    (valid-name? name)\n    (valid-opts? opts)\n    (fn? cb)]}\n  (analyze-str*\n   {:*compiler* state,\n    :*data-readers* tags/*cljs-data-readers*,\n    :*passes* (or (:passes opts) ana/*passes*),\n    :*analyze-deps* (:analyze-deps opts true),\n    :*cljs-dep-set* ana/*cljs-dep-set*,\n    :*load-macros* (:load-macros opts true),\n    :*load-fn* (or (:load opts) *load-fn*),\n    :*eval-fn* (or (:eval opts) *eval-fn*)}\n   source\n   name\n   opts\n   cb)))\n"} {:sym *eval-fn*, :meta {:doc "Each runtime environment provides various ways to eval JavaScript\n  source. Whatever function *eval-fn* is bound to will be passed a map\n  containing the following keys:\n\n  :source - the source of the library (string)\n  :name   - used to unique identify the script (symbol)\n  :cache  - if the source was originally ClojureScript, will be given the\n            analysis cache.\n\n  The result of evaluation should be the return value."}, :source "(defonce *eval-fn* (fn [m] (throw (js/Error. \"No *eval-fn* set\"))))\n"}), cljs.core ({:sym sort-by, :meta {:doc "Returns a sorted sequence of the items in coll, where the sort\n   order is determined by comparing (keyfn item).  Comp can be\n   boolean-valued comparison funcion, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :arglists [[keyfn coll] [keyfn comp coll]]}, :source "(defn\n sort-by\n \"Returns a sorted sequence of the items in coll, where the sort\\n   order is determined by comparing (keyfn item).  Comp can be\\n   boolean-valued comparison funcion, or a -/0/+ valued comparator.\\n   Comp defaults to compare.\"\n ([keyfn coll] (sort-by keyfn compare coll))\n ([keyfn comp coll]\n  (sort (fn [x y] ((fn->comparator comp) (keyfn x) (keyfn y))) coll)))\n"} {:sym ITransientAssociative, :meta {:doc "Protocol for adding associativity to transient collections."}, :methods (-assoc!)} {:sym chunk-first, :meta {:doc nil, :arglists ([s])}, :source "(defn chunk-first [s] (-chunked-first s))\n"} {:sym m3-hash-int, :meta {:doc nil, :arglists ([in])}, :source "(defn\n m3-hash-int\n [in]\n (if\n  (zero? in)\n  in\n  (let [k1 (m3-mix-K1 in) h1 (m3-mix-H1 m3-seed k1)] (m3-fmix h1 4))))\n"} {:sym pr-str*, :meta {:doc "Support so that collections can implement toString without\n   loading all the printing machinery.", :arglists ([obj])}, :source "(defn\n pr-str*\n \"Support so that collections can implement toString without\\n   loading all the printing machinery.\"\n [obj]\n (let\n  [sb (StringBuffer.) writer (StringBufferWriter. sb)]\n  (-pr-writer obj writer (pr-opts))\n  (-flush writer)\n  (str sb)))\n"} {:sym tree-seq, :meta {:doc "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n  branch? must be a fn of one arg that returns true if passed a node\n  that can have children (but may not).  children must be a fn of one\n  arg that returns a sequence of the children. Will only be called on\n  nodes for which branch? returns true. Root is the root node of the\n  tree.", :arglists ([branch? children root])}, :source "(defn\n tree-seq\n \"Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\\n  branch? must be a fn of one arg that returns true if passed a node\\n  that can have children (but may not).  children must be a fn of one\\n  arg that returns a sequence of the children. Will only be called on\\n  nodes for which branch? returns true. Root is the root node of the\\n  tree.\"\n [branch? children root]\n (let\n  [walk\n   (fn\n    walk\n    [node]\n    (lazy-seq\n     (cons node (when (branch? node) (mapcat walk (children node))))))]\n  (walk root)))\n"} {:sym unchecked-remainder-int, :meta {:doc nil, :arglists ([x n])}, :source "(defn\n unchecked-remainder-int\n [x n]\n (cljs.core/unchecked-remainder-int x n))\n"} {:sym seq, :meta {:doc "Returns a seq on the collection. If the collection is\n  empty, returns nil.  (seq nil) returns nil. seq also works on\n  Strings.", :arglists ([coll])}, :source "(defn\n seq\n \"Returns a seq on the collection. If the collection is\\n  empty, returns nil.  (seq nil) returns nil. seq also works on\\n  Strings.\"\n [coll]\n (when-not\n  (nil? coll)\n  (cond\n   (implements? ISeqable coll)\n   (-seq coll)\n   (array? coll)\n   (when-not (zero? (alength coll)) (IndexedSeq. coll 0 nil))\n   (string? coll)\n   (when-not (zero? (alength coll)) (IndexedSeq. coll 0 nil))\n   (native-satisfies? ISeqable coll)\n   (-seq coll)\n   :else\n   (throw (js/Error. (str coll \" is not ISeqable\"))))))\n"} {:sym reduce, :meta {:doc "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called.", :arglists [[f coll] [f val coll]]}, :source "(defn\n reduce\n \"f should be a function of 2 arguments. If val is not supplied,\\n  returns the result of applying f to the first 2 items in coll, then\\n  applying f to that result and the 3rd item, etc. If coll contains no\\n  items, f must accept no arguments as well, and reduce returns the\\n  result of calling f with no arguments.  If coll has only 1 item, it\\n  is returned and f is not called.  If val is supplied, returns the\\n  result of applying f to val and the first item in coll, then\\n  applying f to that result and the 2nd item, etc. If coll contains no\\n  items, returns val and f is not called.\"\n ([f coll]\n  (cond\n   (implements? IReduce coll)\n   (-reduce coll f)\n   (array? coll)\n   (array-reduce coll f)\n   (string? coll)\n   (array-reduce coll f)\n   (native-satisfies? IReduce coll)\n   (-reduce coll f)\n   (iterable? coll)\n   (iter-reduce coll f)\n   :else\n   (seq-reduce f coll)))\n ([f val coll]\n  (cond\n   (implements? IReduce coll)\n   (-reduce coll f val)\n   (array? coll)\n   (array-reduce coll f val)\n   (string? coll)\n   (array-reduce coll f val)\n   (native-satisfies? IReduce coll)\n   (-reduce coll f val)\n   (iterable? coll)\n   (iter-reduce coll f val)\n   :else\n   (seq-reduce f val coll))))\n"} {:sym contains?, :meta {:doc "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'.", :arglists ([coll v])}, :source "(defn\n contains?\n \"Returns true if key is present in the given collection, otherwise\\n  returns false.  Note that for numerically indexed collections like\\n  vectors and arrays, this tests if the numeric key is within the\\n  range of indexes. 'contains?' operates constant or logarithmic time;\\n  it will not perform a linear search for a value.  See also 'some'.\"\n [coll v]\n (if\n  (identical? (get coll v lookup-sentinel) lookup-sentinel)\n  false\n  true))\n"} {:sym every?, :meta {:doc "Returns true if (pred x) is logical true for every x in coll, else\n  false.", :arglists ([pred coll])}, :source "(defn\n every?\n \"Returns true if (pred x) is logical true for every x in coll, else\\n  false.\"\n [pred coll]\n (cond\n  (nil? (seq coll))\n  true\n  (pred (first coll))\n  (recur pred (next coll))\n  :else\n  false))\n"} {:sym keep-indexed, :meta {:doc "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided.", :arglists [[f] [f coll]]}, :source "(defn\n keep-indexed\n \"Returns a lazy sequence of the non-nil results of (f index item). Note,\\n  this means false return values will be included.  f must be free of\\n  side-effects.  Returns a stateful transducer when no collection is\\n  provided.\"\n ([f]\n  (fn\n   [rf]\n   (let\n    [ia (volatile! -1)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input]\n      (let\n       [i (vswap! ia inc) v (f i input)]\n       (if (nil? v) result (rf result v))))))))\n ([f coll]\n  (letfn\n   [(keepi\n     [idx coll]\n     (lazy-seq\n      (when-let\n       [s (seq coll)]\n       (if\n        (chunked-seq? s)\n        (let\n         [c (chunk-first s) size (count c) b (chunk-buffer size)]\n         (dotimes\n          [i size]\n          (let\n           [x (f (+ idx i) (-nth c i))]\n           (when-not (nil? x) (chunk-append b x))))\n         (chunk-cons (chunk b) (keepi (+ idx size) (chunk-rest s))))\n        (let\n         [x (f idx (first s))]\n         (if\n          (nil? x)\n          (keepi (inc idx) (rest s))\n          (cons x (keepi (inc idx) (rest s)))))))))]\n   (keepi 0 coll))))\n"} {:sym subs, :meta {:doc "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive.", :arglists [[s start] [s start end]]}, :source "(defn\n subs\n \"Returns the substring of s beginning at start inclusive, and ending\\n  at end (defaults to length of string), exclusive.\"\n ([s start] (.substring s start))\n ([s start end] (.substring s start end)))\n"} {:sym IFind, :meta {:doc "Protocol for implementing entry finding in collections."}, :methods (-find)} {:sym MODULE_URIS, :meta {}, :source "(def MODULE_URIS nil)\n"} {:sym take-last, :meta {:doc "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec.", :arglists ([n coll])}, :source "(defn\n take-last\n \"Returns a seq of the last n items in coll.  Depending on the type\\n  of coll may be no better than linear time.  For vectors, see also subvec.\"\n [n coll]\n (loop\n  [s (seq coll) lead (seq (drop n coll))]\n  (if lead (recur (next s) (next lead)) s)))\n"} {:sym bit-set, :meta {:doc "Set bit at index n", :arglists ([x n])}, :source "(defn bit-set \"Set bit at index n\" [x n] (cljs.core/bit-set x n))\n"} {:sym string-hash-cache-count, :meta {}, :source "(def string-hash-cache-count 0)\n"} {:sym qualified-keyword?, :meta {:doc "Return true if x is a keyword with a namespace", :arglists ([x])}, :source "(defn\n qualified-keyword?\n \"Return true if x is a keyword with a namespace\"\n [x]\n (boolean (and (keyword? x) (namespace x) true)))\n"} {:sym -with-meta, :meta {:doc "Returns a new object with value of o and metadata meta added to it.", :arglists ([o meta])}, :protocol IWithMeta} {:sym unchecked-subtract-int, :meta {:doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n unchecked-subtract-int\n \"If no ys are supplied, returns the negation of x, else subtracts\\n  the ys from x and returns the result.\"\n ([x] (cljs.core/unchecked-subtract-int x))\n ([x y] (cljs.core/unchecked-subtract-int x y))\n ([x y & more]\n  (reduce\n   unchecked-subtract-int\n   (cljs.core/unchecked-subtract-int x y)\n   more)))\n"} {:sym -iterator, :meta {:doc "Returns an iterator for coll.", :arglists ([coll])}, :protocol IIterable} {:sym *print-namespace-maps*, :meta {:doc "*print-namespace-maps* controls whether the printer will print\n  namespace map literal syntax.\n\n  Defaults to false, but the REPL binds it to true."}, :source "(def *print-namespace-maps* false)\n"} {:sym first, :meta {:doc "Returns the first item in the collection. Calls seq on its\n  argument. If coll is nil, returns nil.", :arglists ([coll])}, :source "(defn\n first\n \"Returns the first item in the collection. Calls seq on its\\n  argument. If coll is nil, returns nil.\"\n [coll]\n (when-not\n  (nil? coll)\n  (if\n   (implements? ISeq coll)\n   (-first coll)\n   (let [s (seq coll)] (when-not (nil? s) (-first s))))))\n"} {:sym native-satisfies?, :meta {:doc "Internal - do not use!", :arglists ([p x])}, :source "(defn\n native-satisfies?\n \"Internal - do not use!\"\n [p x]\n (let\n  [x (if (nil? x) nil x)]\n  (cond\n   (unchecked-get p (goog/typeOf x))\n   true\n   (unchecked-get p \"_\")\n   true\n   :else\n   false)))\n"} {:sym seq?, :meta {:doc "Return true if s satisfies ISeq", :arglists ([s])}, :source "(defn\n seq?\n \"Return true if s satisfies ISeq\"\n [s]\n (if (nil? s) false (satisfies? ISeq s)))\n"} {:sym -sorted-seq-from, :meta {:doc "Returns a sorted seq from coll in either ascending or descending order.\n     If ascending is true, the result should contain all items which are > or >=\n     than k. If ascending is false, the result should contain all items which\n     are < or <= than k, e.g.\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) => (3 4 5)\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) => (3 2 1)", :arglists ([coll k ascending?])}, :protocol ISorted} {:sym inst-ms, :meta {:doc "Return the number of milliseconds since January 1, 1970, 00:00:00 GMT", :arglists ([inst])}, :source "(defn\n inst-ms\n \"Return the number of milliseconds since January 1, 1970, 00:00:00 GMT\"\n [inst]\n (inst-ms* inst))\n"} {:sym iterate, :meta {:doc "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects", :arglists ([f x])}, :source "(defn\n iterate\n \"Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects\"\n {:added \"1.0\"}\n [f x]\n (cons x (lazy-seq (iterate f (f x)))))\n"} {:sym -empty, :meta {:doc "Returns an empty collection of the same category as coll. Used\n     by cljs.core/empty.", :arglists ([coll])}, :protocol IEmptyableCollection} {:sym ILookup, :meta {:doc "Protocol for looking up a value in a data structure."}, :methods (-lookup)} {:sym -chunked-rest, :meta {:doc "Return a new collection of coll with the first chunk removed.", :arglists ([coll])}, :protocol IChunkedSeq} {:sym fn?, :meta {:doc "Return true if f is a JavaScript function or satisfies the Fn protocol.", :arglists ([f])}, :source "(defn\n fn?\n \"Return true if f is a JavaScript function or satisfies the Fn protocol.\"\n [f]\n (or (goog/isFunction f) (satisfies? Fn f)))\n"} {:sym -assoc, :meta {:doc "Returns a new collection of coll with a mapping from key k to\n     value v added to it.", :arglists ([coll k v])}, :protocol IAssociative} {:sym keyword-identical?, :meta {:doc "Efficient test to determine that two keywords are identical.", :arglists ([x y])}, :source "(defn\n keyword-identical?\n \"Efficient test to determine that two keywords are identical.\"\n [x y]\n (if\n  (identical? x y)\n  true\n  (if\n   (and (keyword? x) (keyword? y))\n   (identical? (.-fqn x) (.-fqn y))\n   false)))\n"} {:sym *print-err-fn*, :meta {:doc "Each runtime environment provides a different way to print error output.\n  Whatever function *print-err-fn* is bound to will be passed any\n  Strings which should be printed."}, :source "(defonce *print-err-fn* nil)\n"} {:sym dissoc, :meta {:doc "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s).", :arglists [[coll] [coll k] [coll k & ks]]}, :source "(defn\n dissoc\n \"dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\\n  that does not contain a mapping for key(s).\"\n ([coll] coll)\n ([coll k] (when-not (nil? coll) (-dissoc coll k)))\n ([coll k & ks]\n  (when-not\n   (nil? coll)\n   (let\n    [ret (dissoc coll k)]\n    (if ks (recur ret (first ks) (next ks)) ret)))))\n"} {:sym atom, :meta {:doc "Creates and returns an Atom with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  If metadata-map is supplied, it will be come the metadata on the\n  atom. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an Error.  If either of these error conditions\n  occur, then the value of the atom will not change.", :arglists [[x] [x & {:keys [meta validator]}]]}, :source "(defn\n atom\n \"Creates and returns an Atom with an initial value of x and zero or\\n  more options (in any order):\\n\\n  :meta metadata-map\\n\\n  :validator validate-fn\\n\\n  If metadata-map is supplied, it will be come the metadata on the\\n  atom. validate-fn must be nil or a side-effect-free fn of one\\n  argument, which will be passed the intended new state on any state\\n  change. If the new state is unacceptable, the validate-fn should\\n  return false or throw an Error.  If either of these error conditions\\n  occur, then the value of the atom will not change.\"\n ([x] (Atom. x nil nil nil))\n ([x & {:keys [meta validator]}] (Atom. x meta validator nil)))\n"} {:sym bit-shift-right, :meta {:doc "Bitwise shift right", :arglists ([x n])}, :source "(defn\n bit-shift-right\n \"Bitwise shift right\"\n [x n]\n (cljs.core/bit-shift-right x n))\n"} {:sym *clojurescript-version*, :meta {}, :source "(def *clojurescript-version* \"1.9.946\")\n"} {:sym -first, :meta {:doc "Returns the first item in the collection coll. Used by cljs.core/first.", :arglists ([coll])}, :protocol ISeq} {:sym peek, :meta {:doc "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil.", :arglists ([coll])}, :source "(defn\n peek\n \"For a list or queue, same as first, for a vector, same as, but much\\n  more efficient than, last. If the collection is empty, returns nil.\"\n [coll]\n (when-not (nil? coll) (-peek coll)))\n"} {:sym IKVReduce, :meta {:doc "Protocol for associative types that can reduce themselves\n  via a function of key and val. Called by cljs.core/reduce-kv."}, :methods (-kv-reduce)} {:sym aget, :meta {:doc "Returns the value at the index/indices. Works on JavaScript arrays.", :arglists [[array idx] [array idx & idxs]]}, :source "(defn\n aget\n \"Returns the value at the index/indices. Works on JavaScript arrays.\"\n ([array idx] (cljs.core/aget array idx))\n ([array idx & idxs] (apply aget (aget array idx) idxs)))\n"} {:sym -write, :meta {:doc "Writes s with writer and returns the result.", :arglists ([writer s])}, :protocol IWriter} {:sym iter, :meta {:doc nil, :arglists ([coll])}, :source "(defn\n iter\n [coll]\n (cond\n  (iterable? coll)\n  (-iterator coll)\n  (nil? coll)\n  (nil-iter)\n  (string? coll)\n  (string-iter coll)\n  (array? coll)\n  (array-iter coll)\n  (seqable? coll)\n  (seq-iter coll)\n  :else\n  (throw (js/Error. (str \"Cannot create iterator from \" coll)))))\n"} {:sym last, :meta {:doc "Return the last item in coll, in linear time", :arglists ([s])}, :source "(defn\n last\n \"Return the last item in coll, in linear time\"\n [s]\n (let [sn (next s)] (if-not (nil? sn) (recur sn) (first s))))\n"} {:sym namespace, :meta {:doc "Returns the namespace String of a symbol or keyword, or nil if not present.", :arglists ([x])}, :source "(defn\n namespace\n \"Returns the namespace String of a symbol or keyword, or nil if not present.\"\n [x]\n (if\n  (implements? INamed x)\n  (-namespace x)\n  (throw (js/Error. (str \"Doesn't support namespace: \" x)))))\n"} {:sym -conj, :meta {:doc "Returns a new collection of coll with o added to it. The new item\n     should be added to the most efficient place, e.g.\n     (conj [1 2 3 4] 5) => [1 2 3 4 5]\n     (conj '(2 3 4 5) 1) => '(1 2 3 4 5)", :arglists ([coll o])}, :protocol ICollection} {:sym =, :meta {:doc "Equality. Returns true if x equals y, false if not. Compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define -equiv (and thus =) as a value, not an identity,\n  comparison.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n =\n \"Equality. Returns true if x equals y, false if not. Compares\\n  numbers and collections in a type-independent manner.  Clojure's immutable data\\n  structures define -equiv (and thus =) as a value, not an identity,\\n  comparison.\"\n ([x] true)\n ([x y] (if (nil? x) (nil? y) (or (identical? x y) (-equiv x y))))\n ([x y & more]\n  (if\n   (= x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (= y (first more)))\n   false)))\n"} {:sym ITransientMap, :meta {:doc "Protocol for adding mapping functionality to transient collections."}, :methods (-dissoc!)} {:sym take, :meta {:doc "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided.", :arglists [[n] [n coll]]}, :source "(defn\n take\n \"Returns a lazy sequence of the first n items in coll, or all items if\\n  there are fewer than n.  Returns a stateful transducer when\\n  no collection is provided.\"\n ([n]\n  {:pre [(number? n)]}\n  (fn\n   [rf]\n   (let\n    [na (volatile! n)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input]\n      (let\n       [n\n        @na\n        nn\n        (vswap! na dec)\n        result\n        (if (pos? n) (rf result input) result)]\n       (if (not (pos? nn)) (ensure-reduced result) result)))))))\n ([n coll]\n  {:pre [(number? n)]}\n  (lazy-seq\n   (when\n    (pos? n)\n    (when-let\n     [s (seq coll)]\n     (cons (first s) (take (dec n) (rest s))))))))\n"} {:sym vector?, :meta {:doc "Return true if x satisfies IVector", :arglists ([x])}, :source "(defn\n vector?\n \"Return true if x satisfies IVector\"\n [x]\n (satisfies? IVector x))\n"} {:sym boolean, :meta {:doc "Coerce to boolean", :arglists ([x])}, :source "(defn\n boolean\n \"Coerce to boolean\"\n [x]\n (cond (nil? x) false (false? x) false :else true))\n"} {:sym IChunk, :meta {:doc "Protocol for accessing the items of a chunk."}, :methods (-drop-first)} {:sym bit-shift-left, :meta {:doc "Bitwise shift left", :arglists ([x n])}, :source "(defn\n bit-shift-left\n \"Bitwise shift left\"\n [x n]\n (cljs.core/bit-shift-left x n))\n"} {:sym any?, :meta {:doc "Returns true if given any argument.", :arglists ([x])}, :source "(defn any? \"Returns true if given any argument.\" [x] true)\n"} {:sym aclone, :meta {:doc "Returns a javascript array, cloned from the passed in array", :arglists ([arr])}, :source "(defn\n aclone\n \"Returns a javascript array, cloned from the passed in array\"\n [arr]\n (let\n  [len (alength arr) new-arr (make-array len)]\n  (dotimes [i len] (aset new-arr i (aget arr i)))\n  new-arr))\n"} {:sym vreset!, :meta {:doc "Sets the value of volatile to newval without regard for the\n   current value. Returns newval.", :arglists ([vol newval])}, :source "(defn\n vreset!\n \"Sets the value of volatile to newval without regard for the\\n   current value. Returns newval.\"\n [vol newval]\n (-vreset! vol newval))\n"} {:sym chunk, :meta {:doc nil, :arglists ([b])}, :source "(defn chunk [b] (.chunk b))\n"} {:sym dec, :meta {:doc "Returns a number one less than num.", :arglists ([x])}, :source "(defn dec \"Returns a number one less than num.\" [x] (- x 1))\n"} {:sym APersistentVector, :meta {:doc "Marker protocol"}, :methods ()} {:sym map, :meta {:doc "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided.", :arglists [[f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]]}, :source "(defn\n map\n \"Returns a lazy sequence consisting of the result of applying f to\\n  the set of first items of each coll, followed by applying f to the\\n  set of second items in each coll, until any one of the colls is\\n  exhausted.  Any remaining items in other colls are ignored. Function\\n  f should accept number-of-colls arguments. Returns a transducer when\\n  no collection is provided.\"\n ([f]\n  (fn\n   [rf]\n   (fn\n    ([] (rf))\n    ([result] (rf result))\n    ([result input] (rf result (f input)))\n    ([result input & inputs] (rf result (apply f input inputs))))))\n ([f coll]\n  (lazy-seq\n   (when-let\n    [s (seq coll)]\n    (if\n     (chunked-seq? s)\n     (let\n      [c (chunk-first s) size (count c) b (chunk-buffer size)]\n      (dotimes [i size] (chunk-append b (f (-nth c i))))\n      (chunk-cons (chunk b) (map f (chunk-rest s))))\n     (cons (f (first s)) (map f (rest s)))))))\n ([f c1 c2]\n  (lazy-seq\n   (let\n    [s1 (seq c1) s2 (seq c2)]\n    (when\n     (and s1 s2)\n     (cons (f (first s1) (first s2)) (map f (rest s1) (rest s2)))))))\n ([f c1 c2 c3]\n  (lazy-seq\n   (let\n    [s1 (seq c1) s2 (seq c2) s3 (seq c3)]\n    (when\n     (and s1 s2 s3)\n     (cons\n      (f (first s1) (first s2) (first s3))\n      (map f (rest s1) (rest s2) (rest s3)))))))\n ([f c1 c2 c3 & colls]\n  (let\n   [step\n    (fn\n     step\n     [cs]\n     (lazy-seq\n      (let\n       [ss (map seq cs)]\n       (when\n        (every? identity ss)\n        (cons (map first ss) (step (map rest ss)))))))]\n   (map\n    (fn* [p1__18387#] (apply f p1__18387#))\n    (step (conj colls c3 c2 c1))))))\n"} {:sym <, :meta {:doc "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n <\n \"Returns non-nil if nums are in monotonically increasing order,\\n  otherwise false.\"\n ([x] true)\n ([x y] (cljs.core/< x y))\n ([x y & more]\n  (if\n   (cljs.core/< x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (cljs.core/< y (first more)))\n   false)))\n"} {:sym rest, :meta {:doc "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument.", :arglists ([coll])}, :source "(defn\n rest\n \"Returns a possibly empty seq of the items after the first. Calls seq on its\\n  argument.\"\n [coll]\n (if-not\n  (nil? coll)\n  (if\n   (implements? ISeq coll)\n   (-rest coll)\n   (let [s (seq coll)] (if s (-rest s) ())))\n  ()))\n"} {:sym -drop-first, :meta {:doc "Return a new chunk of coll with the first item removed.", :arglists ([coll])}, :protocol IChunk} {:sym boolean?, :meta {:doc "Return true if x is a Boolean", :arglists ([x])}, :source "(defn\n boolean?\n \"Return true if x is a Boolean\"\n [x]\n (or (cljs.core/true? x) (cljs.core/false? x)))\n"} {:sym -clone, :meta {:doc "Creates a clone of value.", :arglists ([value])}, :protocol ICloneable} {:sym char?, :meta {:doc "Returns true if x is a JavaScript string of length one.", :arglists ([x])}, :source "(defn\n char?\n \"Returns true if x is a JavaScript string of length one.\"\n [x]\n (and (string? x) (== 1 (.-length x))))\n"} {:sym -reduce, :meta {:doc "f should be a function of 2 arguments. If start is not supplied,\n     returns the result of applying f to the first 2 items in coll, then\n     applying f to that result and the 3rd item, etc.", :arglists ([coll f] [coll f start])}, :protocol IReduce} {:sym -count, :meta {:doc "Calculates the count of coll in constant time. Used by cljs.core/count.", :arglists ([coll])}, :protocol ICounted} {:sym swap-vals!, :meta {:doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.\n  Returns [old new], the value of the atom before and after the swap.", :arglists [[a f] [a f x] [a f x y] [a f x y & more]]}, :source "(defn\n swap-vals!\n \"Atomically swaps the value of atom to be:\\n  (apply f current-value-of-atom args). Note that f may be called\\n  multiple times, and thus should be free of side effects.\\n  Returns [old new], the value of the atom before and after the swap.\"\n {:added \"1.9\"}\n ([a f] (reset-vals! a (f (.-state a))))\n ([a f x] (reset-vals! a (f (.-state a) x)))\n ([a f x y] (reset-vals! a (f (.-state a) x y)))\n ([a f x y & more] (reset-vals! a (apply f (.-state a) x y more))))\n"} {:sym keep, :meta {:doc "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided.", :arglists [[f] [f coll]]}, :source "(defn\n keep\n \"Returns a lazy sequence of the non-nil results of (f item). Note,\\n  this means false return values will be included.  f must be free of\\n  side-effects.  Returns a transducer when no collection is provided.\"\n ([f]\n  (fn\n   [rf]\n   (fn\n    ([] (rf))\n    ([result] (rf result))\n    ([result input]\n     (let [v (f input)] (if (nil? v) result (rf result v)))))))\n ([f coll]\n  (lazy-seq\n   (when-let\n    [s (seq coll)]\n    (if\n     (chunked-seq? s)\n     (let\n      [c (chunk-first s) size (count c) b (chunk-buffer size)]\n      (dotimes\n       [i size]\n       (let [x (f (-nth c i))] (when-not (nil? x) (chunk-append b x))))\n      (chunk-cons (chunk b) (keep f (chunk-rest s))))\n     (let\n      [x (f (first s))]\n      (if (nil? x) (keep f (rest s)) (cons x (keep f (rest s))))))))))\n"} {:sym char, :meta {:doc "Coerce to char", :arglists ([x])}, :source "(defn\n char\n \"Coerce to char\"\n [x]\n (cond\n  (number? x)\n  (.fromCharCode js/String x)\n  (and (string? x) (== (.-length x) 1))\n  x\n  :else\n  (throw (js/Error. \"Argument to char must be a character or number\"))))\n"} {:sym mapcat, :meta {:doc "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided", :arglists [[f] [f & colls]]}, :source "(defn\n mapcat\n \"Returns the result of applying concat to the result of applying map\\n  to f and colls.  Thus function f should return a collection. Returns\\n  a transducer when no collections are provided\"\n {:added \"1.0\", :static true}\n ([f] (comp (map f) cat))\n ([f & colls] (apply concat (apply map f colls))))\n"} {:sym unchecked-long, :meta {:doc "Coerce to long by stripping decimal places. Identical to `int'.", :arglists ([x])}, :source "(defn\n unchecked-long\n \"Coerce to long by stripping decimal places. Identical to `int'.\"\n [x]\n (fix x))\n"} {:sym m3-seed, :meta {}, :source "(def m3-seed 0)\n"} {:sym some?, :meta {:doc "Returns true if x is not nil, false otherwise.", :arglists ([x])}, :source "(defn\n some?\n \"Returns true if x is not nil, false otherwise.\"\n [x]\n (not (nil? x)))\n"} {:sym unchecked-negate, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-negate [x] (cljs.core/unchecked-negate x))\n"} {:sym symbol-identical?, :meta {:doc "Efficient test to determine that two symbols are identical.", :arglists ([x y])}, :source "(defn\n symbol-identical?\n \"Efficient test to determine that two symbols are identical.\"\n [x y]\n (if\n  (identical? x y)\n  true\n  (if\n   (and (symbol? x) (symbol? y))\n   (identical? (.-str x) (.-str y))\n   false)))\n"} {:sym *command-line-args*, :meta {:doc "A sequence of the supplied command line arguments, or nil if\n  none were supplied"}, :source "(def *command-line-args* nil)\n"} {:sym reverse, :meta {:doc "Returns a seq of the items in coll in reverse order. Not lazy.", :arglists ([coll])}, :source "(defn\n reverse\n \"Returns a seq of the items in coll in reverse order. Not lazy.\"\n [coll]\n (if (reversible? coll) (rseq coll) (reduce conj () coll)))\n"} {:sym inst?, :meta {:doc "Return true if x satisfies Inst", :arglists ([x])}, :source "(defn inst? \"Return true if x satisfies Inst\" [x] (satisfies? Inst x))\n"} {:sym bit-count, :meta {:doc "Counts the number of bits set in n", :arglists ([v])}, :source "(defn\n bit-count\n \"Counts the number of bits set in n\"\n [v]\n (let\n  [v\n   (- v (bit-and (bit-shift-right v 1) 1431655765))\n   v\n   (+ (bit-and v 858993459) (bit-and (bit-shift-right v 2) 858993459))]\n  (bit-shift-right\n   (* (bit-and (+ v (bit-shift-right v 4)) 252645135) 16843009)\n   24)))\n"} {:sym sort, :meta {:doc "Returns a sorted sequence of the items in coll. Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :arglists [[coll] [comp coll]]}, :source "(defn\n sort\n \"Returns a sorted sequence of the items in coll. Comp can be\\n   boolean-valued comparison function, or a -/0/+ valued comparator.\\n   Comp defaults to compare.\"\n ([coll] (sort compare coll))\n ([comp coll]\n  (if\n   (seq coll)\n   (let\n    [a (to-array coll)]\n    (garray/stableSort a (fn->comparator comp))\n    (seq a))\n   ())))\n"} {:sym unchecked-inc-int, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-inc-int [x] (cljs.core/unchecked-inc-int x))\n"} {:sym -compare, :meta {:doc "Returns a negative number, zero, or a positive number when x is logically\n     'less than', 'equal to', or 'greater than' y.", :arglists ([x y])}, :protocol IComparable} {:sym map-indexed, :meta {:doc "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item. Returns a stateful transducer when\n  no collection is provided.", :arglists [[f] [f coll]]}, :source "(defn\n map-indexed\n \"Returns a lazy sequence consisting of the result of applying f to 0\\n  and the first item of coll, followed by applying f to 1 and the second\\n  item in coll, etc, until coll is exhausted. Thus function f should\\n  accept 2 arguments, index and item. Returns a stateful transducer when\\n  no collection is provided.\"\n ([f]\n  (fn\n   [rf]\n   (let\n    [i (volatile! -1)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input] (rf result (f (vswap! i inc) input)))))))\n ([f coll]\n  (letfn\n   [(mapi\n     [idx coll]\n     (lazy-seq\n      (when-let\n       [s (seq coll)]\n       (if\n        (chunked-seq? s)\n        (let\n         [c (chunk-first s) size (count c) b (chunk-buffer size)]\n         (dotimes [i size] (chunk-append b (f (+ idx i) (-nth c i))))\n         (chunk-cons (chunk b) (mapi (+ idx size) (chunk-rest s))))\n        (cons (f idx (first s)) (mapi (inc idx) (rest s)))))))]\n   (mapi 0 coll))))\n"} {:sym comp, :meta {:doc "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc.", :arglists [[] [f] [f g] [f g h] [f1 f2 f3 & fs]]}, :source "(defn\n comp\n \"Takes a set of functions and returns a fn that is the composition\\n  of those fns.  The returned fn takes a variable number of args,\\n  applies the rightmost of fns to the args, the next\\n  fn (right-to-left) to the result, etc.\"\n ([] identity)\n ([f] f)\n ([f g]\n  (fn\n   ([] (f (g)))\n   ([x] (f (g x)))\n   ([x y] (f (g x y)))\n   ([x y z] (f (g x y z)))\n   ([x y z & args] (f (apply g x y z args)))))\n ([f g h]\n  (fn\n   ([] (f (g (h))))\n   ([x] (f (g (h x))))\n   ([x y] (f (g (h x y))))\n   ([x y z] (f (g (h x y z))))\n   ([x y z & args] (f (g (apply h x y z args))))))\n ([f1 f2 f3 & fs]\n  (let\n   [fs (reverse (list* f1 f2 f3 fs))]\n   (fn\n    [& args]\n    (loop\n     [ret (apply (first fs) args) fs (next fs)]\n     (if fs (recur ((first fs) ret) (next fs)) ret))))))\n"} {:sym array-chunk, :meta {:doc nil, :arglists [[arr] [arr off] [arr off end]]}, :source "(defn\n array-chunk\n ([arr] (ArrayChunk. arr 0 (alength arr)))\n ([arr off] (ArrayChunk. arr off (alength arr)))\n ([arr off end] (ArrayChunk. arr off end)))\n"} {:sym bit-shift-right-zero-fill, :meta {:doc "DEPRECATED: Bitwise shift right with zero fill", :arglists ([x n])}, :source "(defn\n bit-shift-right-zero-fill\n \"DEPRECATED: Bitwise shift right with zero fill\"\n [x n]\n (cljs.core/bit-shift-right-zero-fill x n))\n"} {:sym -as-transient, :meta {:doc "Returns a new, transient version of the collection, in constant time.", :arglists ([coll])}, :protocol IEditableCollection} {:sym simple-symbol?, :meta {:doc "Return true if x is a symbol without a namespace", :arglists ([x])}, :source "(defn\n simple-symbol?\n \"Return true if x is a symbol without a namespace\"\n [x]\n (and (symbol? x) (nil? (namespace x))))\n"} {:sym IIndexed, :meta {:doc "Protocol for collections to provide indexed-based access to their items."}, :methods (-nth)} {:sym disj, :meta {:doc "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s).", :arglists [[coll] [coll k] [coll k & ks]]}, :source "(defn\n disj\n \"disj[oin]. Returns a new set of the same (hashed/sorted) type, that\\n  does not contain key(s).\"\n ([coll] coll)\n ([coll k] (when-not (nil? coll) (-disjoin coll k)))\n ([coll k & ks]\n  (when-not\n   (nil? coll)\n   (let\n    [ret (disj coll k)]\n    (if ks (recur ret (first ks) (next ks)) ret)))))\n"} {:sym IPrintWithWriter, :meta {:doc "The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append."}, :methods (-pr-writer)} {:sym IVector, :meta {:doc "Protocol for adding vector functionality to collections."}, :methods (-assoc-n)} {:sym IIterable, :meta {:doc "Protocol for iterating over a collection."}, :methods (-iterator)} {:sym cons, :meta {:doc "Returns a new seq where x is the first element and coll is the rest.", :arglists ([x coll])}, :source "(defn\n cons\n \"Returns a new seq where x is the first element and coll is the rest.\"\n [x coll]\n (if\n  (or (nil? coll) (implements? ISeq coll))\n  (Cons. nil x coll nil)\n  (Cons. nil x (seq coll) nil)))\n"} {:sym floats, :meta {:doc nil, :arglists ([x])}, :source "(defn floats [x] x)\n"} {:sym pos?, :meta {:doc "Returns true if num is greater than zero, else false", :arglists ([x])}, :source "(defn\n pos?\n \"Returns true if num is greater than zero, else false\"\n [x]\n (cljs.core/pos? x))\n"} {:sym fnil, :meta {:doc "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched.", :arglists [[f x] [f x y] [f x y z]]}, :source "(defn\n fnil\n \"Takes a function f, and returns a function that calls f, replacing\\n  a nil first argument to f with the supplied value x. Higher arity\\n  versions can replace arguments in the second and third\\n  positions (y, z). Note that the function f can take any number of\\n  arguments, not just the one(s) being nil-patched.\"\n ([f x]\n  (fn\n   ([a] (f (if (nil? a) x a)))\n   ([a b] (f (if (nil? a) x a) b))\n   ([a b c] (f (if (nil? a) x a) b c))\n   ([a b c & ds] (apply f (if (nil? a) x a) b c ds))))\n ([f x y]\n  (fn\n   ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n   ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) c))\n   ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) c ds))))\n ([f x y z]\n  (fn\n   ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n   ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c)))\n   ([a b c & ds]\n    (apply\n     f\n     (if (nil? a) x a)\n     (if (nil? b) y b)\n     (if (nil? c) z c)\n     ds)))))\n"} {:sym nthrest, :meta {:doc "Returns the nth rest of coll, coll when n is 0.", :arglists ([coll n])}, :source "(defn\n nthrest\n \"Returns the nth rest of coll, coll when n is 0.\"\n [coll n]\n (loop\n  [n n xs coll]\n  (if (and (pos? n) (seq xs)) (recur (dec n) (rest xs)) xs)))\n"} {:sym *warn-on-infer*, :meta {}, :source "(def *warn-on-infer* false)\n"} {:sym -find, :meta {:doc "Returns the map entry for key, or nil if key not present.", :arglists ([coll k])}, :protocol IFind} {:sym sequential?, :meta {:doc "Returns true if coll satisfies ISequential", :arglists ([x])}, :source "(defn\n sequential?\n \"Returns true if coll satisfies ISequential\"\n [x]\n (satisfies? ISequential x))\n"} {:sym m3-mix-H1, :meta {:doc nil, :arglists ([h1 k1])}, :source "(defn\n m3-mix-H1\n [h1 k1]\n (int\n  (->\n   (int h1)\n   (bit-xor (int k1))\n   (int-rotate-left 13)\n   (imul 5)\n   (+ (int 3864292196)))))\n"} {:sym prim-seq, :meta {:doc "Create seq from a primitive JavaScript Array-like.", :arglists [[prim] [prim i]]}, :source "(defn\n prim-seq\n \"Create seq from a primitive JavaScript Array-like.\"\n ([prim] (prim-seq prim 0))\n ([prim i] (when (< i (alength prim)) (IndexedSeq. prim i nil))))\n"} {:sym *print-level*, :meta {:doc "*print-level* controls how many levels deep the printer will\n  print nested objects. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  level to print. Each argument to print is at level 0; if an argument is a\n  collection, its items are at level 1; and so on. If an object is a\n  collection and is at a level greater than or equal to the value bound to\n  *print-level*, the printer prints '#' to represent it. The root binding\n  is nil indicating no limit."}, :source "(def *print-level* nil)\n"} {:sym shuffle, :meta {:doc "Return a random permutation of coll", :arglists ([coll])}, :source "(defn\n shuffle\n \"Return a random permutation of coll\"\n [coll]\n (let [a (to-array coll)] (garray/shuffle a) (vec a)))\n"} {:sym hash-keyword, :meta {:doc nil, :arglists ([k])}, :source "(defn hash-keyword [k] (int (+ (hash-symbol k) 2654435769)))\n"} {:sym find, :meta {:doc "Returns the map entry for key, or nil if key not present.", :arglists ([coll k])}, :source "(defn\n find\n \"Returns the map entry for key, or nil if key not present.\"\n [coll k]\n (if\n  (ifind? coll)\n  (-find coll k)\n  (when\n   (and (not (nil? coll)) (associative? coll) (contains? coll k))\n   [k (get coll k)])))\n"} {:sym alength, :meta {:doc "Returns the length of the array. Works on arrays of all types.", :arglists ([array])}, :source "(defn\n alength\n \"Returns the length of the array. Works on arrays of all types.\"\n [array]\n (cljs.core/alength array))\n"} {:sym bit-xor, :meta {:doc "Bitwise exclusive or", :arglists [[x y] [x y & more]]}, :source "(defn\n bit-xor\n \"Bitwise exclusive or\"\n ([x y] (cljs.core/bit-xor x y))\n ([x y & more] (reduce bit-xor (cljs.core/bit-xor x y) more)))\n"} {:sym unsigned-bit-shift-right, :meta {:doc "Bitwise shift right with zero fill", :arglists ([x n])}, :source "(defn\n unsigned-bit-shift-right\n \"Bitwise shift right with zero fill\"\n [x n]\n (cljs.core/unsigned-bit-shift-right x n))\n"} {:sym neg?, :meta {:doc "Returns true if num is less than zero, else false", :arglists ([x])}, :source "(defn\n neg?\n \"Returns true if num is less than zero, else false\"\n [x]\n (cljs.core/neg? x))\n"} {:sym js-invoke, :meta {:doc "Invoke JavaScript object method via string. Needed when the\n  string is not a valid unquoted property name.", :arglists ([obj s & args])}, :source "(defn\n js-invoke\n \"Invoke JavaScript object method via string. Needed when the\\n  string is not a valid unquoted property name.\"\n [obj s & args]\n (.apply (unchecked-get obj s) obj (into-array args)))\n"} {:sym m3-mix-K1, :meta {:doc nil, :arglists ([k1])}, :source "(defn\n m3-mix-K1\n [k1]\n (-> (int k1) (imul m3-C1) (int-rotate-left 15) (imul m3-C2)))\n"} {:sym unchecked-float, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-float [x] x)\n"} {:sym undefined?, :meta {:doc "Returns true if x identical to the JavaScript undefined value.", :arglists ([x])}, :source "(defn\n undefined?\n \"Returns true if x identical to the JavaScript undefined value.\"\n [x]\n (cljs.core/undefined? x))\n"} {:sym IMeta, :meta {:doc "Protocol for accessing the metadata of an object."}, :methods (-meta)} {:sym reduced?, :meta {:doc "Returns true if x is the result of a call to reduced", :arglists ([r])}, :source "(defn\n reduced?\n \"Returns true if x is the result of a call to reduced\"\n [r]\n (instance? Reduced r))\n"} {:sym disj!, :meta {:doc "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s).", :arglists [[tcoll val] [tcoll val & vals]]}, :source "(defn\n disj!\n \"disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\\n  does not contain key(s).\"\n ([tcoll val] (-disjoin! tcoll val))\n ([tcoll val & vals]\n  (let\n   [ntcoll (-disjoin! tcoll val)]\n   (if vals (recur ntcoll (first vals) (next vals)) ntcoll))))\n"} {:sym -lookup, :meta {:doc "Use k to look up a value in o. If not-found is supplied and k is not\n     a valid value that can be used for look up, not-found is returned.", :arglists ([o k] [o k not-found])}, :protocol ILookup} {:sym float?, :meta {:doc "Returns true for JavaScript numbers, false otherwise.", :arglists ([x])}, :source "(defn\n float?\n \"Returns true for JavaScript numbers, false otherwise.\"\n [x]\n (number? x))\n"} {:sym ICloneable, :meta {:doc "Protocol for cloning a value."}, :methods (-clone)} {:sym booleans, :meta {:doc nil, :arglists ([x])}, :source "(defn booleans [x] x)\n"} {:sym int-array, :meta {:doc "Creates an array of ints. Does not coerce array, provided for compatibility\n  with Clojure.", :arglists [[size-or-seq] [size init-val-or-seq]]}, :source "(defn\n int-array\n \"Creates an array of ints. Does not coerce array, provided for compatibility\\n  with Clojure.\"\n ([size-or-seq]\n  (if\n   (number? size-or-seq)\n   (int-array size-or-seq nil)\n   (into-array size-or-seq)))\n ([size init-val-or-seq]\n  (let\n   [a (make-array size)]\n   (if\n    (seq? init-val-or-seq)\n    (let\n     [s (seq init-val-or-seq)]\n     (loop\n      [i 0 s s]\n      (if\n       (and s (< i size))\n       (do (aset a i (first s)) (recur (inc i) (next s)))\n       a)))\n    (do (dotimes [i size] (aset a i init-val-or-seq)) a)))))\n"} {:sym set?, :meta {:doc "Returns true if x satisfies ISet", :arglists ([x])}, :source "(defn\n set?\n \"Returns true if x satisfies ISet\"\n [x]\n (if (nil? x) false (satisfies? ISet x)))\n"} {:sym iterable?, :meta {:doc "Return true if x implements IIterable protocol.", :arglists ([x])}, :source "(defn\n iterable?\n \"Return true if x implements IIterable protocol.\"\n [x]\n (satisfies? IIterable x))\n"} {:sym -pr-writer, :meta {:doc nil, :arglists ([o writer opts])}, :protocol IPrintWithWriter} {:sym vary-meta, :meta {:doc "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata.", :arglists [[obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d & args]]}, :source "(defn\n vary-meta\n \"Returns an object of the same type and value as obj, with\\n  (apply f (meta obj) args) as its metadata.\"\n ([obj f] (with-meta obj (f (meta obj))))\n ([obj f a] (with-meta obj (f (meta obj) a)))\n ([obj f a b] (with-meta obj (f (meta obj) a b)))\n ([obj f a b c] (with-meta obj (f (meta obj) a b c)))\n ([obj f a b c d] (with-meta obj (f (meta obj) a b c d)))\n ([obj f a b c d & args]\n  (with-meta obj (apply f (meta obj) a b c d args))))\n"} {:sym INext, :meta {:doc "Protocol for accessing the next items of a collection."}, :methods (-next)} {:sym is_proto_, :meta {:doc nil, :arglists ([x])}, :source "(defn is_proto_ [x] (identical? (.-prototype (.-constructor x)) x))\n"} {:sym ICounted, :meta {:doc "Protocol for adding the ability to count a collection in constant time."}, :methods (-count)} {:sym IMapEntry, :meta {:doc "Protocol for examining a map entry."}, :methods (-key -val)} {:sym <=, :meta {:doc "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n <=\n \"Returns non-nil if nums are in monotonically non-decreasing order,\\n  otherwise false.\"\n ([x] true)\n ([x y] (cljs.core/<= x y))\n ([x y & more]\n  (if\n   (cljs.core/<= x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (cljs.core/<= y (first more)))\n   false)))\n"} {:sym MODULE_INFOS, :meta {}, :source "(def MODULE_INFOS nil)\n"} {:sym conj!, :meta {:doc "Adds val to the transient collection, and return tcoll. The 'addition'\n  may happen at different 'places' depending on the concrete type.", :arglists [[] [tcoll] [tcoll val] [tcoll val & vals]]}, :source "(defn\n conj!\n \"Adds val to the transient collection, and return tcoll. The 'addition'\\n  may happen at different 'places' depending on the concrete type.\"\n ([] (transient []))\n ([tcoll] tcoll)\n ([tcoll val] (-conj! tcoll val))\n ([tcoll val & vals]\n  (let\n   [ntcoll (-conj! tcoll val)]\n   (if vals (recur ntcoll (first vals) (next vals)) ntcoll))))\n"} {:sym -pop, :meta {:doc "Returns a new stack without the item on top of the stack. Is used\n     by cljs.core/pop.", :arglists ([coll])}, :protocol IStack} {:sym repeatedly, :meta {:doc "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it", :arglists [[f] [n f]]}, :source "(defn\n repeatedly\n \"Takes a function of no args, presumably with side effects, and\\n  returns an infinite (or length n if supplied) lazy sequence of calls\\n  to it\"\n ([f] (lazy-seq (cons (f) (repeatedly f))))\n ([n f] (take n (repeatedly f))))\n"} {:sym reset-vals!, :meta {:doc "Sets the value of atom to newval. Returns [old new], the value of the\n   atom before and after the reset.", :arglists ([a new-value])}, :source "(defn\n reset-vals!\n \"Sets the value of atom to newval. Returns [old new], the value of the\\n   atom before and after the reset.\"\n {:added \"1.9\"}\n [a new-value]\n (let\n  [validate (.-validator a)]\n  (when-not\n   (nil? validate)\n   (when-not\n    (validate new-value)\n    (throw (js/Error. \"Validator rejected reference state\"))))\n  (let\n   [old-value (.-state a)]\n   (set! (.-state a) new-value)\n   (when-not\n    (nil? (.-watches a))\n    (-notify-watches a old-value new-value))\n   [old-value new-value])))\n"} {:sym IStack, :meta {:doc "Protocol for collections to provide access to their items as stacks. The top\n  of the stack should be accessed in the most efficient way for the different\n  data structures."}, :methods (-peek -pop)} {:sym -remove-watch, :meta {:doc "Removes watcher that corresponds to key from this.", :arglists ([this key])}, :protocol IWatchable} {:sym IVolatile, :meta {:doc "Protocol for adding volatile functionality."}, :methods (-vreset!)} {:sym remove, :meta {:doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :arglists [[pred] [pred coll]]}, :source "(defn\n remove\n \"Returns a lazy sequence of the items in coll for which\\n  (pred item) returns false. pred must be free of side-effects.\\n  Returns a transducer when no collection is provided.\"\n ([pred] (filter (complement pred)))\n ([pred coll] (filter (complement pred) coll)))\n"} {:sym *, :meta {:doc "Returns the product of nums. (*) returns 1.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n *\n \"Returns the product of nums. (*) returns 1.\"\n ([] 1)\n ([x] x)\n ([x y] (cljs.core/* x y))\n ([x y & more] (reduce * (cljs.core/* x y) more)))\n"} {:sym min, :meta {:doc "Returns the least of the nums.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n min\n \"Returns the least of the nums.\"\n ([x] x)\n ([x y] (cljs.core/min x y))\n ([x y & more] (reduce min (cljs.core/min x y) more)))\n"} {:sym -persistent!, :meta {:doc "Creates a persistent data structure from tcoll and returns it.", :arglists ([tcoll])}, :protocol ITransientCollection} {:sym -nth, :meta {:doc "Returns the value at the index n in the collection coll.\n     Returns not-found if index n is out of bounds and not-found is supplied.", :arglists ([coll n] [coll n not-found])}, :protocol IIndexed} {:sym pop!, :meta {:doc "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns tcoll", :arglists ([tcoll])}, :source "(defn\n pop!\n \"Removes the last item from a transient vector. If\\n  the collection is empty, throws an exception. Returns tcoll\"\n [tcoll]\n (-pop! tcoll))\n"} {:sym chunk-append, :meta {:doc nil, :arglists ([b x])}, :source "(defn chunk-append [b x] (.add b x))\n"} {:sym *unchecked-arrays*, :meta {}, :source "(def *unchecked-arrays* false)\n"} {:sym IReversible, :meta {:doc "Protocol for reversing a seq."}, :methods (-rseq)} {:sym reversible?, :meta {:doc "Returns true if coll satisfies? IReversible.", :arglists ([coll])}, :source "(defn\n reversible?\n \"Returns true if coll satisfies? IReversible.\"\n [coll]\n (satisfies? IReversible coll))\n"} {:sym -realized?, :meta {:doc "Returns true if a value for x has been produced, false otherwise.", :arglists ([x])}, :protocol IPending} {:sym -add-watch, :meta {:doc "Adds a watcher function f to this. Keys must be unique per reference,\n     and can be used to remove the watch with -remove-watch.", :arglists ([this key f])}, :protocol IWatchable} {:sym -deref-with-timeout, :meta {:doc nil, :arglists ([o msec timeout-val])}, :protocol IDerefWithTimeout} {:sym conj, :meta {:doc "conj[oin]. Returns a new collection with the xs\n  'added'. (conj nil item) returns (item).  The 'addition' may\n  happen at different 'places' depending on the concrete type.", :arglists [[] [coll] [coll x] [coll x & xs]]}, :source "(defn\n conj\n \"conj[oin]. Returns a new collection with the xs\\n  'added'. (conj nil item) returns (item).  The 'addition' may\\n  happen at different 'places' depending on the concrete type.\"\n ([] [])\n ([coll] coll)\n ([coll x] (if-not (nil? coll) (-conj coll x) (list x)))\n ([coll x & xs]\n  (if xs (recur (conj coll x) (first xs) (next xs)) (conj coll x))))\n"} {:sym -sorted-seq, :meta {:doc "Returns a sorted seq from coll in either ascending or descending order.", :arglists ([coll ascending?])}, :protocol ISorted} {:sym transduce, :meta {:doc "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items.", :arglists [[xform f coll] [xform f init coll]]}, :source "(defn\n transduce\n \"reduce with a transformation of f (xf). If init is not\\n  supplied, (f) will be called to produce it. f should be a reducing\\n  step function that accepts both 1 and 2 arguments, if it accepts\\n  only 2 you can add the arity-1 with 'completing'. Returns the result\\n  of applying (the transformed) xf to init and the first item in coll,\\n  then applying xf to that result and the 2nd item, etc. If coll\\n  contains no items, returns init and f is not called. Note that\\n  certain transforms may inject or skip items.\"\n ([xform f coll] (transduce xform f (f) coll))\n ([xform f init coll]\n  (let [f (xform f) ret (reduce f init coll)] (f ret))))\n"} {:sym -swap!, :meta {:doc "Swaps the value of o to be (apply f current-value-of-atom args).", :arglists ([o f] [o f a] [o f a b] [o f a b xs])}, :protocol ISwap} {:sym *print-length*, :meta {:doc "*print-length* controls how many items of each collection the\n  printer will print. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  number of items of each collection to print. If a collection contains\n  more items, the printer will print items up to the limit followed by\n  '...' to represent the remaining items. The root binding is nil\n  indicating no limit."}, :source "(def *print-length* nil)\n"} {:sym js-delete, :meta {:doc "Delete a property from a JavaScript object.", :arglists ([obj key])}, :source "(defn\n js-delete\n \"Delete a property from a JavaScript object.\"\n [obj key]\n (cljs.core/js-delete obj key))\n"} {:sym truth_, :meta {:doc "Internal - do not use!", :arglists ([x])}, :source "(defn truth_ \"Internal - do not use!\" [x] (cljs.core/truth_ x))\n"} {:sym compare-and-set!, :meta {:doc "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is equal to oldval. Returns true if\n  set happened, else false.", :arglists ([a oldval newval])}, :source "(defn\n compare-and-set!\n \"Atomically sets the value of atom to newval if and only if the\\n  current value of the atom is equal to oldval. Returns true if\\n  set happened, else false.\"\n [a oldval newval]\n (if (= (-deref a) oldval) (do (reset! a newval) true) false))\n"} {:sym array-seq, :meta {:doc "Create a seq from a JavaScript array.", :arglists [[array] [array i]]}, :source "(defn\n array-seq\n \"Create a seq from a JavaScript array.\"\n ([array] (prim-seq array 0))\n ([array i] (prim-seq array i)))\n"} {:sym interleave, :meta {:doc "Returns a lazy seq of the first item in each coll, then the second etc.", :arglists [[] [c1] [c1 c2] [c1 c2 & colls]]}, :source "(defn\n interleave\n \"Returns a lazy seq of the first item in each coll, then the second etc.\"\n ([] ())\n ([c1] (lazy-seq c1))\n ([c1 c2]\n  (lazy-seq\n   (let\n    [s1 (seq c1) s2 (seq c2)]\n    (when\n     (and s1 s2)\n     (cons\n      (first s1)\n      (cons (first s2) (interleave (rest s1) (rest s2))))))))\n ([c1 c2 & colls]\n  (lazy-seq\n   (let\n    [ss (map seq (conj colls c2 c1))]\n    (when\n     (every? identity ss)\n     (concat (map first ss) (apply interleave (map rest ss))))))))\n"} {:sym map?, :meta {:doc "Return true if x satisfies IMap", :arglists ([x])}, :source "(defn\n map?\n \"Return true if x satisfies IMap\"\n [x]\n (if (nil? x) false (satisfies? IMap x)))\n"} {:sym m3-C1, :meta {}, :source "(def m3-C1 (int 3432918353))\n"} {:sym get, :meta {:doc "Returns the value mapped to key, not-found or nil if key not present.", :arglists [[o k] [o k not-found]]}, :source "(defn\n get\n \"Returns the value mapped to key, not-found or nil if key not present.\"\n ([o k]\n  (when-not\n   (nil? o)\n   (cond\n    (implements? ILookup o)\n    (-lookup o k)\n    (array? o)\n    (when (and (some? k) (< k (.-length o))) (aget o (int k)))\n    (string? o)\n    (when (and (some? k) (< k (.-length o))) (.charAt o (int k)))\n    (native-satisfies? ILookup o)\n    (-lookup o k)\n    :else\n    nil)))\n ([o k not-found]\n  (if-not\n   (nil? o)\n   (cond\n    (implements? ILookup o)\n    (-lookup o k not-found)\n    (array? o)\n    (if\n     (and (some? k) (>= k 0) (< k (.-length o)))\n     (aget o (int k))\n     not-found)\n    (string? o)\n    (if\n     (and (some? k) (>= k 0) (< k (.-length o)))\n     (.charAt o (int k))\n     not-found)\n    (native-satisfies? ILookup o)\n    (-lookup o k not-found)\n    :else\n    not-found)\n   not-found)))\n"} {:sym identity, :meta {:doc "Returns its argument.", :arglists ([x])}, :source "(defn identity \"Returns its argument.\" [x] x)\n"} {:sym into, :meta {:doc "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined. A transducer may be supplied.", :arglists [[] [to] [to from] [to xform from]]}, :source "(defn\n into\n \"Returns a new coll consisting of to-coll with all of the items of\\n  from-coll conjoined. A transducer may be supplied.\"\n ([] [])\n ([to] to)\n ([to from]\n  (if-not\n   (nil? to)\n   (if\n    (implements? IEditableCollection to)\n    (-with-meta\n     (persistent! (reduce -conj! (transient to) from))\n     (meta to))\n    (reduce -conj to from))\n   (reduce conj () from)))\n ([to xform from]\n  (if\n   (implements? IEditableCollection to)\n   (-with-meta\n    (persistent! (transduce xform conj! (transient to) from))\n    (meta to))\n   (transduce xform conj to from))))\n"} {:sym long, :meta {:doc "Coerce to long by stripping decimal places. Identical to `int'.", :arglists ([x])}, :source "(defn\n long\n \"Coerce to long by stripping decimal places. Identical to `int'.\"\n [x]\n (fix x))\n"} {:sym double, :meta {:doc nil, :arglists ([x])}, :source "(defn double [x] x)\n"} {:sym volatile?, :meta {:doc "Returns true if x is a volatile.", :arglists ([x])}, :source "(defn\n volatile?\n \"Returns true if x is a volatile.\"\n [x]\n (instance? Volatile x))\n"} {:sym -key, :meta {:doc "Returns the key of the map entry.", :arglists ([coll])}, :protocol IMapEntry} {:sym nfirst, :meta {:doc "Same as (next (first x))", :arglists ([coll])}, :source "(defn nfirst \"Same as (next (first x))\" [coll] (next (first coll)))\n"} {:sym meta, :meta {:doc "Returns the metadata of obj, returns nil if there is no metadata.", :arglists ([o])}, :source "(defn\n meta\n \"Returns the metadata of obj, returns nil if there is no metadata.\"\n [o]\n (when (and (not (nil? o)) (satisfies? IMeta o)) (-meta o)))\n"} {:sym -kv-reduce, :meta {:doc "Reduces an associative collection and returns the result. f should be\n     a function that takes three arguments.", :arglists ([coll f init])}, :protocol IKVReduce} {:sym IHash, :meta {:doc "Protocol for adding hashing functionality to a type."}, :methods (-hash)} {:sym bit-and-not, :meta {:doc "Bitwise and with complement", :arglists [[x y] [x y & more]]}, :source "(defn\n bit-and-not\n \"Bitwise and with complement\"\n ([x y] (cljs.core/bit-and-not x y))\n ([x y & more] (reduce bit-and-not (cljs.core/bit-and-not x y) more)))\n"} {:sym var?, :meta {:doc "Returns true if v is of type cljs.core.Var", :arglists ([v])}, :source "(defn\n var?\n \"Returns true if v is of type cljs.core.Var\"\n [v]\n (instance? cljs.core.Var v))\n"} {:sym -comparator, :meta {:doc "Returns the comparator for coll.", :arglists ([coll])}, :protocol ISorted} {:sym unchecked-add-int, :meta {:doc "Returns the sum of nums. (+) returns 0.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n unchecked-add-int\n \"Returns the sum of nums. (+) returns 0.\"\n ([] 0)\n ([x] x)\n ([x y] (cljs.core/unchecked-add-int x y))\n ([x y & more]\n  (reduce unchecked-add-int (cljs.core/unchecked-add-int x y) more)))\n"} {:sym hash-ordered-coll, :meta {:doc "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://clojure.org/data_structures#hash for full algorithms.", :arglists ([coll])}, :source "(defn\n hash-ordered-coll\n \"Returns the hash code, consistent with =, for an external ordered\\n   collection implementing Iterable.\\n   See http://clojure.org/data_structures#hash for full algorithms.\"\n [coll]\n (loop\n  [n 0 hash-code 1 coll (seq coll)]\n  (if-not\n   (nil? coll)\n   (recur\n    (inc n)\n    (bit-or (+ (imul 31 hash-code) (hash (first coll))) 0)\n    (next coll))\n   (mix-collection-hash hash-code n))))\n"} {:sym IEquiv, :meta {:doc "Protocol for adding value comparison functionality to a type."}, :methods (-equiv)} {:sym cycle, :meta {:doc "Returns a lazy (infinite!) sequence of repetitions of the items in coll.", :arglists ([coll])}, :source "(defn\n cycle\n \"Returns a lazy (infinite!) sequence of repetitions of the items in coll.\"\n [coll]\n (lazy-seq (when-let [s (seq coll)] (concat s (cycle s)))))\n"} {:sym -deref, :meta {:doc "Returns the value of the reference o.", :arglists ([o])}, :protocol IDeref} {:sym empty?, :meta {:doc "Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))", :arglists ([coll])}, :source "(defn\n empty?\n \"Returns true if coll has no items - same as (not (seq coll)).\\n  Please use the idiom (seq x) rather than (not (empty? x))\"\n [coll]\n (or (nil? coll) (not (seq coll))))\n"} {:sym short, :meta {:doc nil, :arglists ([x])}, :source "(defn short [x] x)\n"} {:sym -chunked-first, :meta {:doc "Returns the first chunk in coll.", :arglists ([coll])}, :protocol IChunkedSeq} {:sym filterv, :meta {:doc "Returns a vector of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.", :arglists ([pred coll])}, :source "(defn\n filterv\n \"Returns a vector of the items in coll for which\\n  (pred item) returns true. pred must be free of side-effects.\"\n [pred coll]\n (->\n  (reduce (fn [v o] (if (pred o) (conj! v o) v)) (transient []) coll)\n  persistent!))\n"} {:sym hash, :meta {:doc "Returns the hash code of its argument. Note this is the hash code\n   consistent with =.", :arglists ([o])}, :source "(defn\n hash\n \"Returns the hash code of its argument. Note this is the hash code\\n   consistent with =.\"\n [o]\n (cond\n  (implements? IHash o)\n  (bit-xor (-hash o) 0)\n  (number? o)\n  (if\n   (js/isFinite o)\n   (js-mod (Math/floor o) 2147483647)\n   (case o ##Inf 2146435072 ##-Inf -1048576 2146959360))\n  (true? o)\n  1231\n  (false? o)\n  1237\n  (string? o)\n  (m3-hash-int (hash-string o))\n  (instance? js/Date o)\n  (bit-xor (.valueOf o) 0)\n  (nil? o)\n  0\n  :else\n  (bit-xor (-hash o) 0)))\n"} {:sym quot, :meta {:doc "quot[ient] of dividing numerator by denominator.", :arglists ([n d])}, :source "(defn\n quot\n \"quot[ient] of dividing numerator by denominator.\"\n [n d]\n (let [rem (js-mod n d)] (fix (/ (- n rem) d))))\n"} {:sym unchecked-double, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-double [x] x)\n"} {:sym ranged-iterator, :meta {:doc nil, :arglists ([v start end])}, :source "(defn\n ranged-iterator\n [v start end]\n (let\n  [i start]\n  (RangedIterator.\n   i\n   (- i (js-mod i 32))\n   (when (< start (count v)) (unchecked-array-for v i))\n   v\n   start\n   end)))\n"} {:sym ITransientVector, :meta {:doc "Protocol for adding vector functionality to transient collections."}, :methods (-assoc-n! -pop!)} {:sym longs, :meta {:doc nil, :arglists ([x])}, :source "(defn longs [x] x)\n"} {:sym not=, :meta {:doc "Same as (not (= obj1 obj2))", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n not=\n \"Same as (not (= obj1 obj2))\"\n ([x] false)\n ([x y] (not (= x y)))\n ([x y & more] (not (apply = x y more))))\n"} {:sym set-print-err-fn!, :meta {:doc "Set *print-err-fn* to f.", :arglists ([f])}, :source "(defn\n set-print-err-fn!\n \"Set *print-err-fn* to f.\"\n [f]\n (set! *print-err-fn* f))\n"} {:sym string?, :meta {:doc "Returns true if x is a JavaScript string.", :arglists ([x])}, :source "(defn\n string?\n \"Returns true if x is a JavaScript string.\"\n [x]\n (goog/isString x))\n"} {:sym es6-iterator, :meta {:doc "EXPERIMENTAL: Return a ES2015 compatible iterator for coll.", :arglists ([coll])}, :source "(defn\n es6-iterator\n \"EXPERIMENTAL: Return a ES2015 compatible iterator for coll.\"\n [coll]\n (ES6Iterator. (seq coll)))\n"} {:sym m3-C2, :meta {}, :source "(def m3-C2 (int 461845907))\n"} {:sym *print-newline*, :meta {:doc "When set to logical false will drop newlines from printing calls.\n  This is to work around the implicit newlines emitted by standard JavaScript\n  console objects."}, :source "(def *print-newline* true)\n"} {:sym unchecked-multiply-int, :meta {:doc "Returns the product of nums. (*) returns 1.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n unchecked-multiply-int\n \"Returns the product of nums. (*) returns 1.\"\n ([] 1)\n ([x] x)\n ([x y] (cljs.core/unchecked-multiply-int x y))\n ([x y & more]\n  (reduce\n   unchecked-multiply-int\n   (cljs.core/unchecked-multiply-int x y)\n   more)))\n"} {:sym chunk-rest, :meta {:doc nil, :arglists ([s])}, :source "(defn chunk-rest [s] (-chunked-rest s))\n"} {:sym double?, :meta {:doc "Returns true for JavaScript numbers, false otherwise.", :arglists ([x])}, :source "(defn\n double?\n \"Returns true for JavaScript numbers, false otherwise.\"\n [x]\n (number? x))\n"} {:sym vec, :meta {:doc "Creates a new vector containing the contents of coll. JavaScript arrays\n  will be aliased and should not be modified.", :arglists ([coll])}, :source "(defn\n vec\n \"Creates a new vector containing the contents of coll. JavaScript arrays\\n  will be aliased and should not be modified.\"\n [coll]\n (if\n  (array? coll)\n  (.fromArray PersistentVector coll true)\n  (-persistent!\n   (reduce -conj! (-as-transient (.-EMPTY PersistentVector)) coll))))\n"} {:sym *print-meta*, :meta {:doc "If set to logical true, when printing an object, its metadata will also\n  be printed in a form that can be read back by the reader.\n\n  Defaults to false."}, :source "(def *print-meta* false)\n"} {:sym -notify-watches, :meta {:doc "Calls all watchers with this, oldval and newval.", :arglists ([this oldval newval])}, :protocol IWatchable} {:sym int, :meta {:doc "Coerce to int by stripping decimal places.", :arglists ([x])}, :source "(defn int \"Coerce to int by stripping decimal places.\" [x] (bit-or x 0))\n"} {:sym second, :meta {:doc "Same as (first (next x))", :arglists ([coll])}, :source "(defn second \"Same as (first (next x))\" [coll] (first (next coll)))\n"} {:sym IEditableCollection, :meta {:doc "Protocol for collections which can transformed to transients."}, :methods (-as-transient)} {:sym hash-combine, :meta {:doc nil, :arglists ([seed hash])}, :source "(defn\n hash-combine\n [seed hash]\n (bit-xor\n  seed\n  (+ hash 2654435769 (bit-shift-left seed 6) (bit-shift-right seed 2))))\n"} {:sym >, :meta {:doc "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n >\n \"Returns non-nil if nums are in monotonically decreasing order,\\n  otherwise false.\"\n ([x] true)\n ([x y] (cljs.core/> x y))\n ([x y & more]\n  (if\n   (cljs.core/> x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (cljs.core/> y (first more)))\n   false)))\n"} {:sym -name, :meta {:doc "Returns the name String of x.", :arglists ([x])}, :protocol INamed} {:sym int?, :meta {:doc "Return true if x satisfies integer? or is an instance of goog.math.Integer\n   or goog.math.Long.", :arglists ([x])}, :source "(defn\n int?\n \"Return true if x satisfies integer? or is an instance of goog.math.Integer\\n   or goog.math.Long.\"\n [x]\n (or\n  (integer? x)\n  (instance? goog.math.Integer x)\n  (instance? goog.math.Long x)))\n"} {:sym associative?, :meta {:doc "Returns true if coll implements Associative", :arglists ([x])}, :source "(defn\n associative?\n \"Returns true if coll implements Associative\"\n [x]\n (satisfies? IAssociative x))\n"} {:sym unchecked-int, :meta {:doc "Coerce to int by stripping decimal places.", :arglists ([x])}, :source "(defn\n unchecked-int\n \"Coerce to int by stripping decimal places.\"\n [x]\n (fix x))\n"} {:sym js-keys, :meta {:doc "Return the JavaScript keys for an object.", :arglists ([obj])}, :source "(defn\n js-keys\n \"Return the JavaScript keys for an object.\"\n [obj]\n (gobject/getKeys obj))\n"} {:sym inst-ms*, :meta {:doc nil, :arglists ([inst])}, :protocol Inst} {:sym keyword?, :meta {:doc "Return true if x is a Keyword", :arglists ([x])}, :source "(defn\n keyword?\n \"Return true if x is a Keyword\"\n [x]\n (instance? Keyword x))\n"} {:sym array-iter, :meta {:doc nil, :arglists ([x])}, :source "(defn array-iter [x] (ArrayIter. x 0))\n"} {:sym -rseq, :meta {:doc "Returns a seq of the items in coll in reversed order.", :arglists ([coll])}, :protocol IReversible} {:sym unchecked-multiply, :meta {:doc "Returns the product of nums. (*) returns 1.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n unchecked-multiply\n \"Returns the product of nums. (*) returns 1.\"\n ([] 1)\n ([x] x)\n ([x y] (cljs.core/unchecked-multiply x y))\n ([x y & more]\n  (reduce unchecked-multiply (cljs.core/unchecked-multiply x y) more)))\n"} {:sym even?, :meta {:doc "Returns true if n is even, throws an exception if n is not an integer", :arglists ([n])}, :source "(defn\n even?\n \"Returns true if n is even, throws an exception if n is not an integer\"\n [n]\n (if\n  (integer? n)\n  (zero? (bit-and n 1))\n  (throw (js/Error. (str \"Argument must be an integer: \" n)))))\n"} {:sym es6-iterator-seq, :meta {:doc "EXPERIMENTAL: Given an ES2015 compatible iterator return a seq.", :arglists ([iter])}, :source "(defn\n es6-iterator-seq\n \"EXPERIMENTAL: Given an ES2015 compatible iterator return a seq.\"\n [iter]\n (let\n  [v (.next iter)]\n  (if (.-done v) () (ES6IteratorSeq. (.-value v) iter nil))))\n"} {:sym unchecked-dec, :meta {:doc "Returns a number one less than x, an int.", :arglists ([x])}, :source "(defn\n unchecked-dec\n \"Returns a number one less than x, an int.\"\n [x]\n (cljs.core/unchecked-dec x))\n"} {:sym Inst, :meta {:doc nil}, :methods (inst-ms*)} {:sym double-array, :meta {:doc "Creates an array of doubles. Does not coerce array, provided for compatibility\n  with Clojure.", :arglists [[size-or-seq] [size init-val-or-seq]]}, :source "(defn\n double-array\n \"Creates an array of doubles. Does not coerce array, provided for compatibility\\n  with Clojure.\"\n ([size-or-seq]\n  (if\n   (number? size-or-seq)\n   (double-array size-or-seq nil)\n   (into-array size-or-seq)))\n ([size init-val-or-seq]\n  (let\n   [a (make-array size)]\n   (if\n    (seq? init-val-or-seq)\n    (let\n     [s (seq init-val-or-seq)]\n     (loop\n      [i 0 s s]\n      (if\n       (and s (< i size))\n       (do (aset a i (first s)) (recur (inc i) (next s)))\n       a)))\n    (do (dotimes [i size] (aset a i init-val-or-seq)) a)))))\n"} {:sym spread, :meta {:doc nil, :arglists ([arglist])}, :source "(defn\n spread\n [arglist]\n (when-not\n  (nil? arglist)\n  (let\n   [n (next arglist)]\n   (if\n    (nil? n)\n    (seq (first arglist))\n    (cons (first arglist) (spread n))))))\n"} {:sym rseq, :meta {:doc "Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil", :arglists ([rev])}, :source "(defn\n rseq\n \"Returns, in constant time, a seq of the items in rev (which\\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil\"\n [rev]\n (-rseq rev))\n"} {:sym IReset, :meta {:doc "Protocol for adding resetting functionality."}, :methods (-reset!)} {:sym IEmptyableCollection, :meta {:doc "Protocol for creating an empty collection."}, :methods (-empty)} {:sym *print-fn-bodies*, :meta {:doc "*print-fns-bodies* controls whether functions print their source or\n    only their names."}, :source "(def *print-fn-bodies* false)\n"} {:sym float, :meta {:doc nil, :arglists ([x])}, :source "(defn float [x] x)\n"} {:sym IRecord, :meta {:doc "Marker interface indicating a record object"}, :methods ()} {:sym concat, :meta {:doc "Returns a lazy seq representing the concatenation of the elements in the supplied colls.", :arglists [[] [x] [x y] [x y & zs]]}, :source "(defn\n concat\n \"Returns a lazy seq representing the concatenation of the elements in the supplied colls.\"\n ([] (lazy-seq nil))\n ([x] (lazy-seq x))\n ([x y]\n  (lazy-seq\n   (let\n    [s (seq x)]\n    (if\n     s\n     (if\n      (chunked-seq? s)\n      (chunk-cons (chunk-first s) (concat (chunk-rest s) y))\n      (cons (first s) (concat (rest s) y)))\n     y))))\n ([x y & zs]\n  (let\n   [cat\n    (fn\n     cat\n     [xys zs]\n     (lazy-seq\n      (let\n       [xys (seq xys)]\n       (if\n        xys\n        (if\n         (chunked-seq? xys)\n         (chunk-cons (chunk-first xys) (cat (chunk-rest xys) zs))\n         (cons (first xys) (cat (rest xys) zs)))\n        (when zs (cat (first zs) (next zs)))))))]\n   (cat (concat x y) zs))))\n"} {:sym IDerefWithTimeout, :meta {:doc nil}, :methods (-deref-with-timeout)} {:sym symbol, :meta {:doc "Returns a Symbol with the given namespace and name.", :arglists [[name] [ns name]]}, :source "(defn\n symbol\n \"Returns a Symbol with the given namespace and name.\"\n ([name]\n  (if\n   (symbol? name)\n   name\n   (let\n    [idx (.indexOf name \"/\")]\n    (if\n     (< idx 1)\n     (symbol nil name)\n     (symbol\n      (.substring name 0 idx)\n      (.substring name (inc idx) (. name -length)))))))\n ([ns name]\n  (let\n   [sym-str (if-not (nil? ns) (str ns \"/\" name) name)]\n   (Symbol. ns name sym-str nil nil))))\n"} {:sym to-array-2d, :meta {:doc "Returns a (potentially-ragged) 2-dimensional array\n  containing the contents of coll.", :arglists ([coll])}, :source "(defn\n to-array-2d\n \"Returns a (potentially-ragged) 2-dimensional array\\n  containing the contents of coll.\"\n [coll]\n (let\n  [ret (make-array (count coll))]\n  (loop\n   [i 0 xs (seq coll)]\n   (when-not\n    (nil? xs)\n    (aset ret i (to-array (first xs)))\n    (recur (inc i) (next xs))))\n  ret))\n"} {:sym mod, :meta {:doc "Modulus of num and div. Truncates toward negative infinity.", :arglists ([n d])}, :source "(defn\n mod\n \"Modulus of num and div. Truncates toward negative infinity.\"\n [n d]\n (js-mod (+ (js-mod n d) d) d))\n"} {:sym ISet, :meta {:doc "Protocol for adding set functionality to a collection."}, :methods (-disjoin)} {:sym pop, :meta {:doc "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item.\n  Note - not the same as next/butlast.", :arglists ([coll])}, :source "(defn\n pop\n \"For a list or queue, returns a new list/queue without the first\\n  item, for a vector, returns a new vector without the last item.\\n  Note - not the same as next/butlast.\"\n [coll]\n (when-not (nil? coll) (-pop coll)))\n"} {:sym IPending, :meta {:doc "Protocol for types which can have a deferred realization. Currently only\n  implemented by Delay and LazySeq."}, :methods (-realized?)} {:sym -entry-key, :meta {:doc "Returns the key for entry.", :arglists ([coll entry])}, :protocol ISorted} {:sym dissoc!, :meta {:doc "Returns a transient map that doesn't contain a mapping for key(s).", :arglists [[tcoll key] [tcoll key & ks]]}, :source "(defn\n dissoc!\n \"Returns a transient map that doesn't contain a mapping for key(s).\"\n ([tcoll key] (-dissoc! tcoll key))\n ([tcoll key & ks]\n  (let\n   [ntcoll (-dissoc! tcoll key)]\n   (if ks (recur ntcoll (first ks) (next ks)) ntcoll))))\n"} {:sym indexed?, :meta {:doc "Returns true if coll implements nth in constant time", :arglists ([x])}, :source "(defn\n indexed?\n \"Returns true if coll implements nth in constant time\"\n [x]\n (satisfies? IIndexed x))\n"} {:sym -, :meta {:doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n -\n \"If no ys are supplied, returns the negation of x, else subtracts\\n  the ys from x and returns the result.\"\n ([x] (cljs.core/- x))\n ([x y] (cljs.core/- x y))\n ([x y & more] (reduce - (cljs.core/- x y) more)))\n"} {:sym -equiv, :meta {:doc "Returns true if o and other are equal, false otherwise.", :arglists ([o other])}, :protocol IEquiv} {:sym assoc!, :meta {:doc "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll.", :arglists [[tcoll key val] [tcoll key val & kvs]]}, :source "(defn\n assoc!\n \"When applied to a transient map, adds mapping of key(s) to\\n  val(s). When applied to a transient vector, sets the val at index.\\n  Note - index must be <= (count vector). Returns coll.\"\n ([tcoll key val] (-assoc! tcoll key val))\n ([tcoll key val & kvs]\n  (let\n   [ntcoll (-assoc! tcoll key val)]\n   (if\n    kvs\n    (recur ntcoll (first kvs) (second kvs) (nnext kvs))\n    ntcoll))))\n"} {:sym reduce-kv, :meta {:doc "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals.", :arglists [[f init coll]]}, :source "(defn\n reduce-kv\n \"Reduces an associative collection. f should be a function of 3\\n  arguments. Returns the result of applying f to init, the first key\\n  and the first value in coll, then applying f to that result and the\\n  2nd key and value, etc. If coll contains no entries, returns init\\n  and f is not called. Note that reduce-kv is supported on vectors,\\n  where the keys will be the ordinals.\"\n ([f init coll] (if-not (nil? coll) (-kv-reduce coll f init) init)))\n"} {:sym reset!, :meta {:doc "Sets the value of atom to newval without regard for the\n  current value. Returns new-value.", :arglists ([a new-value])}, :source "(defn\n reset!\n \"Sets the value of atom to newval without regard for the\\n  current value. Returns new-value.\"\n [a new-value]\n (if\n  (instance? Atom a)\n  (let\n   [validate (.-validator a)]\n   (when-not\n    (nil? validate)\n    (when-not\n     (validate new-value)\n     (throw (js/Error. \"Validator rejected reference state\"))))\n   (let\n    [old-value (.-state a)]\n    (set! (.-state a) new-value)\n    (when-not\n     (nil? (.-watches a))\n     (-notify-watches a old-value new-value))\n    new-value))\n  (-reset! a new-value)))\n"} {:sym Fn, :meta {:doc "Marker protocol"}, :methods ()} {:sym ffirst, :meta {:doc "Same as (first (first x))", :arglists ([coll])}, :source "(defn ffirst \"Same as (first (first x))\" [coll] (first (first coll)))\n"} {:sym counted?, :meta {:doc "Returns true if coll implements count in constant time", :arglists ([x])}, :source "(defn\n counted?\n \"Returns true if coll implements count in constant time\"\n [x]\n (satisfies? ICounted x))\n"} {:sym assoc-in, :meta {:doc "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created.", :arglists ([m [k & ks] v])}, :source "(defn\n assoc-in\n \"Associates a value in a nested associative structure, where ks is a\\n  sequence of keys and v is the new value and returns a new nested structure.\\n  If any levels do not exist, hash-maps will be created.\"\n [m [k & ks] v]\n (if ks (assoc m k (assoc-in (get m k) ks v)) (assoc m k v)))\n"} {:sym bit-test, :meta {:doc "Test bit at index n", :arglists ([x n])}, :source "(defn bit-test \"Test bit at index n\" [x n] (cljs.core/bit-test x n))\n"} {:sym ISwap, :meta {:doc "Protocol for adding swapping functionality."}, :methods (-swap!)} {:sym zero?, :meta {:doc "Returns true if num is zero, else false", :arglists ([x])}, :source "(defn\n zero?\n \"Returns true if num is zero, else false\"\n [x]\n (cljs.core/zero? x))\n"} {:sym simple-keyword?, :meta {:doc "Return true if x is a keyword without a namespace", :arglists ([x])}, :source "(defn\n simple-keyword?\n \"Return true if x is a keyword without a namespace\"\n [x]\n (and (keyword? x) (nil? (namespace x))))\n"} {:sym *main-cli-fn*, :meta {:doc "When compiled for a command-line target, whatever function\n  *main-cli-fn* is set to will be called with the command-line\n  argv as arguments"}, :source "(def *main-cli-fn* nil)\n"} {:sym -assoc-n, :meta {:doc "Returns a new vector with value val added at position n.", :arglists ([coll n val])}, :protocol IVector} {:sym unchecked-dec-int, :meta {:doc "Returns a number one less than x, an int.", :arglists ([x])}, :source "(defn\n unchecked-dec-int\n \"Returns a number one less than x, an int.\"\n [x]\n (cljs.core/unchecked-dec-int x))\n"} {:sym persistent!, :meta {:doc "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception.", :arglists ([tcoll])}, :source "(defn\n persistent!\n \"Returns a new, persistent version of the transient collection, in\\n  constant time. The transient collection cannot be used after this\\n  call, any such use will throw an exception.\"\n [tcoll]\n (-persistent! tcoll))\n"} {:sym set-print-fn!, :meta {:doc "Set *print-fn* to f.", :arglists ([f])}, :source "(defn set-print-fn! \"Set *print-fn* to f.\" [f] (set! *print-fn* f))\n"} {:sym nnext, :meta {:doc "Same as (next (next x))", :arglists ([coll])}, :source "(defn nnext \"Same as (next (next x))\" [coll] (next (next coll)))\n"} {:sym not-every?, :meta {:doc "Returns false if (pred x) is logical true for every x in\n  coll, else true.", :arglists ([pred coll])}, :source "(defn\n not-every?\n \"Returns false if (pred x) is logical true for every x in\\n  coll, else true.\"\n [pred coll]\n (not (every? pred coll)))\n"} {:sym rem, :meta {:doc "remainder of dividing numerator by denominator.", :arglists ([n d])}, :source "(defn\n rem\n \"remainder of dividing numerator by denominator.\"\n [n d]\n (let [q (quot n d)] (- n (* d q))))\n"} {:sym ifind?, :meta {:doc "Returns true if coll implements IFind", :arglists ([x])}, :source "(defn\n ifind?\n \"Returns true if coll implements IFind\"\n [x]\n (satisfies? IFind x))\n"} {:sym some, :meta {:doc "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)", :arglists ([pred coll])}, :source "(defn\n some\n \"Returns the first logical true value of (pred x) for any x in coll,\\n  else nil.  One common idiom is to use a set as pred, for example\\n  this will return :fred if :fred is in the sequence, otherwise nil:\\n  (some #{:fred} coll)\"\n [pred coll]\n (when (seq coll) (or (pred (first coll)) (recur pred (next coll)))))\n"} {:sym INamed, :meta {:doc "Protocol for adding a name."}, :methods (-name -namespace)} {:sym IReduce, :meta {:doc "Protocol for seq types that can reduce themselves.\n  Called by cljs.core/reduce."}, :methods (-reduce)} {:sym neg-int?, :meta {:doc "Return true if x satisfies int? and is negative.", :arglists ([x])}, :source "(defn\n neg-int?\n \"Return true if x satisfies int? and is negative.\"\n [x]\n (cond\n  (integer? x)\n  (neg? x)\n  (instance? goog.math.Integer x)\n  (.isNegative x)\n  (instance? goog.math.Long x)\n  (.isNegative x)\n  :else\n  false))\n"} {:sym drop, :meta {:doc "Returns a lazy sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided.", :arglists [[n] [n coll]]}, :source "(defn\n drop\n \"Returns a lazy sequence of all but the first n items in coll.\\n  Returns a stateful transducer when no collection is provided.\"\n ([n]\n  {:pre [(number? n)]}\n  (fn\n   [rf]\n   (let\n    [na (volatile! n)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input]\n      (let\n       [n @na]\n       (vswap! na dec)\n       (if (pos? n) result (rf result input))))))))\n ([n coll]\n  {:pre [(number? n)]}\n  (let\n   [step\n    (fn\n     [n coll]\n     (let\n      [s (seq coll)]\n      (if (and (pos? n) s) (recur (dec n) (rest s)) s)))]\n   (lazy-seq (step n coll)))))\n"} {:sym js-obj, :meta {:doc "Create JavaSript object from an even number arguments representing\n  interleaved keys and values.", :arglists [[] [& keyvals]]}, :source "(defn\n js-obj\n \"Create JavaSript object from an even number arguments representing\\n  interleaved keys and values.\"\n ([] (cljs.core/js-obj))\n ([& keyvals] (apply gobject/create keyvals)))\n"} {:sym ITransientCollection, :meta {:doc "Protocol for adding basic functionality to transient collections."}, :methods (-conj! -persistent!)} {:sym nth, :meta {:doc "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences.", :arglists [[coll n] [coll n not-found]]}, :source "(defn\n nth\n \"Returns the value at the index. get returns nil if index out of\\n  bounds, nth throws an exception unless not-found is supplied.  nth\\n  also works for strings, arrays, regex Matchers and Lists, and,\\n  in O(n) time, for sequences.\"\n ([coll n]\n  (cond\n   (not (number? n))\n   (throw (js/Error. \"Index argument to nth must be a number\"))\n   (nil? coll)\n   coll\n   (implements? IIndexed coll)\n   (-nth coll n)\n   (array? coll)\n   (if\n    (and (>= n 0) (< n (.-length coll)))\n    (aget coll n)\n    (throw (js/Error. \"Index out of bounds\")))\n   (string? coll)\n   (if\n    (and (>= n 0) (< n (.-length coll)))\n    (.charAt coll n)\n    (throw (js/Error. \"Index out of bounds\")))\n   (implements? ISeq coll)\n   (linear-traversal-nth coll n)\n   (native-satisfies? IIndexed coll)\n   (-nth coll n)\n   :else\n   (throw\n    (js/Error.\n     (str\n      \"nth not supported on this type \"\n      (type->str (type coll)))))))\n ([coll n not-found]\n  (cond\n   (not (number? n))\n   (throw (js/Error. \"Index argument to nth must be a number.\"))\n   (nil? coll)\n   not-found\n   (implements? IIndexed coll)\n   (-nth coll n not-found)\n   (array? coll)\n   (if (and (>= n 0) (< n (.-length coll))) (aget coll n) not-found)\n   (string? coll)\n   (if (and (>= n 0) (< n (.-length coll))) (.charAt coll n) not-found)\n   (implements? ISeq coll)\n   (linear-traversal-nth coll n not-found)\n   (native-satisfies? IIndexed coll)\n   (-nth coll n not-found)\n   :else\n   (throw\n    (js/Error.\n     (str\n      \"nth not supported on this type \"\n      (type->str (type coll))))))))\n"} {:sym sorted?, :meta {:doc "Returns true if coll satisfies ISorted", :arglists ([x])}, :source "(defn\n sorted?\n \"Returns true if coll satisfies ISorted\"\n [x]\n (satisfies? ISorted x))\n"} {:sym nil?, :meta {:doc "Returns true if x is nil, false otherwise.", :arglists ([x])}, :source "(defn\n nil?\n \"Returns true if x is nil, false otherwise.\"\n [x]\n (coercive-= x nil))\n"} {:sym split-at, :meta {:doc "Returns a vector of [(take n coll) (drop n coll)]", :arglists ([n coll])}, :source "(defn\n split-at\n \"Returns a vector of [(take n coll) (drop n coll)]\"\n [n coll]\n [(take n coll) (drop n coll)])\n"} {:sym not-native, :meta {}, :source "(def not-native nil)\n"} {:sym bit-and, :meta {:doc "Bitwise and", :arglists [[x y] [x y & more]]}, :source "(defn\n bit-and\n \"Bitwise and\"\n ([x y] (cljs.core/bit-and x y))\n ([x y & more] (reduce bit-and (cljs.core/bit-and x y) more)))\n"} {:sym bounded-count, :meta {:doc "If coll is counted? returns its count, else will count at most the first n\n   elements of coll using its seq", :arglists ([n coll])}, :source "(defn\n bounded-count\n \"If coll is counted? returns its count, else will count at most the first n\\n   elements of coll using its seq\"\n {:added \"1.9\"}\n [n coll]\n (if\n  (counted? coll)\n  (count coll)\n  (loop\n   [i 0 s (seq coll)]\n   (if (and (not (nil? s)) (< i n)) (recur (inc i) (next s)) i))))\n"} {:sym update, :meta {:doc "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value.", :arglists [[m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more]]}, :source "(defn\n update\n \"'Updates' a value in an associative structure, where k is a\\n  key and f is a function that will take the old value\\n  and any supplied args and return the new value, and returns a new\\n  structure.  If the key does not exist, nil is passed as the old value.\"\n ([m k f] (assoc m k (f (get m k))))\n ([m k f x] (assoc m k (f (get m k) x)))\n ([m k f x y] (assoc m k (f (get m k) x y)))\n ([m k f x y z] (assoc m k (f (get m k) x y z)))\n ([m k f x y z & more] (assoc m k (apply f (get m k) x y z more))))\n"} {:sym list*, :meta {:doc "Creates a new list containing the items prepended to the rest, the\n  last of which will be treated as a sequence.", :arglists [[args] [a args] [a b args] [a b c args] [a b c d & more]]}, :source "(defn\n list*\n \"Creates a new list containing the items prepended to the rest, the\\n  last of which will be treated as a sequence.\"\n ([args] (seq args))\n ([a args] (cons a args))\n ([a b args] (cons a (cons b args)))\n ([a b c args] (cons a (cons b (cons c args))))\n ([a b c d & more] (cons a (cons b (cons c (cons d (spread more)))))))\n"} {:sym update-in, :meta {:doc "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created.", :arglists [[m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c] [m [k & ks] f a b c & args]]}, :source "(defn\n update-in\n \"'Updates' a value in a nested associative structure, where ks is a\\n  sequence of keys and f is a function that will take the old value\\n  and any supplied args and return the new value, and returns a new\\n  nested structure.  If any levels do not exist, hash-maps will be\\n  created.\"\n ([m [k & ks] f]\n  (if\n   ks\n   (assoc m k (update-in (get m k) ks f))\n   (assoc m k (f (get m k)))))\n ([m [k & ks] f a]\n  (if\n   ks\n   (assoc m k (update-in (get m k) ks f a))\n   (assoc m k (f (get m k) a))))\n ([m [k & ks] f a b]\n  (if\n   ks\n   (assoc m k (update-in (get m k) ks f a b))\n   (assoc m k (f (get m k) a b))))\n ([m [k & ks] f a b c]\n  (if\n   ks\n   (assoc m k (update-in (get m k) ks f a b c))\n   (assoc m k (f (get m k) a b c))))\n ([m [k & ks] f a b c & args]\n  (if\n   ks\n   (assoc m k (apply update-in (get m k) ks f a b c args))\n   (assoc m k (apply f (get m k) a b c args)))))\n"} {:sym ensure-reduced, :meta {:doc "If x is already reduced?, returns it, else returns (reduced x)", :arglists ([x])}, :source "(defn\n ensure-reduced\n \"If x is already reduced?, returns it, else returns (reduced x)\"\n [x]\n (if (reduced? x) x (reduced x)))\n"} {:sym instance?, :meta {:doc "Evaluates x and tests if it is an instance of the type\n  c. Returns true or false", :arglists ([c x])}, :source "(defn\n instance?\n \"Evaluates x and tests if it is an instance of the type\\n  c. Returns true or false\"\n [c x]\n (cljs.core/instance? c x))\n"} {:sym mix-collection-hash, :meta {:doc "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://clojure.org/data_structures#hash for full algorithms.", :arglists ([hash-basis count])}, :source "(defn\n mix-collection-hash\n \"Mix final collection hash for ordered or unordered collections.\\n   hash-basis is the combined collection hash, count is the number\\n   of elements included in the basis. Note this is the hash code\\n   consistent with =, different from .hashCode.\\n   See http://clojure.org/data_structures#hash for full algorithms.\"\n [hash-basis count]\n (let\n  [h1 m3-seed k1 (m3-mix-K1 hash-basis) h1 (m3-mix-H1 h1 k1)]\n  (m3-fmix h1 count)))\n"} {:sym unchecked-add, :meta {:doc "Returns the sum of nums. (+) returns 0.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n unchecked-add\n \"Returns the sum of nums. (+) returns 0.\"\n ([] 0)\n ([x] x)\n ([x y] (cljs.core/unchecked-add x y))\n ([x y & more]\n  (reduce unchecked-add (cljs.core/unchecked-add x y) more)))\n"} {:sym transformer-iterator, :meta {:doc nil, :arglists ([xform sourceIter multi])}, :source "(defn\n transformer-iterator\n [xform sourceIter multi]\n (let\n  [iterator\n   (TransformerIterator. EMPTY NONE false nil sourceIter multi)]\n  (set!\n   (.-xf iterator)\n   (xform\n    (fn\n     ([] nil)\n     ([acc] acc)\n     ([acc o]\n      (set! (.-buffer iterator) (.add (.-buffer iterator) o))\n      acc))))\n  iterator))\n"} {:sym not, :meta {:doc "Returns true if x is logical false, false otherwise.", :arglists ([x])}, :source "(defn\n not\n \"Returns true if x is logical false, false otherwise.\"\n [x]\n (cond (nil? x) true (false? x) true :else false))\n"} {:sym -vreset!, :meta {:doc "Sets the value of volatile o to new-value without regard for the\n     current value. Returns new-value.", :arglists ([o new-value])}, :protocol IVolatile} {:sym with-meta, :meta {:doc "Returns an object of the same type and value as obj, with\n  map m as its metadata.", :arglists ([o meta])}, :source "(defn\n with-meta\n \"Returns an object of the same type and value as obj, with\\n  map m as its metadata.\"\n [o meta]\n (if\n  (goog/isFunction o)\n  (MetaFn. o meta)\n  (when-not (nil? o) (-with-meta o meta))))\n"} {:sym unreduced, :meta {:doc "If x is reduced?, returns (deref x), else returns x", :arglists ([x])}, :source "(defn\n unreduced\n \"If x is reduced?, returns (deref x), else returns x\"\n [x]\n (if (reduced? x) (deref x) x))\n"} {:sym record?, :meta {:doc "Return true if x satisfies IRecord", :arglists ([x])}, :source "(defn\n record?\n \"Return true if x satisfies IRecord\"\n [x]\n (satisfies? IRecord x))\n"} {:sym type, :meta {:doc "Return x's constructor.", :arglists ([x])}, :source "(defn\n type\n \"Return x's constructor.\"\n [x]\n (when-not (nil? x) (.-constructor x)))\n"} {:sym identical?, :meta {:doc "Tests if 2 arguments are the same object", :arglists ([x y])}, :source "(defn\n identical?\n \"Tests if 2 arguments are the same object\"\n [x y]\n (cljs.core/identical? x y))\n"} {:sym -namespace, :meta {:doc "Returns the namespace String of x.", :arglists ([x])}, :protocol INamed} {:sym unchecked-divide-int, :meta {:doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n unchecked-divide-int\n \"If no denominators are supplied, returns 1/numerator,\\n  else returns numerator divided by all of the denominators.\"\n ([x] (unchecked-divide-int 1 x))\n ([x y] (cljs.core/divide x y))\n ([x y & more]\n  (reduce unchecked-divide-int (unchecked-divide-int x y) more)))\n"} {:sym *out*, :meta {}, :source "(def *out* nil)\n"} {:sym hash-string, :meta {:doc nil, :arglists ([k])}, :source "(defn\n hash-string\n [k]\n (when\n  (> string-hash-cache-count 255)\n  (set! string-hash-cache (js-obj))\n  (set! string-hash-cache-count 0))\n (if\n  (nil? k)\n  0\n  (let\n   [h (unchecked-get string-hash-cache k)]\n   (if (number? h) h (add-to-string-hash-cache k)))))\n"} {:sym set-validator!, :meta {:doc "Sets the validator-fn for an atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an Error. If the current state\n  is not acceptable to the new validator, an Error will be thrown and the\n  validator will not be changed.", :arglists ([iref val])}, :source "(defn\n set-validator!\n \"Sets the validator-fn for an atom. validator-fn must be nil or a\\n  side-effect-free fn of one argument, which will be passed the intended\\n  new state on any state change. If the new state is unacceptable, the\\n  validator-fn should return false or throw an Error. If the current state\\n  is not acceptable to the new validator, an Error will be thrown and the\\n  validator will not be changed.\"\n [iref val]\n (when\n  (and (some? val) (not (val (-deref iref))))\n  (throw (js/Error. \"Validator rejected reference state\")))\n (set! (.-validator iref) val))\n"} {:sym ident?, :meta {:doc "Return true if x is a symbol or keyword", :arglists ([x])}, :source "(defn\n ident?\n \"Return true if x is a symbol or keyword\"\n [x]\n (or (keyword? x) (symbol? x)))\n"} {:sym -meta, :meta {:doc "Returns the metadata of object o.", :arglists ([o])}, :protocol IMeta} {:sym swap!, :meta {:doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in.", :arglists [[a f] [a f x] [a f x y] [a f x y & more]]}, :source "(defn\n swap!\n \"Atomically swaps the value of atom to be:\\n  (apply f current-value-of-atom args). Note that f may be called\\n  multiple times, and thus should be free of side effects.  Returns\\n  the value that was swapped in.\"\n ([a f]\n  (if (instance? Atom a) (reset! a (f (.-state a))) (-swap! a f)))\n ([a f x]\n  (if (instance? Atom a) (reset! a (f (.-state a) x)) (-swap! a f x)))\n ([a f x y]\n  (if\n   (instance? Atom a)\n   (reset! a (f (.-state a) x y))\n   (-swap! a f x y)))\n ([a f x y & more]\n  (if\n   (instance? Atom a)\n   (reset! a (apply f (.-state a) x y more))\n   (-swap! a f x y more))))\n"} {:sym -chunked-next, :meta {:doc "Returns a new collection of coll without the first chunk.", :arglists ([coll])}, :protocol IChunkedNext} {:sym unchecked-subtract, :meta {:doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n unchecked-subtract\n \"If no ys are supplied, returns the negation of x, else subtracts\\n  the ys from x and returns the result.\"\n ([x] (cljs.core/unchecked-subtract x))\n ([x y] (cljs.core/unchecked-subtract x y))\n ([x y & more]\n  (reduce unchecked-subtract (cljs.core/unchecked-subtract x y) more)))\n"} {:sym IMap, :meta {:doc "Protocol for adding mapping functionality to collections."}, :methods (-dissoc)} {:sym cloneable?, :meta {:doc "Return true if x implements ICloneable protocol.", :arglists ([value])}, :source "(defn\n cloneable?\n \"Return true if x implements ICloneable protocol.\"\n [value]\n (satisfies? ICloneable value))\n"} {:sym qualified-ident?, :meta {:doc "Return true if x is a symbol or keyword with a namespace", :arglists ([x])}, :source "(defn\n qualified-ident?\n \"Return true if x is a symbol or keyword with a namespace\"\n [x]\n (boolean (and (ident? x) (namespace x) true)))\n"} {:sym hash-string*, :meta {:doc nil, :arglists ([s])}, :source "(defn\n hash-string*\n [s]\n (if-not\n  (nil? s)\n  (let\n   [len (.-length s)]\n   (if\n    (pos? len)\n    (loop\n     [i 0 hash 0]\n     (if\n      (< i len)\n      (recur (inc i) (+ (imul 31 hash) (.charCodeAt s i)))\n      hash))\n    0))\n  0))\n"} {:sym true?, :meta {:doc "Returns true if x is the value true, false otherwise.", :arglists ([x])}, :source "(defn\n true?\n \"Returns true if x is the value true, false otherwise.\"\n [x]\n (cljs.core/true? x))\n"} {:sym array, :meta {:doc "Creates a new javascript array.\n@param {...*} var_args", :arglists ([var-args])}, :source "(defn\n array\n \"Creates a new javascript array.\\n@param {...*} var_args\"\n [var-args]\n (let\n  [a (js/Array. (alength (cljs.core/js-arguments)))]\n  (loop\n   [i 0]\n   (if\n    (< i (alength a))\n    (do (aset a i (aget (cljs.core/js-arguments) i)) (recur (inc i)))\n    a))))\n"} {:sym -peek, :meta {:doc "Returns the item from the top of the stack. Is used by cljs.core/peek.", :arglists ([coll])}, :protocol IStack} {:sym ISeq, :meta {:doc "Protocol for collections to provide access to their items as sequences."}, :methods (-first -rest)} {:sym empty, :meta {:doc "Returns an empty collection of the same category as coll, or nil", :arglists ([coll])}, :source "(defn\n empty\n \"Returns an empty collection of the same category as coll, or nil\"\n [coll]\n (when-not (nil? coll) (-empty coll)))\n"} {:sym volatile!, :meta {:doc "Creates and returns a Volatile with an initial value of val.", :arglists ([val])}, :source "(defn\n volatile!\n \"Creates and returns a Volatile with an initial value of val.\"\n [val]\n (Volatile. val))\n"} {:sym /, :meta {:doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n /\n \"If no denominators are supplied, returns 1/numerator,\\n  else returns numerator divided by all of the denominators.\"\n ([x] (/ 1 x))\n ([x y] (cljs.core/divide x y))\n ([x y & more] (reduce / (/ x y) more)))\n"} {:sym bit-or, :meta {:doc "Bitwise or", :arglists [[x y] [x y & more]]}, :source "(defn\n bit-or\n \"Bitwise or\"\n ([x y] (cljs.core/bit-or x y))\n ([x y & more] (reduce bit-or (cljs.core/bit-or x y) more)))\n"} {:sym m3-fmix, :meta {:doc nil, :arglists ([h1 len])}, :source "(defn\n m3-fmix\n [h1 len]\n (as->\n  (int h1)\n  h1\n  (bit-xor h1 len)\n  (bit-xor h1 (unsigned-bit-shift-right h1 16))\n  (imul h1 (int 2246822507))\n  (bit-xor h1 (unsigned-bit-shift-right h1 13))\n  (imul h1 (int 3266489909))\n  (bit-xor h1 (unsigned-bit-shift-right h1 16))))\n"} {:sym vector, :meta {:doc "Creates a new vector containing the args.", :arglists ([& args])}, :source "(defn\n vector\n \"Creates a new vector containing the args.\"\n [& args]\n (if\n  (and (instance? IndexedSeq args) (zero? (.-i args)))\n  (.fromArray PersistentVector (.-arr args) true)\n  (vec args)))\n"} {:sym >=, :meta {:doc "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n >=\n \"Returns non-nil if nums are in monotonically non-increasing order,\\n  otherwise false.\"\n ([x] true)\n ([x y] (cljs.core/>= x y))\n ([x y & more]\n  (if\n   (cljs.core/>= x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (cljs.core/>= y (first more)))\n   false)))\n"} {:sym drop-last, :meta {:doc "Return a lazy sequence of all but the last n (default 1) items in coll", :arglists [[s] [n s]]}, :source "(defn\n drop-last\n \"Return a lazy sequence of all but the last n (default 1) items in coll\"\n ([s] (drop-last 1 s))\n ([n s] (map (fn [x _] x) s (drop n s))))\n"} {:sym object?, :meta {:doc "Returns true if x's constructor is Object", :arglists ([x])}, :source "(defn\n object?\n \"Returns true if x's constructor is Object\"\n [x]\n (if-not (nil? x) (identical? (.-constructor x) js/Object) false))\n"} {:sym not-empty, :meta {:doc "If coll is empty, returns nil, else coll", :arglists ([coll])}, :source "(defn\n not-empty\n \"If coll is empty, returns nil, else coll\"\n [coll]\n (when (seq coll) coll))\n"} {:sym partition, :meta {:doc "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition up to n items. In case there are\n  not enough padding elements, return a partition with less than n items.", :arglists [[n coll] [n step coll] [n step pad coll]]}, :source "(defn\n partition\n \"Returns a lazy sequence of lists of n items each, at offsets step\\n  apart. If step is not supplied, defaults to n, i.e. the partitions\\n  do not overlap. If a pad collection is supplied, use its elements as\\n  necessary to complete last partition up to n items. In case there are\\n  not enough padding elements, return a partition with less than n items.\"\n ([n coll] (partition n n coll))\n ([n step coll]\n  (lazy-seq\n   (when-let\n    [s (seq coll)]\n    (let\n     [p (take n s)]\n     (when\n      (== n (count p))\n      (cons p (partition n step (drop step s))))))))\n ([n step pad coll]\n  (lazy-seq\n   (when-let\n    [s (seq coll)]\n    (let\n     [p (take n s)]\n     (if\n      (== n (count p))\n      (cons p (partition n step pad (drop step s)))\n      (list (take n (concat p pad)))))))))\n"} {:sym DEMUNGE_PATTERN, :meta {}, :source "(def DEMUNGE_PATTERN nil)\n"} {:sym IAssociative, :meta {:doc "Protocol for adding associativity to collections."}, :methods (-assoc -contains-key?)} {:sym bit-flip, :meta {:doc "Flip bit at index n", :arglists ([x n])}, :source "(defn bit-flip \"Flip bit at index n\" [x n] (cljs.core/bit-flip x n))\n"} {:sym long-array, :meta {:doc "Creates an array of longs. Does not coerce array, provided for compatibility\n  with Clojure.", :arglists [[size-or-seq] [size init-val-or-seq]]}, :source "(defn\n long-array\n \"Creates an array of longs. Does not coerce array, provided for compatibility\\n  with Clojure.\"\n ([size-or-seq]\n  (if\n   (number? size-or-seq)\n   (long-array size-or-seq nil)\n   (into-array size-or-seq)))\n ([size init-val-or-seq]\n  (let\n   [a (make-array size)]\n   (if\n    (seq? init-val-or-seq)\n    (let\n     [s (seq init-val-or-seq)]\n     (loop\n      [i 0 s s]\n      (if\n       (and s (< i size))\n       (do (aset a i (first s)) (recur (inc i) (next s)))\n       a)))\n    (do (dotimes [i size] (aset a i init-val-or-seq)) a)))))\n"} {:sym ISeqable, :meta {:doc "Protocol for adding the ability to a type to be transformed into a sequence."}, :methods (-seq)} {:sym js-mod, :meta {:doc "Modulus of num and div with original javascript behavior. i.e. bug for negative numbers", :arglists ([n d])}, :source "(defn\n js-mod\n \"Modulus of num and div with original javascript behavior. i.e. bug for negative numbers\"\n [n d]\n (cljs.core/js-mod n d))\n"} {:sym integer?, :meta {:doc "Returns true if n is a JavaScript number with no decimal part.", :arglists ([n])}, :source "(defn\n integer?\n \"Returns true if n is a JavaScript number with no decimal part.\"\n [n]\n (and\n  (number? n)\n  (not (js/isNaN n))\n  (not (identical? n js/Infinity))\n  (== (js/parseFloat n) (js/parseInt n 10))))\n"} {:sym mapv, :meta {:doc "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.", :arglists [[f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]]}, :source "(defn\n mapv\n \"Returns a vector consisting of the result of applying f to the\\n  set of first items of each coll, followed by applying f to the set\\n  of second items in each coll, until any one of the colls is\\n  exhausted.  Any remaining items in other colls are ignored. Function\\n  f should accept number-of-colls arguments.\"\n ([f coll]\n  (->\n   (reduce (fn [v o] (conj! v (f o))) (transient []) coll)\n   persistent!))\n ([f c1 c2] (into [] (map f c1 c2)))\n ([f c1 c2 c3] (into [] (map f c1 c2 c3)))\n ([f c1 c2 c3 & colls] (into [] (apply map f c1 c2 c3 colls))))\n"} {:sym infinite?, :meta {:doc "Returns true for Infinity and -Infinity values.", :arglists ([x])}, :source "(defn\n infinite?\n \"Returns true for Infinity and -Infinity values.\"\n [x]\n (or\n  (identical? x js/Number.POSITIVE_INFINITY)\n  (identical? x js/Number.NEGATIVE_INFINITY)))\n"} {:sym ISequential, :meta {:doc "Marker interface indicating a persistent collection of sequential items"}, :methods ()} {:sym equiv-map, :meta {:doc "Test map equivalence. Returns true if x equals y, otherwise returns false.", :arglists ([x y])}, :source "(defn\n equiv-map\n \"Test map equivalence. Returns true if x equals y, otherwise returns false.\"\n [x y]\n (boolean\n  (when\n   (and (map? y) (not (record? y)))\n   (when\n    (== (count x) (count y))\n    (if\n     (satisfies? IKVReduce x)\n     (reduce-kv\n      (fn\n       [_ k v]\n       (if (= (get y k never-equiv) v) true (reduced false)))\n      true\n      x)\n     (every?\n      (fn [xkv] (= (get y (first xkv) never-equiv) (second xkv)))\n      x))))))\n"} {:sym object-array, :meta {:doc "Creates an array of objects. Does not coerce array, provided for compatibility\n  with Clojure.", :arglists [[size-or-seq] [size init-val-or-seq]]}, :source "(defn\n object-array\n \"Creates an array of objects. Does not coerce array, provided for compatibility\\n  with Clojure.\"\n ([size-or-seq]\n  (if\n   (number? size-or-seq)\n   (object-array size-or-seq nil)\n   (into-array size-or-seq)))\n ([size init-val-or-seq]\n  (let\n   [a (make-array size)]\n   (if\n    (seq? init-val-or-seq)\n    (let\n     [s (seq init-val-or-seq)]\n     (loop\n      [i 0 s s]\n      (if\n       (and s (< i size))\n       (do (aset a i (first s)) (recur (inc i) (next s)))\n       a)))\n    (do (dotimes [i size] (aset a i init-val-or-seq)) a)))))\n"} {:sym seq-iter, :meta {:doc nil, :arglists ([coll])}, :source "(defn seq-iter [coll] (SeqIter. INIT coll))\n"} {:sym IChunkedSeq, :meta {:doc "Protocol for accessing a collection as sequential chunks."}, :methods (-chunked-first -chunked-rest)} {:sym -next, :meta {:doc "Returns a new collection of coll without the first item. In contrast to\n     rest, it should return nil if there are no more items, e.g.\n     (next []) => nil\n     (next nil) => nil", :arglists ([coll])}, :protocol INext} {:sym flatten, :meta {:doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns nil.", :arglists ([x])}, :source "(defn\n flatten\n \"Takes any nested combination of sequential things (lists, vectors,\\n  etc.) and returns their contents as a single, flat sequence.\\n  (flatten nil) returns nil.\"\n [x]\n (filter\n  (fn* [p1__18388#] (not (sequential? p1__18388#)))\n  (rest (tree-seq sequential? seq x))))\n"} {:sym -dissoc, :meta {:doc "Returns a new collection of coll without the mapping for key k.", :arglists ([coll k])}, :protocol IMap} {:sym doubles, :meta {:doc nil, :arglists ([x])}, :source "(defn doubles [x] x)\n"} {:sym -contains-key?, :meta {:doc "Returns true if k is a key in coll.", :arglists ([coll k])}, :protocol IAssociative} {:sym ifn?, :meta {:doc "Returns true if f returns true for fn? or satisfies IFn.", :arglists ([f])}, :source "(defn\n ifn?\n \"Returns true if f returns true for fn? or satisfies IFn.\"\n [f]\n (or (fn? f) (satisfies? IFn f)))\n"} {:sym IAtom, :meta {:doc "Marker protocol indicating an atom."}, :methods ()} {:sym nat-int?, :meta {:doc "Return true if x satisfies int? and is a natural integer value.", :arglists ([x])}, :source "(defn\n nat-int?\n \"Return true if x satisfies int? and is a natural integer value.\"\n [x]\n (cond\n  (integer? x)\n  (or (not (neg? x)) (zero? x))\n  (instance? goog.math.Integer x)\n  (or (not (.isNegative x)) (.isZero x))\n  (instance? goog.math.Long x)\n  (or (not (.isNegative x)) (.isZero x))\n  :else\n  false))\n"} {:sym IWatchable, :meta {:doc "Protocol for types that can be watched. Currently only implemented by Atom."}, :methods (-add-watch -notify-watches -remove-watch)} {:sym subvec, :meta {:doc "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done.", :arglists [[v start] [v start end]]}, :source "(defn\n subvec\n \"Returns a persistent vector of the items in vector from\\n  start (inclusive) to end (exclusive).  If end is not supplied,\\n  defaults to (count vector). This operation is O(1) and very fast, as\\n  the resulting vector shares structure with the original and no\\n  trimming is done.\"\n ([v start] (subvec v start (count v)))\n ([v start end]\n  (assert (and (not (nil? start)) (not (nil? end))))\n  (build-subvec nil v start end nil)))\n"} {:sym -pop!, :meta {:doc "Returns tcoll with the last item removed from it.", :arglists ([tcoll])}, :protocol ITransientVector} {:sym partial, :meta {:doc "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args.", :arglists [[f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more]]}, :source "(defn\n partial\n \"Takes a function f and fewer than the normal arguments to f, and\\n  returns a fn that takes a variable number of additional args. When\\n  called, the returned function calls f with args + additional args.\"\n ([f] f)\n ([f arg1]\n  (fn\n   ([] (f arg1))\n   ([x] (f arg1 x))\n   ([x y] (f arg1 x y))\n   ([x y z] (f arg1 x y z))\n   ([x y z & args] (apply f arg1 x y z args))))\n ([f arg1 arg2]\n  (fn\n   ([] (f arg1 arg2))\n   ([x] (f arg1 arg2 x))\n   ([x y] (f arg1 arg2 x y))\n   ([x y z] (f arg1 arg2 x y z))\n   ([x y z & args] (apply f arg1 arg2 x y z args))))\n ([f arg1 arg2 arg3]\n  (fn\n   ([] (f arg1 arg2 arg3))\n   ([x] (f arg1 arg2 arg3 x))\n   ([x y] (f arg1 arg2 arg3 x y))\n   ([x y z] (f arg1 arg2 arg3 x y z))\n   ([x y z & args] (apply f arg1 arg2 arg3 x y z args))))\n ([f arg1 arg2 arg3 & more]\n  (fn [& args] (apply f arg1 arg2 arg3 (concat more args)))))\n"} {:sym chunked-seq?, :meta {:doc "Return true if x is satisfies IChunkedSeq.", :arglists ([x])}, :source "(defn\n chunked-seq?\n \"Return true if x is satisfies IChunkedSeq.\"\n [x]\n (implements? IChunkedSeq x))\n"} {:sym replicate, :meta {:doc "DEPRECATED: Use 'repeat' instead.\n  Returns a lazy seq of n xs.", :arglists ([n x])}, :source "(defn\n replicate\n \"DEPRECATED: Use 'repeat' instead.\\n  Returns a lazy seq of n xs.\"\n [n x]\n (take n (repeat x)))\n"} {:sym reduced, :meta {:doc "Wraps x in a way such that a reduce will terminate with the value x", :arglists ([x])}, :source "(defn\n reduced\n \"Wraps x in a way such that a reduce will terminate with the value x\"\n [x]\n (Reduced. x))\n"} {:sym ITransientSet, :meta {:doc "Protocol for adding set functionality to a transient collection."}, :methods (-disjoin!)} {:sym unchecked-byte, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-byte [x] x)\n"} {:sym every-pred, :meta {:doc "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates.", :arglists [[p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]]}, :source "(defn\n every-pred\n \"Takes a set of predicates and returns a function f that returns true if all of its\\n  composing predicates return a logical true value against all of its arguments, else it returns\\n  false. Note that f is short-circuiting in that it will stop execution on the first\\n  argument that triggers a logical false result against the original predicates.\"\n ([p]\n  (fn\n   ep1\n   ([] true)\n   ([x] (boolean (p x)))\n   ([x y] (boolean (and (p x) (p y))))\n   ([x y z] (boolean (and (p x) (p y) (p z))))\n   ([x y z & args] (boolean (and (ep1 x y z) (every? p args))))))\n ([p1 p2]\n  (fn\n   ep2\n   ([] true)\n   ([x] (boolean (and (p1 x) (p2 x))))\n   ([x y] (boolean (and (p1 x) (p1 y) (p2 x) (p2 y))))\n   ([x y z] (boolean (and (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z))))\n   ([x y z & args]\n    (boolean\n     (and\n      (ep2 x y z)\n      (every?\n       (fn* [p1__18375#] (and (p1 p1__18375#) (p2 p1__18375#)))\n       args))))))\n ([p1 p2 p3]\n  (fn\n   ep3\n   ([] true)\n   ([x] (boolean (and (p1 x) (p2 x) (p3 x))))\n   ([x y] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y))))\n   ([x y z]\n    (boolean\n     (and\n      (p1 x)\n      (p2 x)\n      (p3 x)\n      (p1 y)\n      (p2 y)\n      (p3 y)\n      (p1 z)\n      (p2 z)\n      (p3 z))))\n   ([x y z & args]\n    (boolean\n     (and\n      (ep3 x y z)\n      (every?\n       (fn*\n        [p1__18376#]\n        (and (p1 p1__18376#) (p2 p1__18376#) (p3 p1__18376#)))\n       args))))))\n ([p1 p2 p3 & ps]\n  (let\n   [ps (list* p1 p2 p3 ps)]\n   (fn\n    epn\n    ([] true)\n    ([x] (every? (fn* [p1__18377#] (p1__18377# x)) ps))\n    ([x y]\n     (every?\n      (fn* [p1__18378#] (and (p1__18378# x) (p1__18378# y)))\n      ps))\n    ([x y z]\n     (every?\n      (fn*\n       [p1__18379#]\n       (and (p1__18379# x) (p1__18379# y) (p1__18379# z)))\n      ps))\n    ([x y z & args]\n     (boolean\n      (and\n       (epn x y z)\n       (every? (fn* [p1__18380#] (every? p1__18380# args)) ps))))))))\n"} {:sym missing-protocol, :meta {:doc nil, :arglists ([proto obj])}, :source "(defn\n missing-protocol\n [proto obj]\n (let\n  [ty\n   (type obj)\n   ty\n   (if\n    (and ty (.-cljs$lang$type ty))\n    (.-cljs$lang$ctorStr ty)\n    (goog/typeOf obj))]\n  (js/Error.\n   (.join\n    (array\n     \"No protocol method \"\n     proto\n     \" defined for type \"\n     ty\n     \": \"\n     obj)\n    \"\"))))\n"} {:sym load-file, :meta {:doc nil, :arglists ([file])}, :source "(defn\n load-file\n [file]\n (when-not js/COMPILED (cljs.core/load-file* file)))\n"} {:sym distinct?, :meta {:doc "Returns true if no two of the arguments are =", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n distinct?\n \"Returns true if no two of the arguments are =\"\n ([x] true)\n ([x y] (not (= x y)))\n ([x y & more]\n  (if\n   (not (= x y))\n   (loop\n    [s #{x y} xs more]\n    (let\n     [x (first xs) etc (next xs)]\n     (if xs (if (contains? s x) false (recur (conj s x) etc)) true)))\n   false)))\n"} {:sym pos-int?, :meta {:doc "Return true if x satisfies int? and is positive.", :arglists ([x])}, :source "(defn\n pos-int?\n \"Return true if x satisfies int? and is positive.\"\n [x]\n (cond\n  (integer? x)\n  (pos? x)\n  (instance? goog.math.Integer x)\n  (and (not (.isNegative x)) (not (.isZero x)))\n  (instance? goog.math.Long x)\n  (and (not (.isNegative x)) (not (.isZero x)))\n  :else\n  false))\n"} {:sym unchecked-short, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-short [x] x)\n"} {:sym odd?, :meta {:doc "Returns true if n is odd, throws an exception if n is not an integer", :arglists ([n])}, :source "(defn\n odd?\n \"Returns true if n is odd, throws an exception if n is not an integer\"\n [n]\n (not (even? n)))\n"} {:sym reduceable?, :meta {:doc "Returns true if coll satisfies IReduce", :arglists ([x])}, :source "(defn\n reduceable?\n \"Returns true if coll satisfies IReduce\"\n [x]\n (satisfies? IReduce x))\n"} {:sym string-hash-cache, :meta {}, :source "(def string-hash-cache (js-obj))\n"} {:sym inc, :meta {:doc "Returns a number one greater than num.", :arglists ([x])}, :source "(defn\n inc\n \"Returns a number one greater than num.\"\n [x]\n (cljs.core/+ x 1))\n"} {:sym type->str, :meta {:doc nil, :arglists ([ty])}, :source "(defn type->str [ty] (if-let [s (.-cljs$lang$ctorStr ty)] s (str ty)))\n"} {:sym bit-clear, :meta {:doc "Clear bit at index n", :arglists ([x n])}, :source "(defn bit-clear \"Clear bit at index n\" [x n] (cljs.core/bit-clear x n))\n"} {:sym filter, :meta {:doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :arglists [[pred] [pred coll]]}, :source "(defn\n filter\n \"Returns a lazy sequence of the items in coll for which\\n  (pred item) returns true. pred must be free of side-effects.\\n  Returns a transducer when no collection is provided.\"\n ([pred]\n  (fn\n   [rf]\n   (fn\n    ([] (rf))\n    ([result] (rf result))\n    ([result input] (if (pred input) (rf result input) result)))))\n ([pred coll]\n  (lazy-seq\n   (when-let\n    [s (seq coll)]\n    (if\n     (chunked-seq? s)\n     (let\n      [c (chunk-first s) size (count c) b (chunk-buffer size)]\n      (dotimes\n       [i size]\n       (when (pred (-nth c i)) (chunk-append b (-nth c i))))\n      (chunk-cons (chunk b) (filter pred (chunk-rest s))))\n     (let\n      [f (first s) r (rest s)]\n      (if (pred f) (cons f (filter pred r)) (filter pred r))))))))\n"} {:sym -assoc-n!, :meta {:doc "Returns tcoll with value val added at position n.", :arglists ([tcoll n val])}, :protocol ITransientVector} {:sym IWithMeta, :meta {:doc "Protocol for adding metadata to an object."}, :methods (-with-meta)} {:sym list, :meta {:doc "Creates a new list containing the items.", :arglists ([& xs])}, :source "(defn\n list\n \"Creates a new list containing the items.\"\n [& xs]\n (let\n  [arr\n   (if\n    (and (instance? IndexedSeq xs) (zero? (.-i xs)))\n    (.-arr xs)\n    (let\n     [arr (array)]\n     (loop\n      [xs xs]\n      (if-not\n       (nil? xs)\n       (do (.push arr (-first xs)) (recur (-next xs)))\n       arr))))]\n  (loop\n   [i (alength arr) r ()]\n   (if (> i 0) (recur (dec i) (-conj r (aget arr (dec i)))) r))))\n"} {:sym +, :meta {:doc "Returns the sum of nums. (+) returns 0.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n +\n \"Returns the sum of nums. (+) returns 0.\"\n ([] 0)\n ([x] x)\n ([x y] (cljs.core/+ x y))\n ([x y & more] (reduce + (cljs.core/+ x y) more)))\n"} {:sym aset, :meta {:doc "Sets the value at the index/indices. Works on JavaScript arrays.\n  Returns val.", :arglists [[array idx val] [array idx idx2 & idxv]]}, :source "(defn\n aset\n \"Sets the value at the index/indices. Works on JavaScript arrays.\\n  Returns val.\"\n ([array idx val] (cljs.core/aset array idx val))\n ([array idx idx2 & idxv] (apply aset (aget array idx) idx2 idxv)))\n"} {:sym int-rotate-left, :meta {:doc nil, :arglists ([x n])}, :source "(defn\n int-rotate-left\n [x n]\n (bit-or (bit-shift-left x n) (unsigned-bit-shift-right x (- n))))\n"} {:sym keyword, :meta {:doc "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically.", :arglists [[name] [ns name]]}, :source "(defn\n keyword\n \"Returns a Keyword with the given namespace and name.  Do not use :\\n  in the keyword strings, it will be added automatically.\"\n ([name]\n  (cond\n   (keyword? name)\n   name\n   (symbol? name)\n   (Keyword.\n    (cljs.core/namespace name)\n    (cljs.core/name name)\n    (.-str name)\n    nil)\n   (string? name)\n   (let\n    [parts (.split name \"/\")]\n    (if\n     (== (alength parts) 2)\n     (Keyword. (aget parts 0) (aget parts 1) name nil)\n     (Keyword. nil (aget parts 0) name nil)))))\n ([ns name]\n  (let\n   [ns\n    (cond\n     (keyword? ns)\n     (cljs.core/name ns)\n     (symbol? ns)\n     (cljs.core/name ns)\n     :else\n     ns)\n    name\n    (cond\n     (keyword? name)\n     (cljs.core/name name)\n     (symbol? name)\n     (cljs.core/name name)\n     :else\n     name)]\n   (Keyword. ns name (str (when ns (str ns \"/\")) name) nil))))\n"} {:sym *ns*, :meta {:doc "Var bound to the current namespace. Only used for bootstrapping."}, :source "(def *ns* nil)\n"} {:sym *assert*, :meta {}, :source "(def *assert* true)\n"} {:sym ICollection, :meta {:doc "Protocol for adding to a collection."}, :methods (-conj)} {:sym chars, :meta {:doc nil, :arglists ([x])}, :source "(defn chars [x] x)\n"} {:sym next, :meta {:doc "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil", :arglists ([coll])}, :source "(defn\n next\n \"Returns a seq of the items after the first. Calls seq on its\\n  argument.  If there are no more items, returns nil\"\n [coll]\n (when-not\n  (nil? coll)\n  (if (implements? INext coll) (-next coll) (seq (rest coll)))))\n"} {:sym ASeq, :meta {:doc "Marker protocol indicating an array sequence."}, :methods ()} {:sym IFn, :meta {:doc "Protocol for adding the ability to invoke an object as a function.\n  For example, a vector can also be used to look up a value:\n  ([1 2 3 4] 1) => 2"}, :methods (-invoke)} {:sym -reset!, :meta {:doc "Sets the value of o to new-value.", :arglists ([o new-value])}, :protocol IReset} {:sym -rest, :meta {:doc "Returns a new collection of coll without the first item. It should\n     always return a seq, e.g.\n     (rest []) => ()\n     (rest nil) => ()", :arglists ([coll])}, :protocol ISeq} {:sym nil-iter, :meta {:doc nil, :arglists ([])}, :source "(defn\n nil-iter\n []\n (reify\n  Object\n  (hasNext [_] false)\n  (next [_] (js/Error. \"No such element\"))\n  (remove [_] (js/Error. \"Unsupported operation\"))))\n"} {:sym false?, :meta {:doc "Returns true if x is the value false, false otherwise.", :arglists ([x])}, :source "(defn\n false?\n \"Returns true if x is the value false, false otherwise.\"\n [x]\n (cljs.core/false? x))\n"} {:sym *print-readably*, :meta {:doc "When set to logical false, strings and characters will be printed with\n  non-alphanumeric characters converted to the appropriate escape sequences.\n\n  Defaults to true"}, :source "(def *print-readably* true)\n"} {:sym ints, :meta {:doc nil, :arglists ([x])}, :source "(defn ints [x] x)\n"} {:sym some-fn, :meta {:doc "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates.", :arglists [[p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]]}, :source "(defn\n some-fn\n \"Takes a set of predicates and returns a function f that returns the first logical true value\\n  returned by one of its composing predicates against any of its arguments, else it returns\\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\\n  argument that triggers a logical true result against the original predicates.\"\n ([p]\n  (fn\n   sp1\n   ([] nil)\n   ([x] (p x))\n   ([x y] (or (p x) (p y)))\n   ([x y z] (or (p x) (p y) (p z)))\n   ([x y z & args] (or (sp1 x y z) (some p args)))))\n ([p1 p2]\n  (fn\n   sp2\n   ([] nil)\n   ([x] (or (p1 x) (p2 x)))\n   ([x y] (or (p1 x) (p1 y) (p2 x) (p2 y)))\n   ([x y z] (or (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z)))\n   ([x y z & args]\n    (or\n     (sp2 x y z)\n     (some\n      (fn* [p1__18381#] (or (p1 p1__18381#) (p2 p1__18381#)))\n      args)))))\n ([p1 p2 p3]\n  (fn\n   sp3\n   ([] nil)\n   ([x] (or (p1 x) (p2 x) (p3 x)))\n   ([x y] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y)))\n   ([x y z]\n    (or\n     (p1 x)\n     (p2 x)\n     (p3 x)\n     (p1 y)\n     (p2 y)\n     (p3 y)\n     (p1 z)\n     (p2 z)\n     (p3 z)))\n   ([x y z & args]\n    (or\n     (sp3 x y z)\n     (some\n      (fn*\n       [p1__18382#]\n       (or (p1 p1__18382#) (p2 p1__18382#) (p3 p1__18382#)))\n      args)))))\n ([p1 p2 p3 & ps]\n  (let\n   [ps (list* p1 p2 p3 ps)]\n   (fn\n    spn\n    ([] nil)\n    ([x] (some (fn* [p1__18383#] (p1__18383# x)) ps))\n    ([x y]\n     (some (fn* [p1__18384#] (or (p1__18384# x) (p1__18384# y))) ps))\n    ([x y z]\n     (some\n      (fn*\n       [p1__18385#]\n       (or (p1__18385# x) (p1__18385# y) (p1__18385# z)))\n      ps))\n    ([x y z & args]\n     (or\n      (spn x y z)\n      (some (fn* [p1__18386#] (some p1__18386# args)) ps)))))))\n"} {:sym *flush-on-newline*, :meta {:doc "When set to true, output will be flushed whenever a newline is printed.\n\n  Defaults to true."}, :source "(def *flush-on-newline* true)\n"} {:sym to-array, :meta {:doc "Naive impl of to-array as a start.", :arglists ([s])}, :source "(defn\n to-array\n \"Naive impl of to-array as a start.\"\n [s]\n (let\n  [ary (array)]\n  (loop\n   [s (seq s)]\n   (if-not (nil? s) (do (. ary push (first s)) (recur (next s))) ary))))\n"} {:sym list?, :meta {:doc "Returns true if x implements IList", :arglists ([x])}, :source "(defn\n list?\n \"Returns true if x implements IList\"\n [x]\n (satisfies? IList x))\n"} {:sym array?, :meta {:doc "Returns true if x is a JavaScript array.", :arglists ([x])}, :source "(defn\n array?\n \"Returns true if x is a JavaScript array.\"\n [x]\n (if\n  (identical? *target* \"nodejs\")\n  (.isArray js/Array x)\n  (instance? js/Array x)))\n"} {:sym simple-ident?, :meta {:doc "Return true if x is a symbol or keyword without a namespace", :arglists ([x])}, :source "(defn\n simple-ident?\n \"Return true if x is a symbol or keyword without a namespace\"\n [x]\n (and (ident? x) (nil? (namespace x))))\n"} {:sym clone, :meta {:doc "Clone the supplied value which must implement ICloneable.", :arglists ([value])}, :source "(defn\n clone\n \"Clone the supplied value which must implement ICloneable.\"\n [value]\n (-clone value))\n"} {:sym bit-not, :meta {:doc "Bitwise complement", :arglists ([x])}, :source "(defn bit-not \"Bitwise complement\" [x] (cljs.core/bit-not x))\n"} {:sym byte, :meta {:doc nil, :arglists ([x])}, :source "(defn byte [x] x)\n"} {:sym max, :meta {:doc "Returns the greatest of the nums.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n max\n \"Returns the greatest of the nums.\"\n ([x] x)\n ([x y] (cljs.core/max x y))\n ([x y & more] (reduce max (cljs.core/max x y) more)))\n"} {:sym IComparable, :meta {:doc "Protocol for values that can be compared."}, :methods (-compare)} {:sym ==, :meta {:doc "Returns non-nil if nums all have the equivalent\n  value, otherwise false. Behavior on non nums is\n  undefined.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n ==\n \"Returns non-nil if nums all have the equivalent\\n  value, otherwise false. Behavior on non nums is\\n  undefined.\"\n ([x] true)\n ([x y] (-equiv x y))\n ([x y & more]\n  (if\n   (== x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (== y (first more)))\n   false)))\n"} {:sym count, :meta {:doc "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Maps", :arglists ([coll])}, :source "(defn\n count\n \"Returns the number of items in the collection. (count nil) returns\\n  0.  Also works on strings, arrays, and Maps\"\n [coll]\n (if-not\n  (nil? coll)\n  (cond\n   (implements? ICounted coll)\n   (-count coll)\n   (array? coll)\n   (alength coll)\n   (string? coll)\n   (.-length coll)\n   (implements? ISeqable coll)\n   (accumulating-seq-count coll)\n   :else\n   (-count coll))\n  0))\n"} {:sym -disjoin!, :meta {:doc "Returns tcoll without v.", :arglists ([tcoll v])}, :protocol ITransientSet} {:sym *loaded-libs*, :meta {}, :source "(defonce *loaded-libs* nil)\n"} {:sym apply, :meta {:doc "Applies fn f to the argument list formed by prepending intervening arguments to args.", :arglists [[f args] [f x args] [f x y args] [f x y z args] [f a b c d & args]]}, :source "(defn\n apply\n \"Applies fn f to the argument list formed by prepending intervening arguments to args.\"\n ([f args]\n  (if\n   (.-cljs$lang$applyTo f)\n   (let\n    [fixed-arity\n     (.-cljs$lang$maxFixedArity f)\n     bc\n     (bounded-count (inc fixed-arity) args)]\n    (if\n     (<= bc fixed-arity)\n     (apply-to f bc args)\n     (.cljs$lang$applyTo f args)))\n   (apply-to-simple f (seq args))))\n ([f x args]\n  (if\n   (.-cljs$lang$applyTo f)\n   (let\n    [arglist\n     (list* x args)\n     fixed-arity\n     (.-cljs$lang$maxFixedArity f)\n     bc\n     (inc (bounded-count fixed-arity args))]\n    (if\n     (<= bc fixed-arity)\n     (apply-to f bc arglist)\n     (.cljs$lang$applyTo f arglist)))\n   (apply-to-simple f x (seq args))))\n ([f x y args]\n  (if\n   (.-cljs$lang$applyTo f)\n   (let\n    [arglist\n     (list* x y args)\n     fixed-arity\n     (.-cljs$lang$maxFixedArity f)\n     bc\n     (+ 2 (bounded-count (dec fixed-arity) args))]\n    (if\n     (<= bc fixed-arity)\n     (apply-to f bc arglist)\n     (.cljs$lang$applyTo f arglist)))\n   (apply-to-simple f x y (seq args))))\n ([f x y z args]\n  (if\n   (.-cljs$lang$applyTo f)\n   (let\n    [arglist\n     (list* x y z args)\n     fixed-arity\n     (.-cljs$lang$maxFixedArity f)\n     bc\n     (+ 3 (bounded-count (- fixed-arity 2) args))]\n    (if\n     (<= bc fixed-arity)\n     (apply-to f bc arglist)\n     (.cljs$lang$applyTo f arglist)))\n   (apply-to-simple f x y z (seq args))))\n ([f a b c d & args]\n  (if\n   (.-cljs$lang$applyTo f)\n   (let\n    [spread-args\n     (spread args)\n     arglist\n     (cons a (cons b (cons c (cons d spread-args))))\n     fixed-arity\n     (.-cljs$lang$maxFixedArity f)\n     bc\n     (+ 4 (bounded-count (- fixed-arity 3) spread-args))]\n    (if\n     (<= bc fixed-arity)\n     (apply-to f bc arglist)\n     (.cljs$lang$applyTo f arglist)))\n   (apply-to-simple f a b c d (spread args)))))\n"} {:sym add-to-string-hash-cache, :meta {:doc nil, :arglists ([k])}, :source "(defn\n add-to-string-hash-cache\n [k]\n (let\n  [h (hash-string* k)]\n  (gobject/set string-hash-cache k h)\n  (set! string-hash-cache-count (inc string-hash-cache-count))\n  h))\n"} {:sym IChunkedNext, :meta {:doc "Protocol for accessing the chunks of a collection."}, :methods (-chunked-next)} {:sym interpose, :meta {:doc "Returns a lazy seq of the elements of coll separated by sep.\n  Returns a stateful transducer when no collection is provided.", :arglists [[sep] [sep coll]]}, :source "(defn\n interpose\n \"Returns a lazy seq of the elements of coll separated by sep.\\n  Returns a stateful transducer when no collection is provided.\"\n ([sep]\n  (fn\n   [rf]\n   (let\n    [started (volatile! false)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input]\n      (if\n       @started\n       (let\n        [sepr (rf result sep)]\n        (if (reduced? sepr) sepr (rf sepr input)))\n       (do (vreset! started true) (rf result input))))))))\n ([sep coll] (drop 1 (interleave (repeat sep) coll))))\n"} {:sym deref, :meta {:doc "Also reader macro: @var/@atom/@delay. Returns the\n   most-recently-committed value of ref. When applied to a var\n   or atom, returns its current state. When applied to a delay, forces\n   it if not already forced. See also - realized?.", :arglists ([o])}, :source "(defn\n deref\n \"Also reader macro: @var/@atom/@delay. Returns the\\n   most-recently-committed value of ref. When applied to a var\\n   or atom, returns its current state. When applied to a delay, forces\\n   it if not already forced. See also - realized?.\"\n [o]\n (-deref o))\n"} {:sym assoc, :meta {:doc "assoc[iate]. When applied to a map, returns a new map of the\n   same (hashed/sorted) type, that contains the mapping of key(s) to\n   val(s). When applied to a vector, returns a new vector that\n   contains val at index.", :arglists [[coll k v] [coll k v & kvs]]}, :source "(defn\n assoc\n \"assoc[iate]. When applied to a map, returns a new map of the\\n   same (hashed/sorted) type, that contains the mapping of key(s) to\\n   val(s). When applied to a vector, returns a new vector that\\n   contains val at index.\"\n ([coll k v] (if-not (nil? coll) (-assoc coll k v) (array-map k v)))\n ([coll k v & kvs]\n  (let\n   [ret (assoc coll k v)]\n   (if kvs (recur ret (first kvs) (second kvs) (nnext kvs)) ret))))\n"} {:sym transient, :meta {:doc "Returns a new, transient version of the collection, in constant time.", :arglists ([coll])}, :source "(defn\n transient\n \"Returns a new, transient version of the collection, in constant time.\"\n [coll]\n (-as-transient coll))\n"} {:sym -disjoin, :meta {:doc "Returns a new collection of coll that does not contain v.", :arglists ([coll v])}, :protocol ISet} {:sym chunk-cons, :meta {:doc nil, :arglists ([chunk rest])}, :source "(defn\n chunk-cons\n [chunk rest]\n (if (zero? (-count chunk)) rest (ChunkedCons. chunk rest nil nil)))\n"} {:sym drop-while, :meta {:doc "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided.", :arglists [[pred] [pred coll]]}, :source "(defn\n drop-while\n \"Returns a lazy sequence of the items in coll starting from the\\n  first item for which (pred item) returns logical false.  Returns a\\n  stateful transducer when no collection is provided.\"\n ([pred]\n  (fn\n   [rf]\n   (let\n    [da (volatile! true)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input]\n      (let\n       [drop? @da]\n       (if\n        (and drop? (pred input))\n        result\n        (do (vreset! da nil) (rf result input)))))))))\n ([pred coll]\n  (let\n   [step\n    (fn\n     [pred coll]\n     (let\n      [s (seq coll)]\n      (if (and s (pred (first s))) (recur pred (rest s)) s)))]\n   (lazy-seq (step pred coll)))))\n"} {:sym IWriter, :meta {:doc "Protocol for writing. Currently only implemented by StringBufferWriter."}, :methods (-flush -write)} {:sym *print-fn*, :meta {:doc "Each runtime environment provides a different way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed."}, :source "(defonce *print-fn* nil)\n"} {:sym compare, :meta {:doc "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Uses IComparable if available and google.array.defaultCompare for objects\n of the same type and special-cases nil to be less than any other object.", :arglists ([x y])}, :source "(defn\n compare\n \"Comparator. Returns a negative number, zero, or a positive number\\n  when x is logically 'less than', 'equal to', or 'greater than'\\n  y. Uses IComparable if available and google.array.defaultCompare for objects\\n of the same type and special-cases nil to be less than any other object.\"\n [x y]\n (cond\n  (identical? x y)\n  0\n  (nil? x)\n  -1\n  (nil? y)\n  1\n  (number? x)\n  (if\n   (number? y)\n   (garray/defaultCompare x y)\n   (throw (js/Error. (str \"Cannot compare \" x \" to \" y))))\n  (satisfies? IComparable x)\n  (-compare x y)\n  :else\n  (if\n   (and\n    (or (string? x) (array? x) (true? x) (false? x))\n    (identical? (type x) (type y)))\n   (garray/defaultCompare x y)\n   (throw (js/Error. (str \"Cannot compare \" x \" to \" y))))))\n"} {:sym complement, :meta {:doc "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value.", :arglists ([f])}, :source "(defn\n complement\n \"Takes a fn f and returns a fn that takes the same arguments as f,\\n  has the same effects, if any, and returns the opposite truth value.\"\n [f]\n (fn\n  ([] (not (f)))\n  ([x] (not (f x)))\n  ([x y] (not (f x y)))\n  ([x y & zs] (not (apply f x y zs)))))\n"} {:sym -assoc!, :meta {:doc "Returns a new transient collection of tcoll with a mapping from key to\n     val added to it.", :arglists ([tcoll key val])}, :protocol ITransientAssociative} {:sym *print-dup*, :meta {:doc "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false."}, :source "(def *print-dup* false)\n"} {:sym string-iter, :meta {:doc nil, :arglists ([x])}, :source "(defn string-iter [x] (StringIter. x 0))\n"} {:sym IDeref, :meta {:doc "Protocol for adding dereference functionality to a reference."}, :methods (-deref)} {:sym sequence, :meta {:doc "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments", :arglists [[coll] [xform coll] [xform coll & colls]]}, :source "(defn\n sequence\n \"Coerces coll to a (possibly empty) sequence, if it is not already\\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\\n  transducer is supplied, returns a lazy sequence of applications of\\n  the transform to the items in coll(s), i.e. to the set of first\\n  items of each coll, followed by the set of second\\n  items in each coll, until any one of the colls is exhausted.  Any\\n  remaining items in other colls are ignored. The transform should accept\\n  number-of-colls arguments\"\n ([coll] (if (seq? coll) coll (or (seq coll) ())))\n ([xform coll]\n  (or\n   (chunkIteratorSeq (.create TransformerIterator xform (iter coll)))\n   ()))\n ([xform coll & colls]\n  (or\n   (chunkIteratorSeq\n    (.createMulti\n     TransformerIterator\n     xform\n     (map iter (cons coll colls))))\n   ())))\n"} {:sym constantly, :meta {:doc "Returns a function that takes any number of arguments and returns x.", :arglists ([x])}, :source "(defn\n constantly\n \"Returns a function that takes any number of arguments and returns x.\"\n [x]\n (fn [& args] x))\n"} {:sym chunked-seq, :meta {:doc nil, :arglists [[vec i off] [vec node i off] [vec node i off meta]]}, :source "(defn\n chunked-seq\n ([vec i off] (ChunkedSeq. vec (array-for vec i) i off nil nil))\n ([vec node i off] (ChunkedSeq. vec node i off nil nil))\n ([vec node i off meta] (ChunkedSeq. vec node i off meta nil)))\n"} {:sym ISorted, :meta {:doc "Protocol for a collection which can represent their items\n  in a sorted manner. "}, :methods (-comparator -entry-key -sorted-seq -sorted-seq-from)} {:sym make-array, :meta {:doc "Construct a JavaScript array of the specified dimensions. Accepts ignored\n  type argument for compatibility with Clojure. Note that there is no efficient\n  way to allocate multi-dimensional arrays in JavaScript; as such, this function\n  will run in polynomial time when called with 3 or more arguments.", :arglists [[size] [type size] [type size & more-sizes]]}, :source "(defn\n make-array\n \"Construct a JavaScript array of the specified dimensions. Accepts ignored\\n  type argument for compatibility with Clojure. Note that there is no efficient\\n  way to allocate multi-dimensional arrays in JavaScript; as such, this function\\n  will run in polynomial time when called with 3 or more arguments.\"\n ([size] (js/Array. size))\n ([type size] (make-array size))\n ([type size & more-sizes]\n  (let\n   [dims more-sizes dimarray (make-array size)]\n   (dotimes\n    [i (alength dimarray)]\n    (aset dimarray i (apply make-array nil dims)))\n   dimarray)))\n"} {:sym shorts, :meta {:doc nil, :arglists ([x])}, :source "(defn shorts [x] x)\n"} {:sym *unchecked-if*, :meta {}, :source "(def *unchecked-if* false)\n"} {:sym enable-console-print!, :meta {:doc "Set *print-fn* to console.log", :arglists ([])}, :source "(defn\n enable-console-print!\n \"Set *print-fn* to console.log\"\n []\n (set! *print-newline* false)\n (set!\n  *print-fn*\n  (fn\n   [& args]\n   (.apply (.-log js/console) js/console (into-array args))))\n (set!\n  *print-err-fn*\n  (fn\n   [& args]\n   (.apply (.-error js/console) js/console (into-array args))))\n nil)\n"} {:sym -flush, :meta {:doc "Flush writer.", :arglists ([writer])}, :protocol IWriter} {:sym completing, :meta {:doc "Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument.", :arglists [[f] [f cf]]}, :source "(defn\n completing\n \"Takes a reducing function f of 2 args and returns a fn suitable for\\n  transduce by adding an arity-1 signature that calls cf (default -\\n  identity) on the result argument.\"\n ([f] (completing f identity))\n ([f cf] (fn ([] (f)) ([x] (cf x)) ([x y] (f x y)))))\n"} {:sym unchecked-negate-int, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-negate-int [x] (cljs.core/unchecked-negate-int x))\n"} {:sym hash-unordered-coll, :meta {:doc "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://clojure.org/data_structures#hash for full algorithms.", :arglists ([coll])}, :source "(defn\n hash-unordered-coll\n \"Returns the hash code, consistent with =, for an external unordered\\n   collection implementing Iterable. For maps, the iterator should\\n   return map entries whose hash is computed as\\n     (hash-ordered-coll [k v]).\\n   See http://clojure.org/data_structures#hash for full algorithms.\"\n [coll]\n (loop\n  [n 0 hash-code 0 coll (seq coll)]\n  (if-not\n   (nil? coll)\n   (recur\n    (inc n)\n    (bit-or (+ hash-code (hash (first coll))) 0)\n    (next coll))\n   (mix-collection-hash hash-code n))))\n"} {:sym repeat, :meta {:doc "Returns a lazy (infinite!, or length n if supplied) sequence of xs.", :arglists [[x] [n x]]}, :source "(defn\n repeat\n \"Returns a lazy (infinite!, or length n if supplied) sequence of xs.\"\n ([x] (lazy-seq (cons x (repeat x))))\n ([n x] (take n (repeat x))))\n"} {:sym unchecked-inc, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-inc [x] (cljs.core/unchecked-inc x))\n"} {:sym nthnext, :meta {:doc "Returns the nth next of coll, (seq coll) when n is 0.", :arglists ([coll n])}, :source "(defn\n nthnext\n \"Returns the nth next of coll, (seq coll) when n is 0.\"\n [coll n]\n (loop\n  [n n xs (seq coll)]\n  (if (and xs (pos? n)) (recur (dec n) (next xs)) xs)))\n"} {:sym get-validator, :meta {:doc "Gets the validator-fn for a var/ref/agent/atom.", :arglists ([iref])}, :source "(defn\n get-validator\n \"Gets the validator-fn for a var/ref/agent/atom.\"\n [iref]\n (.-validator iref))\n"} {:sym number?, :meta {:doc "Returns true if x is a JavaScript number.", :arglists ([x])}, :source "(defn\n number?\n \"Returns true if x is a JavaScript number.\"\n [x]\n (cljs.core/number? x))\n"} {:sym -conj!, :meta {:doc "Adds value val to tcoll and returns tcoll.", :arglists ([tcoll val])}, :protocol ITransientCollection} {:sym chunk-next, :meta {:doc nil, :arglists ([s])}, :source "(defn\n chunk-next\n [s]\n (if\n  (implements? IChunkedNext s)\n  (-chunked-next s)\n  (seq (-chunked-rest s))))\n"} {:sym not-any?, :meta {:doc "Returns false if (pred x) is logical true for any x in coll,\n  else true.", :arglists ([pred coll])}, :source "(defn\n not-any?\n \"Returns false if (pred x) is logical true for any x in coll,\\n  else true.\"\n [pred coll]\n (not (some pred coll)))\n"} {:sym into-array, :meta {:doc "Returns an array with components set to the values in aseq. Optional type\n  argument accepted for compatibility with Clojure.", :arglists [[aseq] [type aseq]]}, :source "(defn\n into-array\n \"Returns an array with components set to the values in aseq. Optional type\\n  argument accepted for compatibility with Clojure.\"\n ([aseq] (into-array nil aseq))\n ([type aseq] (reduce (fn [a x] (.push a x) a) (array) aseq)))\n"} {:sym -hash, :meta {:doc "Returns the hash code of o.", :arglists ([o])}, :protocol IHash} {:sym qualified-symbol?, :meta {:doc "Return true if x is a symbol with a namespace", :arglists ([x])}, :source "(defn\n qualified-symbol?\n \"Return true if x is a symbol with a namespace\"\n [x]\n (boolean (and (symbol? x) (namespace x) true)))\n"} {:sym -dissoc!, :meta {:doc "Returns a new transient collection of tcoll without the mapping for key.", :arglists ([tcoll key])}, :protocol ITransientMap} {:sym chunk-buffer, :meta {:doc nil, :arglists ([capacity])}, :source "(defn chunk-buffer [capacity] (ChunkBuffer. (make-array capacity) 0))\n"} {:sym seqable?, :meta {:doc "Return true if the seq function is supported for s", :arglists ([s])}, :source "(defn\n seqable?\n \"Return true if the seq function is supported for s\"\n [s]\n (or (satisfies? ISeqable s) (array? s) (string? s)))\n"} {:sym symbol?, :meta {:doc "Return true if x is a Symbol", :arglists ([x])}, :source "(defn symbol? \"Return true if x is a Symbol\" [x] (instance? Symbol x))\n"} {:sym m3-hash-unencoded-chars, :meta {:doc nil, :arglists ([in])}, :source "(defn\n m3-hash-unencoded-chars\n [in]\n (let\n  [h1\n   (loop\n    [i 1 h1 m3-seed]\n    (if\n     (< i (.-length in))\n     (recur\n      (+ i 2)\n      (m3-mix-H1\n       h1\n       (m3-mix-K1\n        (bit-or\n         (.charCodeAt in (dec i))\n         (bit-shift-left (.charCodeAt in i) 16)))))\n     h1))\n   h1\n   (if\n    (== (bit-and (.-length in) 1) 1)\n    (bit-xor h1 (m3-mix-K1 (.charCodeAt in (dec (.-length in)))))\n    h1)]\n  (m3-fmix h1 (imul 2 (.-length in)))))\n"} {:sym unchecked-char, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-char [x] x)\n"} {:sym system-time, :meta {:doc "Returns highest resolution time offered by host in milliseconds.", :arglists ([])}, :source "(defn\n system-time\n \"Returns highest resolution time offered by host in milliseconds.\"\n []\n (cond\n  (and (exists? js/performance) (not (nil? (. js/performance -now))))\n  (.now js/performance)\n  (and (exists? js/process) (not (nil? (. js/process -hrtime))))\n  (let\n   [t (.hrtime js/process)]\n   (/ (+ (* (aget t 0) 1.0E9) (aget t 1)) 1000000.0))\n  :else\n  (.getTime (js/Date.))))\n"} {:sym -invoke, :meta {:doc nil, :arglists ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest])}, :protocol IFn} {:sym coll?, :meta {:doc "Returns true if x satisfies ICollection", :arglists ([x])}, :source "(defn\n coll?\n \"Returns true if x satisfies ICollection\"\n [x]\n (if (nil? x) false (satisfies? ICollection x)))\n"} {:sym get-in, :meta {:doc "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key is not present,\n  or the not-found value if supplied.", :arglists [[m ks] [m ks not-found]]}, :source "(defn\n get-in\n \"Returns the value in a nested associative structure,\\n  where ks is a sequence of keys. Returns nil if the key is not present,\\n  or the not-found value if supplied.\"\n {:added \"1.2\", :static true}\n ([m ks] (reduce get m ks))\n ([m ks not-found]\n  (loop\n   [sentinel lookup-sentinel m m ks (seq ks)]\n   (if-not\n    (nil? ks)\n    (let\n     [m (get m (first ks) sentinel)]\n     (if\n      (identical? sentinel m)\n      not-found\n      (recur sentinel m (next ks))))\n    m))))\n"} {:sym fnext, :meta {:doc "Same as (first (next x))", :arglists ([coll])}, :source "(defn fnext \"Same as (first (next x))\" [coll] (first (next coll)))\n"} {:sym IList, :meta {:doc "Marker interface indicating a persistent list"}, :methods ()} {:sym -val, :meta {:doc "Returns the value of the map entry.", :arglists ([coll])}, :protocol IMapEntry} {:sym bytes, :meta {:doc nil, :arglists ([x])}, :source "(defn bytes [x] x)\n"} {:sym -seq, :meta {:doc "Returns a seq of o, or nil if o is empty.", :arglists ([o])}, :protocol ISeqable}), cljs.tools.reader.reader-types ({:sym indexing-push-back-reader, :meta {:doc "Creates an IndexingPushbackReader from a given string or PushbackReader", :arglists [[s-or-rdr] [s-or-rdr buf-len] [s-or-rdr buf-len file-name]]}, :source "(defn\n indexing-push-back-reader\n \"Creates an IndexingPushbackReader from a given string or PushbackReader\"\n ([s-or-rdr] (indexing-push-back-reader s-or-rdr 1))\n ([s-or-rdr buf-len] (indexing-push-back-reader s-or-rdr buf-len nil))\n ([s-or-rdr buf-len file-name]\n  (IndexingPushbackReader.\n   (if\n    (string? s-or-rdr)\n    (string-push-back-reader s-or-rdr buf-len)\n    s-or-rdr)\n   1\n   1\n   true\n   nil\n   0\n   file-name)))\n"} {:sym log-source*, :meta {:doc nil, :arglists ([reader f])}, :source "(defn\n log-source*\n [reader f]\n (let\n  [buffer (:buffer @(.-frames reader))]\n  (try\n   (swap!\n    (.-frames reader)\n    update-in\n    [:offset]\n    conj\n    (.getLength buffer))\n   (let\n    [ret (f)]\n    (if\n     (implements? IMeta ret)\n     (merge-meta ret {:source (peek-source-log @(.-frames reader))})\n     ret))\n   (finally (swap! (.-frames reader) update-in [:offset] rest)))))\n"} {:sym merge-meta, :meta {:doc "Returns an object of the same type and value as `obj`, with its\nmetadata merged over `m`.", :arglists ([obj m])}, :source "(defn\n merge-meta\n \"Returns an object of the same type and value as `obj`, with its\\nmetadata merged over `m`.\"\n [obj m]\n (let\n  [orig-meta (meta obj)]\n  (with-meta obj (merge m (dissoc orig-meta :source)))))\n"} {:sym Reader, :meta {:doc nil}, :methods (peek-char read-char)} {:sym source-logging-push-back-reader, :meta {:doc "Creates a SourceLoggingPushbackReader from a given string or PushbackReader", :arglists [[s-or-rdr] [s-or-rdr buf-len] [s-or-rdr buf-len file-name]]}, :source "(defn\n source-logging-push-back-reader\n \"Creates a SourceLoggingPushbackReader from a given string or PushbackReader\"\n ([s-or-rdr] (source-logging-push-back-reader s-or-rdr 1))\n ([s-or-rdr buf-len]\n  (source-logging-push-back-reader s-or-rdr buf-len nil))\n ([s-or-rdr buf-len file-name]\n  (SourceLoggingPushbackReader.\n   (if\n    (string? s-or-rdr)\n    (string-push-back-reader s-or-rdr buf-len)\n    s-or-rdr)\n   1\n   1\n   true\n   nil\n   0\n   file-name\n   (atom {:buffer (StringBuffer.), :offset '(0)}))))\n"} {:sym unread, :meta {:doc "Pushes back a single character on to the stream", :arglists ([reader ch])}, :protocol IPushbackReader} {:sym peek-char, :meta {:doc "Returns the next char from the Reader without removing it from the reader stream", :arglists ([reader])}, :protocol Reader} {:sym IPushbackReader, :meta {:doc nil}, :methods (unread)} {:sym indexing-reader?, :meta {:doc "Returns true if the reader satisfies IndexingReader", :arglists ([rdr])}, :source "(defn\n indexing-reader?\n \"Returns true if the reader satisfies IndexingReader\"\n [rdr]\n (implements? IndexingReader rdr))\n"} {:sym string-reader, :meta {:doc "Creates a StringReader from a given string", :arglists [[s]]}, :source "(defn\n string-reader\n \"Creates a StringReader from a given string\"\n ([s] (StringReader. s (count s) 0)))\n"} {:sym read-char, :meta {:doc "Returns the next char from the Reader, nil if the end of stream has been reached", :arglists ([reader])}, :protocol Reader} {:sym get-column-number, :meta {:doc "Returns the column number of the next character to be read from the stream", :arglists ([reader])}, :protocol IndexingReader} {:sym get-file-name, :meta {:doc "Returns the file name the reader is reading from, or nil", :arglists ([reader])}, :protocol IndexingReader} {:sym read-line, :meta {:doc "Reads a line from the reader or from *in* if no reader is specified", :arglists [[rdr]]}, :source "(defn\n read-line\n \"Reads a line from the reader or from *in* if no reader is specified\"\n ([rdr]\n  (loop\n   [c (read-char rdr) s (StringBuffer.)]\n   (if (newline? c) (str s) (recur (read-char rdr) (.append s c))))))\n"} {:sym string-push-back-reader, :meta {:doc "Creates a PushbackReader from a given string", :arglists [[s] [s buf-len]]}, :source "(defn\n string-push-back-reader\n \"Creates a PushbackReader from a given string\"\n ([s] (string-push-back-reader s 1))\n ([s buf-len]\n  (PushbackReader.\n   (string-reader s)\n   (object-array buf-len)\n   buf-len\n   buf-len)))\n"} {:sym line-start?, :meta {:doc "Returns true if rdr is an IndexingReader and the current char starts a new line", :arglists ([rdr])}, :source "(defn\n line-start?\n \"Returns true if rdr is an IndexingReader and the current char starts a new line\"\n [rdr]\n (when (indexing-reader? rdr) (== 1 (get-column-number rdr))))\n"} {:sym source-logging-reader?, :meta {:doc nil, :arglists ([rdr])}, :source "(defn\n source-logging-reader?\n [rdr]\n (instance? SourceLoggingPushbackReader rdr))\n"} {:sym IndexingReader, :meta {:doc nil}, :methods (get-column-number get-file-name get-line-number)} {:sym node-readable-push-back-reader, :meta {:doc nil, :arglists ([readable])}, :source "(defn\n node-readable-push-back-reader\n [readable]\n (PushbackReader.\n  (NodeReadableReader. readable nil)\n  (object-array 1)\n  1\n  1))\n"} {:sym get-line-number, :meta {:doc "Returns the line number of the next character to be read from the stream", :arglists ([reader])}, :protocol IndexingReader}), cljs.core.async ({:sym Pub, :meta {:doc nil}, :methods (sub* unsub* unsub-all*)} {:sym reduce, :meta {:doc "f should be a function of 2 arguments. Returns a channel containing\n  the single result of applying f to init and the first item from the\n  channel, then applying f to that result and the 2nd item, etc. If\n  the channel closes without yielding items, returns init and f is not\n  called. ch must close before reduce produces a result.", :arglists ([f init ch])}, :source "(defn\n reduce\n \"f should be a function of 2 arguments. Returns a channel containing\\n  the single result of applying f to init and the first item from the\\n  channel, then applying f to that result and the 2nd item, etc. If\\n  the channel closes without yielding items, returns init and f is not\\n  called. ch must close before reduce produces a result.\"\n [f init ch]\n (go-loop\n  [ret init]\n  (let\n   [v (<! ch)]\n   (if\n    (nil? v)\n    ret\n    (let [ret' (f ret v)] (if (reduced? ret') @ret' (recur ret')))))))\n"} {:sym remove>, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists ([p ch])}, :source "(defn\n remove>\n \"Deprecated - this function will be removed. Use transducer instead\"\n [p ch]\n (filter> (complement p) ch))\n"} {:sym timeout, :meta {:doc "Returns a channel that will close after msecs", :arglists ([msecs])}, :source "(defn\n timeout\n \"Returns a channel that will close after msecs\"\n [msecs]\n (timers/timeout msecs))\n"} {:sym unsub*, :meta {:doc nil, :arglists ([p v ch])}, :protocol Pub} {:sym admix*, :meta {:doc nil, :arglists ([m ch])}, :protocol Mix} {:sym unmix*, :meta {:doc nil, :arglists ([m ch])}, :protocol Mix} {:sym mix, :meta {:doc "Creates and returns a mix of one or more input channels which will\n  be put on the supplied out channel. Input sources can be added to\n  the mix with 'admix', and removed with 'unmix'. A mix supports\n  soloing, muting and pausing multiple inputs atomically using\n  'toggle', and can solo using either muting or pausing as determined\n  by 'solo-mode'.\n\n  Each channel can have zero or more boolean modes set via 'toggle':\n\n  :solo - when true, only this (ond other soloed) channel(s) will appear\n          in the mix output channel. :mute and :pause states of soloed\n          channels are ignored. If solo-mode is :mute, non-soloed\n          channels are muted, if :pause, non-soloed channels are\n          paused.\n\n  :mute - muted channels will have their contents consumed but not included in the mix\n  :pause - paused channels will not have their contents consumed (and thus also not included in the mix)\n", :arglists ([out])}, :source "(defn\n mix\n \"Creates and returns a mix of one or more input channels which will\\n  be put on the supplied out channel. Input sources can be added to\\n  the mix with 'admix', and removed with 'unmix'. A mix supports\\n  soloing, muting and pausing multiple inputs atomically using\\n  'toggle', and can solo using either muting or pausing as determined\\n  by 'solo-mode'.\\n\\n  Each channel can have zero or more boolean modes set via 'toggle':\\n\\n  :solo - when true, only this (ond other soloed) channel(s) will appear\\n          in the mix output channel. :mute and :pause states of soloed\\n          channels are ignored. If solo-mode is :mute, non-soloed\\n          channels are muted, if :pause, non-soloed channels are\\n          paused.\\n\\n  :mute - muted channels will have their contents consumed but not included in the mix\\n  :pause - paused channels will not have their contents consumed (and thus also not included in the mix)\\n\"\n [out]\n (let\n  [cs\n   (atom {})\n   solo-modes\n   #{:pause :mute}\n   attrs\n   (conj solo-modes :solo)\n   solo-mode\n   (atom :mute)\n   change\n   (chan)\n   changed\n   (fn* [] (put! change true))\n   pick\n   (fn\n    [attr chs]\n    (reduce-kv (fn [ret c v] (if (attr v) (conj ret c) ret)) #{} chs))\n   calc-state\n   (fn\n    []\n    (let\n     [chs\n      @cs\n      mode\n      @solo-mode\n      solos\n      (pick :solo chs)\n      pauses\n      (pick :pause chs)]\n     {:solos solos,\n      :mutes (pick :mute chs),\n      :reads\n      (conj\n       (if\n        (and (= mode :pause) (not (empty? solos)))\n        (vec solos)\n        (vec (remove pauses (keys chs))))\n       change)}))\n   m\n   (reify\n    Mux\n    (muxch* [_] out)\n    Mix\n    (admix* [_ ch] (swap! cs assoc ch {}) (changed))\n    (unmix* [_ ch] (swap! cs dissoc ch) (changed))\n    (unmix-all* [_] (reset! cs {}) (changed))\n    (toggle*\n     [_ state-map]\n     (swap! cs (partial merge-with cljs.core/merge) state-map)\n     (changed))\n    (solo-mode*\n     [_ mode]\n     (assert\n      (solo-modes mode)\n      (str \"mode must be one of: \" solo-modes))\n     (reset! solo-mode mode)\n     (changed)))]\n  (go-loop\n   [{:keys [solos mutes reads], :as state} (calc-state)]\n   (let\n    [[v c] (alts! reads)]\n    (if\n     (or (nil? v) (= c change))\n     (do (when (nil? v) (swap! cs dissoc c)) (recur (calc-state)))\n     (if\n      (or (solos c) (and (empty? solos) (not (mutes c))))\n      (when (>! out v) (recur state))\n      (recur state)))))\n  m))\n"} {:sym pub, :meta {:doc "Creates and returns a pub(lication) of the supplied channel,\n  partitioned into topics by the topic-fn. topic-fn will be applied to\n  each value on the channel and the result will determine the 'topic'\n  on which that value will be put. Channels can be subscribed to\n  receive copies of topics using 'sub', and unsubscribed using\n  'unsub'. Each topic will be handled by an internal mult on a\n  dedicated channel. By default these internal channels are\n  unbuffered, but a buf-fn can be supplied which, given a topic,\n  creates a buffer with desired properties.\n\n  Each item is distributed to all subs in parallel and synchronously,\n  i.e. each sub must accept before the next item is distributed. Use\n  buffering/windowing to prevent slow subs from holding up the pub.\n\n  Items received when there are no matching subs get dropped.\n\n  Note that if buf-fns are used then each topic is handled\n  asynchronously, i.e. if a channel is subscribed to more than one\n  topic it should not expect them to be interleaved identically with\n  the source.", :arglists [[ch topic-fn] [ch topic-fn buf-fn]]}, :source "(defn\n pub\n \"Creates and returns a pub(lication) of the supplied channel,\\n  partitioned into topics by the topic-fn. topic-fn will be applied to\\n  each value on the channel and the result will determine the 'topic'\\n  on which that value will be put. Channels can be subscribed to\\n  receive copies of topics using 'sub', and unsubscribed using\\n  'unsub'. Each topic will be handled by an internal mult on a\\n  dedicated channel. By default these internal channels are\\n  unbuffered, but a buf-fn can be supplied which, given a topic,\\n  creates a buffer with desired properties.\\n\\n  Each item is distributed to all subs in parallel and synchronously,\\n  i.e. each sub must accept before the next item is distributed. Use\\n  buffering/windowing to prevent slow subs from holding up the pub.\\n\\n  Items received when there are no matching subs get dropped.\\n\\n  Note that if buf-fns are used then each topic is handled\\n  asynchronously, i.e. if a channel is subscribed to more than one\\n  topic it should not expect them to be interleaved identically with\\n  the source.\"\n ([ch topic-fn] (pub ch topic-fn (constantly nil)))\n ([ch topic-fn buf-fn]\n  (let\n   [mults\n    (atom {})\n    ensure-mult\n    (fn\n     [topic]\n     (or\n      (get @mults topic)\n      (get\n       (swap!\n        mults\n        (fn*\n         [p1__18372#]\n         (if\n          (p1__18372# topic)\n          p1__18372#\n          (assoc p1__18372# topic (mult (chan (buf-fn topic)))))))\n       topic)))\n    p\n    (reify\n     Mux\n     (muxch* [_] ch)\n     Pub\n     (sub*\n      [p topic ch close?]\n      (let [m (ensure-mult topic)] (tap m ch close?)))\n     (unsub*\n      [p topic ch]\n      (when-let [m (get @mults topic)] (untap m ch)))\n     (unsub-all* [_] (reset! mults {}))\n     (unsub-all* [_ topic] (swap! mults dissoc topic)))]\n   (go-loop\n    []\n    (let\n     [val (<! ch)]\n     (if\n      (nil? val)\n      (doseq [m (vals @mults)] (close! (muxch* m)))\n      (let\n       [topic (topic-fn val) m (get @mults topic)]\n       (when\n        m\n        (when-not (>! (muxch* m) val) (swap! mults dissoc topic)))\n       (recur)))))\n   p)))\n"} {:sym take, :meta {:doc "Returns a channel that will return, at most, n items from ch. After n items\n   have been returned, or ch has been closed, the return chanel will close.\n\n  The output channel is unbuffered by default, unless buf-or-n is given.", :arglists [[n ch] [n ch buf-or-n]]}, :source "(defn\n take\n \"Returns a channel that will return, at most, n items from ch. After n items\\n   have been returned, or ch has been closed, the return chanel will close.\\n\\n  The output channel is unbuffered by default, unless buf-or-n is given.\"\n ([n ch] (take n ch nil))\n ([n ch buf-or-n]\n  (let\n   [out (chan buf-or-n)]\n   (go\n    (loop\n     [x 0]\n     (when\n      (< x n)\n      (let\n       [v (<! ch)]\n       (when (not (nil? v)) (>! out v) (recur (inc x))))))\n    (close! out))\n   out)))\n"} {:sym unsub-all*, :meta {:doc nil, :arglists ([p] [p v])}, :protocol Pub} {:sym <!, :meta {:doc "takes a val from port. Must be called inside a (go ...) block. Will\n  return nil if closed. Will park if nothing is available.\n  Returns true unless port is already closed", :arglists ([port])}, :source "(defn\n <!\n \"takes a val from port. Must be called inside a (go ...) block. Will\\n  return nil if closed. Will park if nothing is available.\\n  Returns true unless port is already closed\"\n [port]\n (throw (js/Error. \"<! used not in (go ...) block\")))\n"} {:sym map, :meta {:doc "Takes a function and a collection of source channels, and returns a\n  channel which contains the values produced by applying f to the set\n  of first items taken from each source channel, followed by applying\n  f to the set of second items from each channel, until any one of the\n  channels is closed, at which point the output channel will be\n  closed. The returned channel will be unbuffered by default, or a\n  buf-or-n can be supplied", :arglists [[f chs] [f chs buf-or-n]]}, :source "(defn\n map\n \"Takes a function and a collection of source channels, and returns a\\n  channel which contains the values produced by applying f to the set\\n  of first items taken from each source channel, followed by applying\\n  f to the set of second items from each channel, until any one of the\\n  channels is closed, at which point the output channel will be\\n  closed. The returned channel will be unbuffered by default, or a\\n  buf-or-n can be supplied\"\n ([f chs] (map f chs nil))\n ([f chs buf-or-n]\n  (let\n   [chs\n    (vec chs)\n    out\n    (chan buf-or-n)\n    cnt\n    (count chs)\n    rets\n    (object-array cnt)\n    dchan\n    (chan 1)\n    dctr\n    (atom nil)\n    done\n    (mapv\n     (fn\n      [i]\n      (fn\n       [ret]\n       (aset rets i ret)\n       (when (zero? (swap! dctr dec)) (put! dchan (.slice rets 0)))))\n     (range cnt))]\n   (go-loop\n    []\n    (reset! dctr cnt)\n    (dotimes\n     [i cnt]\n     (try\n      (take! (chs i) (done i))\n      (catch js/Object e (swap! dctr dec))))\n    (let\n     [rets (<! dchan)]\n     (if\n      (some nil? rets)\n      (close! out)\n      (do (>! out (apply f rets)) (recur)))))\n   out)))\n"} {:sym Mux, :meta {:doc nil}, :methods (muxch*)} {:sym mapcat>, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists [[f out] [f out buf-or-n]]}, :source "(defn\n mapcat>\n \"Deprecated - this function will be removed. Use transducer instead\"\n ([f out] (mapcat> f out nil))\n ([f out buf-or-n] (let [in (chan buf-or-n)] (mapcat* f in out) in)))\n"} {:sym buffer, :meta {:doc "Returns a fixed buffer of size n. When full, puts will block/park.", :arglists ([n])}, :source "(defn\n buffer\n \"Returns a fixed buffer of size n. When full, puts will block/park.\"\n [n]\n (buffers/fixed-buffer n))\n"} {:sym close!, :meta {:doc nil, :arglists [[port]]}, :source "(defn close! ([port] (impl/close! port)))\n"} {:sym offer!, :meta {:doc "Puts a val into port if it's possible to do so immediately.\n  nil values are not allowed. Never blocks. Returns true if offer succeeds.", :arglists ([port val])}, :source "(defn\n offer!\n \"Puts a val into port if it's possible to do so immediately.\\n  nil values are not allowed. Never blocks. Returns true if offer succeeds.\"\n [port val]\n (let\n  [ret (impl/put! port val (fn-handler nop false))]\n  (when ret @ret)))\n"} {:sym chan, :meta {:doc "Creates a channel with an optional buffer, an optional transducer (like (map f),\n  (filter p) etc or a composition thereof), and an optional exception handler.\n  If buf-or-n is a number, will create and use a fixed buffer of that size. If a\n  transducer is supplied a buffer must be specified. ex-handler must be a\n  fn of one argument - if an exception occurs during transformation it will be called\n  with the thrown value as an argument, and any non-nil return value will be placed\n  in the channel.", :arglists [[] [buf-or-n] [buf-or-n xform] [buf-or-n xform ex-handler]]}, :source "(defn\n chan\n \"Creates a channel with an optional buffer, an optional transducer (like (map f),\\n  (filter p) etc or a composition thereof), and an optional exception handler.\\n  If buf-or-n is a number, will create and use a fixed buffer of that size. If a\\n  transducer is supplied a buffer must be specified. ex-handler must be a\\n  fn of one argument - if an exception occurs during transformation it will be called\\n  with the thrown value as an argument, and any non-nil return value will be placed\\n  in the channel.\"\n ([] (chan nil))\n ([buf-or-n] (chan buf-or-n nil nil))\n ([buf-or-n xform] (chan buf-or-n xform nil))\n ([buf-or-n xform ex-handler]\n  (let\n   [buf-or-n (if (= buf-or-n 0) nil buf-or-n)]\n   (when\n    xform\n    (assert buf-or-n \"buffer must be supplied when transducer is\"))\n   (channels/chan\n    (if (number? buf-or-n) (buffer buf-or-n) buf-or-n)\n    xform\n    ex-handler))))\n"} {:sym solo-mode*, :meta {:doc nil, :arglists ([m mode])}, :protocol Mix} {:sym tap, :meta {:doc "Copies the mult source onto the supplied channel.\n\n  By default the channel will be closed when the source closes,\n  but can be determined by the close? parameter.", :arglists [[mult ch] [mult ch close?]]}, :source "(defn\n tap\n \"Copies the mult source onto the supplied channel.\\n\\n  By default the channel will be closed when the source closes,\\n  but can be determined by the close? parameter.\"\n ([mult ch] (tap mult ch true))\n ([mult ch close?] (tap* mult ch close?) ch))\n"} {:sym admix, :meta {:doc "Adds ch as an input to the mix", :arglists ([mix ch])}, :source "(defn admix \"Adds ch as an input to the mix\" [mix ch] (admix* mix ch))\n"} {:sym promise-chan, :meta {:doc "Creates a promise channel with an optional transducer, and an optional\n  exception-handler. A promise channel can take exactly one value that consumers\n  will receive. Once full, puts complete but val is dropped (no transfer).\n  Consumers will block until either a value is placed in the channel or the\n  channel is closed. See chan for the semantics of xform and ex-handler.", :arglists [[] [xform] [xform ex-handler]]}, :source "(defn\n promise-chan\n \"Creates a promise channel with an optional transducer, and an optional\\n  exception-handler. A promise channel can take exactly one value that consumers\\n  will receive. Once full, puts complete but val is dropped (no transfer).\\n  Consumers will block until either a value is placed in the channel or the\\n  channel is closed. See chan for the semantics of xform and ex-handler.\"\n ([] (promise-chan nil))\n ([xform] (promise-chan xform nil))\n ([xform ex-handler] (chan (buffers/promise-buffer) xform ex-handler)))\n"} {:sym unique, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists [[ch] [ch buf-or-n]]}, :source "(defn\n unique\n \"Deprecated - this function will be removed. Use transducer instead\"\n ([ch] (unique ch nil))\n ([ch buf-or-n]\n  (let\n   [out (chan buf-or-n)]\n   (go\n    (loop\n     [last nil]\n     (let\n      [v (<! ch)]\n      (when\n       (not (nil? v))\n       (if (= v last) (recur last) (do (>! out v) (recur v))))))\n    (close! out))\n   out)))\n"} {:sym muxch*, :meta {:doc nil, :arglists ([_])}, :protocol Mux} {:sym solo-mode, :meta {:doc "Sets the solo mode of the mix. mode must be one of :mute or :pause", :arglists ([mix mode])}, :source "(defn\n solo-mode\n \"Sets the solo mode of the mix. mode must be one of :mute or :pause\"\n [mix mode]\n (solo-mode* mix mode))\n"} {:sym transduce, :meta {:doc "async/reduces a channel with a transformation (xform f).\n  Returns a channel containing the result.  ch must close before\n  transduce produces a result.", :arglists ([xform f init ch])}, :source "(defn\n transduce\n \"async/reduces a channel with a transformation (xform f).\\n  Returns a channel containing the result.  ch must close before\\n  transduce produces a result.\"\n [xform f init ch]\n (let [f (xform f)] (go (let [ret (<! (reduce f init ch))] (f ret)))))\n"} {:sym onto-chan, :meta {:doc "Puts the contents of coll into the supplied channel.\n\n  By default the channel will be closed after the items are copied,\n  but can be determined by the close? parameter.\n\n  Returns a channel which will close after the items are copied.", :arglists [[ch coll] [ch coll close?]]}, :source "(defn\n onto-chan\n \"Puts the contents of coll into the supplied channel.\\n\\n  By default the channel will be closed after the items are copied,\\n  but can be determined by the close? parameter.\\n\\n  Returns a channel which will close after the items are copied.\"\n ([ch coll] (onto-chan ch coll true))\n ([ch coll close?]\n  (go-loop\n   [vs (seq coll)]\n   (if\n    (and vs (>! ch (first vs)))\n    (recur (next vs))\n    (when close? (close! ch))))))\n"} {:sym to-chan, :meta {:doc "Creates and returns a channel which contains the contents of coll,\n  closing when exhausted.", :arglists ([coll])}, :source "(defn\n to-chan\n \"Creates and returns a channel which contains the contents of coll,\\n  closing when exhausted.\"\n [coll]\n (let [ch (chan (bounded-count 100 coll))] (onto-chan ch coll) ch))\n"} {:sym dropping-buffer, :meta {:doc "Returns a buffer of size n. When full, puts will complete but\n  val will be dropped (no transfer).", :arglists ([n])}, :source "(defn\n dropping-buffer\n \"Returns a buffer of size n. When full, puts will complete but\\n  val will be dropped (no transfer).\"\n [n]\n (buffers/dropping-buffer n))\n"} {:sym untap-all, :meta {:doc "Disconnects all target channels from a mult", :arglists ([mult])}, :source "(defn\n untap-all\n \"Disconnects all target channels from a mult\"\n [mult]\n (untap-all* mult))\n"} {:sym into, :meta {:doc "Returns a channel containing the single (collection) result of the\n  items taken from the channel conjoined to the supplied\n  collection. ch must close before into produces a result.", :arglists ([coll ch])}, :source "(defn\n into\n \"Returns a channel containing the single (collection) result of the\\n  items taken from the channel conjoined to the supplied\\n  collection. ch must close before into produces a result.\"\n [coll ch]\n (reduce conj coll ch))\n"} {:sym pipeline, :meta {:doc "Takes elements from the from channel and supplies them to the to\n  channel, subject to the transducer xf, with parallelism n. Because\n  it is parallel, the transducer will be applied independently to each\n  element, not across elements, and may produce zero or more outputs\n  per input.  Outputs will be returned in order relative to the\n  inputs. By default, the to channel will be closed when the from\n  channel closes, but can be determined by the close?  parameter. Will\n  stop consuming the from channel if the to channel closes.\n\n  Note this is supplied for API compatibility with the Clojure version.\n  Values of N > 1 will not result in actual concurrency in a\n  single-threaded runtime.", :arglists [[n to xf from] [n to xf from close?] [n to xf from close? ex-handler]]}, :source "(defn\n pipeline\n \"Takes elements from the from channel and supplies them to the to\\n  channel, subject to the transducer xf, with parallelism n. Because\\n  it is parallel, the transducer will be applied independently to each\\n  element, not across elements, and may produce zero or more outputs\\n  per input.  Outputs will be returned in order relative to the\\n  inputs. By default, the to channel will be closed when the from\\n  channel closes, but can be determined by the close?  parameter. Will\\n  stop consuming the from channel if the to channel closes.\\n\\n  Note this is supplied for API compatibility with the Clojure version.\\n  Values of N > 1 will not result in actual concurrency in a\\n  single-threaded runtime.\"\n ([n to xf from] (pipeline n to xf from true))\n ([n to xf from close?] (pipeline n to xf from close? nil))\n ([n to xf from close? ex-handler]\n  (pipeline* n to xf from close? ex-handler :compute)))\n"} {:sym sub, :meta {:doc "Subscribes a channel to a topic of a pub.\n\n  By default the channel will be closed when the source closes,\n  but can be determined by the close? parameter.", :arglists [[p topic ch] [p topic ch close?]]}, :source "(defn\n sub\n \"Subscribes a channel to a topic of a pub.\\n\\n  By default the channel will be closed when the source closes,\\n  but can be determined by the close? parameter.\"\n ([p topic ch] (sub p topic ch true))\n ([p topic ch close?] (sub* p topic ch close?)))\n"} {:sym map>, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists ([f ch])}, :source "(defn\n map>\n \"Deprecated - this function will be removed. Use transducer instead\"\n [f ch]\n (reify\n  impl/Channel\n  (close! [_] (impl/close! ch))\n  impl/ReadPort\n  (take! [_ fn1] (impl/take! ch fn1))\n  impl/WritePort\n  (put! [_ val fn1] (impl/put! ch (f val) fn1))))\n"} {:sym pipe, :meta {:doc "Takes elements from the from channel and supplies them to the to\n   channel. By default, the to channel will be closed when the from\n   channel closes, but can be determined by the close?  parameter. Will\n   stop consuming the from channel if the to channel closes", :arglists [[from to] [from to close?]]}, :source "(defn\n pipe\n \"Takes elements from the from channel and supplies them to the to\\n   channel. By default, the to channel will be closed when the from\\n   channel closes, but can be determined by the close?  parameter. Will\\n   stop consuming the from channel if the to channel closes\"\n ([from to] (pipe from to true))\n ([from to close?]\n  (go-loop\n   []\n   (let\n    [v (<! from)]\n    (if (nil? v) (when close? (close! to)) (when (>! to v) (recur)))))\n  to))\n"} {:sym unmix, :meta {:doc "Removes ch as an input to the mix", :arglists ([mix ch])}, :source "(defn\n unmix\n \"Removes ch as an input to the mix\"\n [mix ch]\n (unmix* mix ch))\n"} {:sym filter<, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists [[p ch] [p ch buf-or-n]]}, :source "(defn\n filter<\n \"Deprecated - this function will be removed. Use transducer instead\"\n ([p ch] (filter< p ch nil))\n ([p ch buf-or-n]\n  (let\n   [out (chan buf-or-n)]\n   (go-loop\n    []\n    (let\n     [val (<! ch)]\n     (if\n      (nil? val)\n      (close! out)\n      (do (when (p val) (>! out val)) (recur)))))\n   out)))\n"} {:sym sub*, :meta {:doc nil, :arglists ([p v ch close?])}, :protocol Pub} {:sym remove<, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists [[p ch] [p ch buf-or-n]]}, :source "(defn\n remove<\n \"Deprecated - this function will be removed. Use transducer instead\"\n ([p ch] (remove< p ch nil))\n ([p ch buf-or-n] (filter< (complement p) ch buf-or-n)))\n"} {:sym untap*, :meta {:doc nil, :arglists ([m ch])}, :protocol Mult} {:sym toggle, :meta {:doc "Atomically sets the state(s) of one or more channels in a mix. The\n  state map is a map of channels -> channel-state-map. A\n  channel-state-map is a map of attrs -> boolean, where attr is one or\n  more of :mute, :pause or :solo. Any states supplied are merged with\n  the current state.\n\n  Note that channels can be added to a mix via toggle, which can be\n  used to add channels in a particular (e.g. paused) state.", :arglists ([mix state-map])}, :source "(defn\n toggle\n \"Atomically sets the state(s) of one or more channels in a mix. The\\n  state map is a map of channels -> channel-state-map. A\\n  channel-state-map is a map of attrs -> boolean, where attr is one or\\n  more of :mute, :pause or :solo. Any states supplied are merged with\\n  the current state.\\n\\n  Note that channels can be added to a mix via toggle, which can be\\n  used to add channels in a particular (e.g. paused) state.\"\n [mix state-map]\n (toggle* mix state-map))\n"} {:sym untap-all*, :meta {:doc nil, :arglists ([m])}, :protocol Mult} {:sym sliding-buffer, :meta {:doc "Returns a buffer of size n. When full, puts will complete, and be\n  buffered, but oldest elements in buffer will be dropped (not\n  transferred).", :arglists ([n])}, :source "(defn\n sliding-buffer\n \"Returns a buffer of size n. When full, puts will complete, and be\\n  buffered, but oldest elements in buffer will be dropped (not\\n  transferred).\"\n [n]\n (buffers/sliding-buffer n))\n"} {:sym partition, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists [[n ch] [n ch buf-or-n]]}, :source "(defn\n partition\n \"Deprecated - this function will be removed. Use transducer instead\"\n ([n ch] (partition n ch nil))\n ([n ch buf-or-n]\n  (let\n   [out (chan buf-or-n)]\n   (go\n    (loop\n     [arr (make-array n) idx 0]\n     (let\n      [v (<! ch)]\n      (if\n       (not (nil? v))\n       (do\n        (aset arr idx v)\n        (let\n         [new-idx (inc idx)]\n         (if\n          (< new-idx n)\n          (recur arr new-idx)\n          (do (>! out (vec arr)) (recur (make-array n) 0)))))\n       (do (when (> idx 0) (>! out (vec arr))) (close! out))))))\n   out)))\n"} {:sym Mult, :meta {:doc nil}, :methods (tap* untap* untap-all*)} {:sym merge, :meta {:doc "Takes a collection of source channels and returns a channel which\n  contains all values taken from them. The returned channel will be\n  unbuffered by default, or a buf-or-n can be supplied. The channel\n  will close after all the source channels have closed.", :arglists [[chs] [chs buf-or-n]]}, :source "(defn\n merge\n \"Takes a collection of source channels and returns a channel which\\n  contains all values taken from them. The returned channel will be\\n  unbuffered by default, or a buf-or-n can be supplied. The channel\\n  will close after all the source channels have closed.\"\n ([chs] (merge chs nil))\n ([chs buf-or-n]\n  (let\n   [out (chan buf-or-n)]\n   (go-loop\n    [cs (vec chs)]\n    (if\n     (pos? (count cs))\n     (let\n      [[v c] (alts! cs)]\n      (if\n       (nil? v)\n       (recur (filterv (fn* [p1__18373#] (not= c p1__18373#)) cs))\n       (do (>! out v) (recur cs))))\n     (close! out)))\n   out)))\n"} {:sym partition-by, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists [[f ch] [f ch buf-or-n]]}, :source "(defn\n partition-by\n \"Deprecated - this function will be removed. Use transducer instead\"\n ([f ch] (partition-by f ch nil))\n ([f ch buf-or-n]\n  (let\n   [out (chan buf-or-n)]\n   (go\n    (loop\n     [lst (make-array 0) last :clojure.core/nothing]\n     (let\n      [v (<! ch)]\n      (if\n       (not (nil? v))\n       (let\n        [new-itm (f v)]\n        (if\n         (or\n          (= new-itm last)\n          (keyword-identical? last :clojure.core/nothing))\n         (do (.push lst v) (recur lst new-itm))\n         (do\n          (>! out (vec lst))\n          (let\n           [new-lst (make-array 0)]\n           (.push new-lst v)\n           (recur new-lst new-itm)))))\n       (do\n        (when (> (alength lst) 0) (>! out (vec lst)))\n        (close! out))))))\n   out)))\n"} {:sym unsub-all, :meta {:doc "Unsubscribes all channels from a pub, or a topic of a pub", :arglists [[p] [p topic]]}, :source "(defn\n unsub-all\n \"Unsubscribes all channels from a pub, or a topic of a pub\"\n ([p] (unsub-all* p))\n ([p topic] (unsub-all* p topic)))\n"} {:sym >!, :meta {:doc "puts a val into port. nil values are not allowed. Must be called\n  inside a (go ...) block. Will park if no buffer space is available.\n  Returns true unless port is already closed.", :arglists ([port val])}, :source "(defn\n >!\n \"puts a val into port. nil values are not allowed. Must be called\\n  inside a (go ...) block. Will park if no buffer space is available.\\n  Returns true unless port is already closed.\"\n [port val]\n (throw (js/Error. \">! used not in (go ...) block\")))\n"} {:sym unmix-all*, :meta {:doc nil, :arglists ([m])}, :protocol Mix} {:sym split, :meta {:doc "Takes a predicate and a source channel and returns a vector of two\n  channels, the first of which will contain the values for which the\n  predicate returned true, the second those for which it returned\n  false.\n\n  The out channels will be unbuffered by default, or two buf-or-ns can\n  be supplied. The channels will close after the source channel has\n  closed.", :arglists [[p ch] [p ch t-buf-or-n f-buf-or-n]]}, :source "(defn\n split\n \"Takes a predicate and a source channel and returns a vector of two\\n  channels, the first of which will contain the values for which the\\n  predicate returned true, the second those for which it returned\\n  false.\\n\\n  The out channels will be unbuffered by default, or two buf-or-ns can\\n  be supplied. The channels will close after the source channel has\\n  closed.\"\n ([p ch] (split p ch nil nil))\n ([p ch t-buf-or-n f-buf-or-n]\n  (let\n   [tc (chan t-buf-or-n) fc (chan f-buf-or-n)]\n   (go-loop\n    []\n    (let\n     [v (<! ch)]\n     (if\n      (nil? v)\n      (do (close! tc) (close! fc))\n      (when (>! (if (p v) tc fc) v) (recur)))))\n   [tc fc])))\n"} {:sym unmix-all, :meta {:doc "removes all inputs from the mix", :arglists ([mix])}, :source "(defn\n unmix-all\n \"removes all inputs from the mix\"\n [mix]\n (unmix-all* mix))\n"} {:sym filter>, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists ([p ch])}, :source "(defn\n filter>\n \"Deprecated - this function will be removed. Use transducer instead\"\n [p ch]\n (reify\n  impl/Channel\n  (close! [_] (impl/close! ch))\n  (closed? [_] (impl/closed? ch))\n  impl/ReadPort\n  (take! [_ fn1] (impl/take! ch fn1))\n  impl/WritePort\n  (put!\n   [_ val fn1]\n   (if\n    (p val)\n    (impl/put! ch val fn1)\n    (channels/box (not (impl/closed? ch)))))))\n"} {:sym tap*, :meta {:doc nil, :arglists ([m ch close?])}, :protocol Mult} {:sym untap, :meta {:doc "Disconnects a target channel from a mult", :arglists ([mult ch])}, :source "(defn\n untap\n \"Disconnects a target channel from a mult\"\n [mult ch]\n (untap* mult ch))\n"} {:sym alts!, :meta {:doc "Completes at most one of several channel operations. Must be called\n   inside a (go ...) block. ports is a vector of channel endpoints,\n   which can be either a channel to take from or a vector of\n  [channel-to-put-to val-to-put], in any combination. Takes will be\n  made as if by <!, and puts will be made as if by >!. Unless\n  the :priority option is true, if more than one port operation is\n  ready a non-deterministic choice will be made. If no operation is\n  ready and a :default value is supplied, [default-val :default] will\n  be returned, otherwise alts! will park until the first operation to\n  become ready completes. Returns [val port] of the completed\n  operation, where val is the value taken for takes, and a\n  boolean (true unless already closed, as per put!) for puts.\n\n  opts are passed as :key val ... Supported options:\n\n  :default val - the value to use if none of the operations are immediately ready\n  :priority true - (default nil) when true, the operations will be tried in order.\n\n  Note: there is no guarantee that the port exps or val exprs will be\n  used, nor in what order should they be, so they should not be\n  depended upon for side effects.", :arglists ([ports & {:as opts}])}, :source "(defn\n alts!\n \"Completes at most one of several channel operations. Must be called\\n   inside a (go ...) block. ports is a vector of channel endpoints,\\n   which can be either a channel to take from or a vector of\\n  [channel-to-put-to val-to-put], in any combination. Takes will be\\n  made as if by <!, and puts will be made as if by >!. Unless\\n  the :priority option is true, if more than one port operation is\\n  ready a non-deterministic choice will be made. If no operation is\\n  ready and a :default value is supplied, [default-val :default] will\\n  be returned, otherwise alts! will park until the first operation to\\n  become ready completes. Returns [val port] of the completed\\n  operation, where val is the value taken for takes, and a\\n  boolean (true unless already closed, as per put!) for puts.\\n\\n  opts are passed as :key val ... Supported options:\\n\\n  :default val - the value to use if none of the operations are immediately ready\\n  :priority true - (default nil) when true, the operations will be tried in order.\\n\\n  Note: there is no guarantee that the port exps or val exprs will be\\n  used, nor in what order should they be, so they should not be\\n  depended upon for side effects.\"\n [ports & {:as opts}]\n (throw (js/Error. \"alts! used not in (go ...) block\")))\n"} {:sym unsub, :meta {:doc "Unsubscribes a channel from a topic of a pub", :arglists ([p topic ch])}, :source "(defn\n unsub\n \"Unsubscribes a channel from a topic of a pub\"\n [p topic ch]\n (unsub* p topic ch))\n"} {:sym poll!, :meta {:doc "Takes a val from port if it's possible to do so immediately.\n  Never blocks. Returns value if successful, nil otherwise.", :arglists ([port])}, :source "(defn\n poll!\n \"Takes a val from port if it's possible to do so immediately.\\n  Never blocks. Returns value if successful, nil otherwise.\"\n [port]\n (let [ret (impl/take! port (fn-handler nop false))] (when ret @ret)))\n"} {:sym map<, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists ([f ch])}, :source "(defn\n map<\n \"Deprecated - this function will be removed. Use transducer instead\"\n [f ch]\n (reify\n  impl/Channel\n  (close! [_] (impl/close! ch))\n  (closed? [_] (impl/closed? ch))\n  impl/ReadPort\n  (take!\n   [_ fn1]\n   (let\n    [ret\n     (impl/take!\n      ch\n      (reify\n       impl/Handler\n       (active? [_] (impl/active? fn1))\n       (blockable? [_] true)\n       (commit\n        [_]\n        (let\n         [f1 (impl/commit fn1)]\n         (fn*\n          [p1__18374#]\n          (f1 (if (nil? p1__18374#) nil (f p1__18374#))))))))]\n    (if (and ret (not (nil? @ret))) (channels/box (f @ret)) ret)))\n  impl/WritePort\n  (put! [_ val fn1] (impl/put! ch val fn1))))\n"} {:sym do-alts, :meta {:doc "returns derefable [val port] if immediate, nil if enqueued", :arglists ([fret ports opts])}, :source "(defn\n do-alts\n \"returns derefable [val port] if immediate, nil if enqueued\"\n [fret ports opts]\n (let\n  [flag\n   (alt-flag)\n   n\n   (count ports)\n   idxs\n   (random-array n)\n   priority\n   (:priority opts)\n   ret\n   (loop\n    [i 0]\n    (when\n     (< i n)\n     (let\n      [idx\n       (if priority i (aget idxs i))\n       port\n       (nth ports idx)\n       wport\n       (when (vector? port) (port 0))\n       vbox\n       (if\n        wport\n        (let\n         [val (port 1)]\n         (impl/put!\n          wport\n          val\n          (alt-handler\n           flag\n           (fn* [p1__18370#] (fret [p1__18370# wport])))))\n        (impl/take!\n         port\n         (alt-handler\n          flag\n          (fn* [p1__18371#] (fret [p1__18371# port])))))]\n      (if\n       vbox\n       (channels/box [@vbox (or wport port)])\n       (recur (inc i))))))]\n  (or\n   ret\n   (when\n    (contains? opts :default)\n    (when-let\n     [got (and (impl/active? flag) (impl/commit flag))]\n     (channels/box [(:default opts) :default]))))))\n"} {:sym pipeline-async, :meta {:doc "Takes elements from the from channel and supplies them to the to\n  channel, subject to the async function af, with parallelism n. af\n  must be a function of two arguments, the first an input value and\n  the second a channel on which to place the result(s). af must close!\n  the channel before returning.  The presumption is that af will\n  return immediately, having launched some asynchronous operation\n  whose completion/callback will manipulate the result channel. Outputs\n  will be returned in order relative to  the inputs. By default, the to\n  channel will be closed when the from channel closes, but can be\n  determined by the close?  parameter. Will stop consuming the from\n  channel if the to channel closes.", :arglists [[n to af from] [n to af from close?]]}, :source "(defn\n pipeline-async\n \"Takes elements from the from channel and supplies them to the to\\n  channel, subject to the async function af, with parallelism n. af\\n  must be a function of two arguments, the first an input value and\\n  the second a channel on which to place the result(s). af must close!\\n  the channel before returning.  The presumption is that af will\\n  return immediately, having launched some asynchronous operation\\n  whose completion/callback will manipulate the result channel. Outputs\\n  will be returned in order relative to  the inputs. By default, the to\\n  channel will be closed when the from channel closes, but can be\\n  determined by the close?  parameter. Will stop consuming the from\\n  channel if the to channel closes.\"\n ([n to af from] (pipeline-async n to af from true))\n ([n to af from close?] (pipeline* n to af from close? nil :async)))\n"} {:sym Mix, :meta {:doc nil}, :methods (admix* solo-mode* toggle* unmix* unmix-all*)} {:sym toggle*, :meta {:doc nil, :arglists ([m state-map])}, :protocol Mix} {:sym mult, :meta {:doc "Creates and returns a mult(iple) of the supplied channel. Channels\n  containing copies of the channel can be created with 'tap', and\n  detached with 'untap'.\n\n  Each item is distributed to all taps in parallel and synchronously,\n  i.e. each tap must accept before the next item is distributed. Use\n  buffering/windowing to prevent slow taps from holding up the mult.\n\n  Items received when there are no taps get dropped.\n\n  If a tap puts to a closed channel, it will be removed from the mult.", :arglists ([ch])}, :source "(defn\n mult\n \"Creates and returns a mult(iple) of the supplied channel. Channels\\n  containing copies of the channel can be created with 'tap', and\\n  detached with 'untap'.\\n\\n  Each item is distributed to all taps in parallel and synchronously,\\n  i.e. each tap must accept before the next item is distributed. Use\\n  buffering/windowing to prevent slow taps from holding up the mult.\\n\\n  Items received when there are no taps get dropped.\\n\\n  If a tap puts to a closed channel, it will be removed from the mult.\"\n [ch]\n (let\n  [cs\n   (atom {})\n   m\n   (reify\n    Mux\n    (muxch* [_] ch)\n    Mult\n    (tap* [_ ch close?] (swap! cs assoc ch close?) nil)\n    (untap* [_ ch] (swap! cs dissoc ch) nil)\n    (untap-all* [_] (reset! cs {}) nil))\n   dchan\n   (chan 1)\n   dctr\n   (atom nil)\n   done\n   (fn [_] (when (zero? (swap! dctr dec)) (put! dchan true)))]\n  (go-loop\n   []\n   (let\n    [val (<! ch)]\n    (if\n     (nil? val)\n     (doseq [[c close?] @cs] (when close? (close! c)))\n     (let\n      [chs (keys @cs)]\n      (reset! dctr (count chs))\n      (doseq\n       [c chs]\n       (when-not (put! c val done) (done nil) (untap* m c)))\n      (when (seq chs) (<! dchan))\n      (recur)))))\n  m))\n"} {:sym mapcat<, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists [[f in] [f in buf-or-n]]}, :source "(defn\n mapcat<\n \"Deprecated - this function will be removed. Use transducer instead\"\n ([f in] (mapcat< f in nil))\n ([f in buf-or-n] (let [out (chan buf-or-n)] (mapcat* f in out) out)))\n"} {:sym ioc-alts!, :meta {:doc nil, :arglists ([state cont-block ports & {:as opts}])}, :source "(defn\n ioc-alts!\n [state cont-block ports & {:as opts}]\n (ioc/aset-all! state helpers/STATE-IDX cont-block)\n (when-let\n  [cb\n   (cljs.core.async/do-alts\n    (fn\n     [val]\n     (ioc/aset-all! state helpers/VALUE-IDX val)\n     (helpers/run-state-machine-wrapped state))\n    ports\n    opts)]\n  (ioc/aset-all! state helpers/VALUE-IDX @cb)\n  :recur))\n"} {:sym unblocking-buffer?, :meta {:doc "Returns true if a channel created with buff will never block. That is to say,\n   puts into this buffer will never cause the buffer to be full. ", :arglists ([buff])}, :source "(defn\n unblocking-buffer?\n \"Returns true if a channel created with buff will never block. That is to say,\\n   puts into this buffer will never cause the buffer to be full. \"\n [buff]\n (satisfies? impl/UnblockingBuffer buff))\n"} {:sym put!, :meta {:doc "Asynchronously puts a val into port, calling fn0 (if supplied) when\n   complete. nil values are not allowed. Will throw if closed. If\n   on-caller? (default true) is true, and the put is immediately\n   accepted, will call fn0 on calling thread.  Returns nil.", :arglists [[port val] [port val fn1] [port val fn1 on-caller?]]}, :source "(defn\n put!\n \"Asynchronously puts a val into port, calling fn0 (if supplied) when\\n   complete. nil values are not allowed. Will throw if closed. If\\n   on-caller? (default true) is true, and the put is immediately\\n   accepted, will call fn0 on calling thread.  Returns nil.\"\n ([port val] (if-let [ret (impl/put! port val fhnop)] @ret true))\n ([port val fn1] (put! port val fn1 true))\n ([port val fn1 on-caller?]\n  (if-let\n   [retb (impl/put! port val (fn-handler fn1))]\n   (let\n    [ret @retb]\n    (if on-caller? (fn1 ret) (dispatch/run (fn* [] (fn1 ret))))\n    ret)\n   true)))\n"} {:sym take!, :meta {:doc "Asynchronously takes a val from port, passing to fn1. Will pass nil\n   if closed. If on-caller? (default true) is true, and value is\n   immediately available, will call fn1 on calling thread.\n   Returns nil.", :arglists [[port fn1] [port fn1 on-caller?]]}, :source "(defn\n take!\n \"Asynchronously takes a val from port, passing to fn1. Will pass nil\\n   if closed. If on-caller? (default true) is true, and value is\\n   immediately available, will call fn1 on calling thread.\\n   Returns nil.\"\n ([port fn1] (take! port fn1 true))\n ([port fn1 on-caller?]\n  (let\n   [ret (impl/take! port (fn-handler fn1))]\n   (when\n    ret\n    (let\n     [val @ret]\n     (if on-caller? (fn1 val) (dispatch/run (fn* [] (fn1 val))))))\n   nil)))\n"}), cljs.core.async.impl.buffers ({:sym acopy, :meta {:doc nil, :arglists ([src src-start dest dest-start len])}, :source "(defn\n acopy\n [src src-start dest dest-start len]\n (loop\n  [cnt 0]\n  (when\n   (< cnt len)\n   (aset dest (+ dest-start cnt) (aget src (+ src-start cnt)))\n   (recur (inc cnt)))))\n"} {:sym ring-buffer, :meta {:doc nil, :arglists ([n])}, :source "(defn\n ring-buffer\n [n]\n (assert (> n 0) \"Can't create a ring buffer of size 0\")\n (RingBuffer. 0 0 0 (make-array n)))\n"} {:sym fixed-buffer, :meta {:doc nil, :arglists ([n])}, :source "(defn fixed-buffer [n] (FixedBuffer. (ring-buffer n) n))\n"} {:sym dropping-buffer, :meta {:doc nil, :arglists ([n])}, :source "(defn dropping-buffer [n] (DroppingBuffer. (ring-buffer n) n))\n"} {:sym sliding-buffer, :meta {:doc nil, :arglists ([n])}, :source "(defn sliding-buffer [n] (SlidingBuffer. (ring-buffer n) n))\n"} {:sym promise-buffer, :meta {:doc nil, :arglists ([])}, :source "(defn promise-buffer [] (PromiseBuffer. NO-VAL))\n"}), cljs.core.async.impl.protocols ({:sym remove!, :meta {:doc "remove and return next item from buffer, called under chan mutex", :arglists ([b])}, :protocol Buffer} {:sym close-buf!, :meta {:doc "called on chan closed under chan mutex, return ignored", :arglists ([b])}, :protocol Buffer} {:sym close!, :meta {:doc nil, :arglists ([chan])}, :protocol Channel} {:sym Handler, :meta {:doc nil}, :methods (active? blockable? commit)} {:sym blockable?, :meta {:doc "returns true if this handler may be blocked, otherwise it must not block", :arglists ([h])}, :protocol Handler} {:sym active?, :meta {:doc "returns true if has callback. Must work w/o lock", :arglists ([h])}, :protocol Handler} {:sym Buffer, :meta {:doc nil}, :methods (add!* close-buf! full? remove!)} {:sym full?, :meta {:doc "returns true if buffer cannot accept put", :arglists ([b])}, :protocol Buffer} {:sym add!, :meta {:doc nil, :arglists [[b] [b itm]]}, :source "(defn add! ([b] b) ([b itm] (assert (not (nil? itm))) (add!* b itm)))\n"} {:sym add!*, :meta {:doc "if room, add item to the buffer, returns b, called under chan mutex", :arglists ([b itm])}, :protocol Buffer} {:sym ReadPort, :meta {:doc nil}, :methods (take!)} {:sym Channel, :meta {:doc nil}, :methods (close! closed?)} {:sym closed?, :meta {:doc nil, :arglists ([chan])}, :protocol Channel} {:sym UnblockingBuffer, :meta {:doc nil}, :methods ()} {:sym MAX-QUEUE-SIZE, :meta {}, :source "(def MAX-QUEUE-SIZE 1024)\n"} {:sym commit, :meta {:doc "commit to fulfilling its end of the transfer, returns cb. Must be called within lock", :arglists ([h])}, :protocol Handler} {:sym put!, :meta {:doc "derefable boolean (false if already closed) if handled, nil if put was enqueued.\n                               Must throw on nil val.", :arglists ([port val fn1-handler])}, :protocol WritePort} {:sym take!, :meta {:doc "derefable val if taken, nil if take was enqueued", :arglists ([port fn1-handler])}, :protocol ReadPort} {:sym WritePort, :meta {:doc nil}, :methods (put!)}), cljs.tools.reader.impl.inspect ({:sym inspect, :meta {:doc "Return a string description of the value supplied.\n   May be the a string version of the value itself (e.g. \"true\")\n   or it may be a description (e.g. \"an instance of Foo\").\n   If truncate is true then return a very terse version of\n   the inspection.", :arglists [[x] [truncate x]]}, :source "(defn\n inspect\n \"Return a string description of the value supplied.\\n   May be the a string version of the value itself (e.g. \\\"true\\\")\\n   or it may be a description (e.g. \\\"an instance of Foo\\\").\\n   If truncate is true then return a very terse version of\\n   the inspection.\"\n ([x] (inspect* false x))\n ([truncate x] (inspect* truncate x)))\n"}), clojure.set ({:sym union, :meta {:doc "Return a set that is the union of the input sets", :arglists [[] [s1] [s1 s2] [s1 s2 & sets]]}, :source "(defn\n union\n \"Return a set that is the union of the input sets\"\n ([] #{})\n ([s1] s1)\n ([s1 s2]\n  (if\n   (< (count s1) (count s2))\n   (reduce conj s2 s1)\n   (reduce conj s1 s2)))\n ([s1 s2 & sets]\n  (let\n   [bubbled-sets (bubble-max-key count (conj sets s2 s1))]\n   (reduce into (first bubbled-sets) (rest bubbled-sets)))))\n"} {:sym map-invert, :meta {:doc "Returns the map with the vals mapped to the keys.", :arglists ([m])}, :source "(defn\n map-invert\n \"Returns the map with the vals mapped to the keys.\"\n [m]\n (reduce (fn [m [k v]] (assoc m v k)) {} m))\n"} {:sym join, :meta {:doc "When passed 2 rels, returns the rel corresponding to the natural\n  join. When passed an additional keymap, joins on the corresponding\n  keys.", :arglists [[xrel yrel] [xrel yrel km]]}, :source "(defn\n join\n \"When passed 2 rels, returns the rel corresponding to the natural\\n  join. When passed an additional keymap, joins on the corresponding\\n  keys.\"\n ([xrel yrel]\n  (if\n   (and (seq xrel) (seq yrel))\n   (let\n    [ks\n     (intersection (set (keys (first xrel))) (set (keys (first yrel))))\n     [r s]\n     (if (<= (count xrel) (count yrel)) [xrel yrel] [yrel xrel])\n     idx\n     (index r ks)]\n    (reduce\n     (fn\n      [ret x]\n      (let\n       [found (idx (select-keys x ks))]\n       (if\n        found\n        (reduce\n         (fn*\n          [p1__18507# p2__18508#]\n          (conj p1__18507# (merge p2__18508# x)))\n         ret\n         found)\n        ret)))\n     #{}\n     s))\n   #{}))\n ([xrel yrel km]\n  (let\n   [[r s k]\n    (if\n     (<= (count xrel) (count yrel))\n     [xrel yrel (map-invert km)]\n     [yrel xrel km])\n    idx\n    (index r (vals k))]\n   (reduce\n    (fn\n     [ret x]\n     (let\n      [found (idx (rename-keys (select-keys x (keys k)) k))]\n      (if\n       found\n       (reduce\n        (fn*\n         [p1__18509# p2__18510#]\n         (conj p1__18509# (merge p2__18510# x)))\n        ret\n        found)\n       ret)))\n    #{}\n    s))))\n"} {:sym select, :meta {:doc "Returns a set of the elements for which pred is true", :arglists ([pred xset])}, :source "(defn\n select\n \"Returns a set of the elements for which pred is true\"\n [pred xset]\n (reduce (fn [s k] (if (pred k) s (disj s k))) xset xset))\n"} {:sym intersection, :meta {:doc "Return a set that is the intersection of the input sets", :arglists [[s1] [s1 s2] [s1 s2 & sets]]}, :source "(defn\n intersection\n \"Return a set that is the intersection of the input sets\"\n ([s1] s1)\n ([s1 s2]\n  (if\n   (< (count s2) (count s1))\n   (recur s2 s1)\n   (reduce\n    (fn\n     [result item]\n     (if (contains? s2 item) result (disj result item)))\n    s1\n    s1)))\n ([s1 s2 & sets]\n  (let\n   [bubbled-sets\n    (bubble-max-key\n     (fn* [p1__18504#] (- (count p1__18504#)))\n     (conj sets s2 s1))]\n   (reduce intersection (first bubbled-sets) (rest bubbled-sets)))))\n"} {:sym superset?, :meta {:doc "Is set1 a superset of set2?", :arglists ([set1 set2])}, :source "(defn\n superset?\n \"Is set1 a superset of set2?\"\n [set1 set2]\n (and\n  (>= (count set1) (count set2))\n  (every? (fn* [p1__18512#] (contains? set1 p1__18512#)) set2)))\n"} {:sym index, :meta {:doc "Returns a map of the distinct values of ks in the xrel mapped to a\n  set of the maps in xrel with the corresponding values of ks.", :arglists ([xrel ks])}, :source "(defn\n index\n \"Returns a map of the distinct values of ks in the xrel mapped to a\\n  set of the maps in xrel with the corresponding values of ks.\"\n [xrel ks]\n (reduce\n  (fn\n   [m x]\n   (let [ik (select-keys x ks)] (assoc m ik (conj (get m ik #{}) x))))\n  {}\n  xrel))\n"} {:sym subset?, :meta {:doc "Is set1 a subset of set2?", :arglists ([set1 set2])}, :source "(defn\n subset?\n \"Is set1 a subset of set2?\"\n [set1 set2]\n (and\n  (<= (count set1) (count set2))\n  (every? (fn* [p1__18511#] (contains? set2 p1__18511#)) set1)))\n"} {:sym rename, :meta {:doc "Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap", :arglists ([xrel kmap])}, :source "(defn\n rename\n \"Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap\"\n [xrel kmap]\n (set (map (fn* [p1__18506#] (rename-keys p1__18506# kmap)) xrel)))\n"} {:sym rename-keys, :meta {:doc "Returns the map with the keys in kmap renamed to the vals in kmap", :arglists ([map kmap])}, :source "(defn\n rename-keys\n \"Returns the map with the keys in kmap renamed to the vals in kmap\"\n [map kmap]\n (reduce\n  (fn\n   [m [old new]]\n   (if (contains? map old) (assoc m new (get map old)) m))\n  (apply dissoc map (keys kmap))\n  kmap))\n"} {:sym project, :meta {:doc "Returns a rel of the elements of xrel with only the keys in ks", :arglists ([xrel ks])}, :source "(defn\n project\n \"Returns a rel of the elements of xrel with only the keys in ks\"\n [xrel ks]\n (set (map (fn* [p1__18505#] (select-keys p1__18505# ks)) xrel)))\n"} {:sym difference, :meta {:doc "Return a set that is the first set without elements of the remaining sets", :arglists [[s1] [s1 s2] [s1 s2 & sets]]}, :source "(defn\n difference\n \"Return a set that is the first set without elements of the remaining sets\"\n ([s1] s1)\n ([s1 s2]\n  (if\n   (< (count s1) (count s2))\n   (reduce\n    (fn\n     [result item]\n     (if (contains? s2 item) (disj result item) result))\n    s1\n    s1)\n   (reduce disj s1 s2)))\n ([s1 s2 & sets] (reduce difference s1 (conj sets s2))))\n"}), cljs.pprint ({:sym pprint, :meta {:doc nil, :arglists [[object] [object writer]]}, :source "(defn\n pprint\n ([object]\n  (let\n   [sb (StringBuffer.)]\n   (binding\n    [*out* (StringBufferWriter. sb)]\n    (pprint object *out*)\n    (string-print (str sb)))))\n ([object writer]\n  (with-pretty-writer\n   writer\n   (binding [*print-pretty* true] (write-out object))\n   (if (not (= 0 (get-column *out*))) (-write *out* \\newline)))))\n"} {:sym get-pretty-writer, :meta {:doc "Returns the IWriter passed in wrapped in a pretty writer proxy, unless it's\nalready a pretty writer. Generally, it is unnecessary to call this function, since pprint,\nwrite, and cl-format all call it if they need to. However if you want the state to be\npreserved across calls, you will want to wrap them with this.\n\nFor example, when you want to generate column-aware output with multiple calls to cl-format,\ndo it like in this example:\n\n    (defn print-table [aseq column-width]\n      (binding [*out* (get-pretty-writer *out*)]\n        (doseq [row aseq]\n          (doseq [col row]\n            (cl-format true \"~4D~7,vT\" col column-width))\n          (prn))))\n\nNow when you run:\n\n    user> (print-table (map #(vector % (* % %) (* % % %)) (range 1 11)) 8)\n\nIt prints a table of squares and cubes for the numbers from 1 to 10:\n\n       1      1       1\n       2      4       8\n       3      9      27\n       4     16      64\n       5     25     125\n       6     36     216\n       7     49     343\n       8     64     512\n       9     81     729\n      10    100    1000", :arglists ([writer])}, :source "(defn\n get-pretty-writer\n \"Returns the IWriter passed in wrapped in a pretty writer proxy, unless it's\\nalready a pretty writer. Generally, it is unnecessary to call this function, since pprint,\\nwrite, and cl-format all call it if they need to. However if you want the state to be\\npreserved across calls, you will want to wrap them with this.\\n\\nFor example, when you want to generate column-aware output with multiple calls to cl-format,\\ndo it like in this example:\\n\\n    (defn print-table [aseq column-width]\\n      (binding [*out* (get-pretty-writer *out*)]\\n        (doseq [row aseq]\\n          (doseq [col row]\\n            (cl-format true \\\"~4D~7,vT\\\" col column-width))\\n          (prn))))\\n\\nNow when you run:\\n\\n    user> (print-table (map #(vector % (* % %) (* % % %)) (range 1 11)) 8)\\n\\nIt prints a table of squares and cubes for the numbers from 1 to 10:\\n\\n       1      1       1\\n       2      4       8\\n       3      9      27\\n       4     16      64\\n       5     25     125\\n       6     36     216\\n       7     49     343\\n       8     64     512\\n       9     81     729\\n      10    100    1000\"\n [writer]\n (if\n  (pretty-writer? writer)\n  writer\n  (pretty-writer writer *print-right-margin* *print-miser-width*)))\n"} {:sym *print-suppress-namespaces*, :meta {:doc "Don't print namespaces with symbols. This is particularly useful when\npretty printing the results of macro expansions"}, :source "(def *print-suppress-namespaces* nil)\n"} {:sym char-code, :meta {:doc "Convert char to int", :arglists ([c])}, :source "(defn\n char-code\n \"Convert char to int\"\n [c]\n (cond\n  (number? c)\n  c\n  (and (string? c) (== (.-length c) 1))\n  (.charCodeAt c 0)\n  :else\n  (throw (js/Error. \"Argument to char must be a character or number\"))))\n"} {:sym *print-pretty*, :meta {:doc "Bind to true if you want write to use pretty printing"}, :source "(def *print-pretty* true)\n"} {:sym *print-pprint-dispatch*, :meta {:doc "The pretty print dispatch function. Use with-pprint-dispatch or\nset-pprint-dispatch to modify."}, :source "(defonce *print-pprint-dispatch* nil)\n"} {:sym pprint-newline, :meta {:doc "Print a conditional newline to a pretty printing stream. kind specifies if the\n  newline is :linear, :miser, :fill, or :mandatory.\n\n  This function is intended for use when writing custom dispatch functions.\n\n  Output is sent to *out* which must be a pretty printing writer.", :arglists ([kind])}, :source "(defn\n pprint-newline\n \"Print a conditional newline to a pretty printing stream. kind specifies if the\\n  newline is :linear, :miser, :fill, or :mandatory.\\n\\n  This function is intended for use when writing custom dispatch functions.\\n\\n  Output is sent to *out* which must be a pretty printing writer.\"\n [kind]\n (check-enumerated-arg kind #{:mandatory :miser :fill :linear})\n (nl *out* kind))\n"} {:sym float?, :meta {:doc "Returns true if n is an float.", :arglists ([n])}, :source "(defn\n float?\n \"Returns true if n is an float.\"\n [n]\n (and\n  (number? n)\n  (not (js/isNaN n))\n  (not (identical? n js/Infinity))\n  (not (== (js/parseFloat n) (js/parseInt n 10)))))\n"} {:sym pprint-tab, :meta {:doc "Tab at this point in the pretty printing stream. kind specifies whether the tab\nis :line, :section, :line-relative, or :section-relative.\n\nColnum and colinc specify the target column and the increment to move the target\nforward if the output is already past the original target.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.\n\nTHIS FUNCTION IS NOT YET IMPLEMENTED.", :arglists ([kind colnum colinc])}, :source "(defn\n pprint-tab\n \"Tab at this point in the pretty printing stream. kind specifies whether the tab\\nis :line, :section, :line-relative, or :section-relative.\\n\\nColnum and colinc specify the target column and the increment to move the target\\nforward if the output is already past the original target.\\n\\nThis function is intended for use when writing custom dispatch functions.\\n\\nOutput is sent to *out* which must be a pretty printing writer.\\n\\nTHIS FUNCTION IS NOT YET IMPLEMENTED.\"\n {:added \"1.2\"}\n [kind colnum colinc]\n (check-enumerated-arg\n  kind\n  #{:section :line :line-relative :section-relative})\n (throw (js/Error. \"pprint-tab is not yet implemented\")))\n"} {:sym pprint-set, :meta {}, :source "(def pprint-set (formatter-out \"~<#{~;~@{~w~^ ~:_~}~;}~:>\"))\n"} {:sym print-table, :meta {:doc "Prints a collection of maps in a textual table. Prints table headings\n   ks, and then a line of output for each row, corresponding to the keys\n   in ks. If ks are not specified, use the keys of the first item in rows.", :arglists [[ks rows] [rows]]}, :source "(defn\n print-table\n \"Prints a collection of maps in a textual table. Prints table headings\\n   ks, and then a line of output for each row, corresponding to the keys\\n   in ks. If ks are not specified, use the keys of the first item in rows.\"\n {:added \"1.3\"}\n ([ks rows]\n  (binding\n   [*print-newline*]\n   (when\n    (seq rows)\n    (let\n     [widths\n      (map\n       (fn\n        [k]\n        (apply\n         max\n         (count (str k))\n         (map\n          (fn* [p1__18456#] (count (str (get p1__18456# k))))\n          rows)))\n       ks)\n      spacers\n      (map\n       (fn* [p1__18457#] (apply str (repeat p1__18457# \"-\")))\n       widths)\n      fmt-row\n      (fn\n       [leader divider trailer row]\n       (str\n        leader\n        (apply\n         str\n         (interpose\n          divider\n          (for\n           [[col width]\n            (map\n             vector\n             (map (fn* [p1__18458#] (get row p1__18458#)) ks)\n             widths)]\n           (add-padding width (str col)))))\n        trailer))]\n     (cljs.core/println)\n     (cljs.core/println (fmt-row \"| \" \" | \" \" |\" (zipmap ks ks)))\n     (cljs.core/println (fmt-row \"|-\" \"-+-\" \"-|\" (zipmap ks spacers)))\n     (doseq\n      [row rows]\n      (cljs.core/println (fmt-row \"| \" \" | \" \" |\" row)))))))\n ([rows] (print-table (keys (first rows)) rows)))\n"} {:sym set-pprint-dispatch, :meta {:doc nil, :arglists ([function])}, :source "(defn\n set-pprint-dispatch\n [function]\n (set! *print-pprint-dispatch* function)\n nil)\n"} {:sym fresh-line, :meta {:doc "Make a newline if *out* is not already at the beginning of the line. If *out* is\nnot a pretty writer (which keeps track of columns), this function always outputs a newline.", :arglists ([])}, :source "(defn\n fresh-line\n \"Make a newline if *out* is not already at the beginning of the line. If *out* is\\nnot a pretty writer (which keeps track of columns), this function always outputs a newline.\"\n []\n (if\n  (satisfies? IDeref *out*)\n  (if (not (= 0 (get-column (:base @@*out*)))) (prn))\n  (prn)))\n"} {:sym pprint-indent, :meta {:doc "Create an indent at this point in the pretty printing stream. This defines how\nfollowing lines are indented. relative-to can be either :block or :current depending\nwhether the indent should be computed relative to the start of the logical block or\nthe current column position. n is an offset.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.", :arglists ([relative-to n])}, :source "(defn\n pprint-indent\n \"Create an indent at this point in the pretty printing stream. This defines how\\nfollowing lines are indented. relative-to can be either :block or :current depending\\nwhether the indent should be computed relative to the start of the logical block or\\nthe current column position. n is an offset.\\n\\nThis function is intended for use when writing custom dispatch functions.\\n\\nOutput is sent to *out* which must be a pretty printing writer.\"\n [relative-to n]\n (check-enumerated-arg relative-to #{:block :current})\n (indent *out* relative-to n))\n"} {:sym *print-radix*, :meta {:doc "Print a radix specifier in front of integers and rationals. If *print-base* is 2, 8,\nor 16, then the radix specifier used is #b, #o, or #x, respectively. Otherwise the\nradix specifier is in the form #XXr where XX is the decimal value of *print-base* "}, :source "(def *print-radix* nil)\n"} {:sym IPrettyFlush, :meta {:doc nil}, :methods (-ppflush)} {:sym cl-format, :meta {:doc "An implementation of a Common Lisp compatible format function. cl-format formats its\narguments to an output stream or string based on the format control string given. It\nsupports sophisticated formatting of structured data.\n\nWriter satisfies IWriter, true to output via *print-fn* or nil to output\nto a string, format-in is the format control string and the remaining arguments\nare the data to be formatted.\n\nThe format control string is a string to be output with embedded 'format directives'\ndescribing how to format the various arguments passed in.\n\nIf writer is nil, cl-format returns the formatted result string. Otherwise, cl-format\nreturns nil.\n\nFor example:\n (let [results [46 38 22]]\n        (cl-format true \"There ~[are~;is~:;are~]~:* ~d result~:p: ~{~d~^, ~}~%\"\n                   (count results) results))\n\nPrints via *print-fn*:\n There are 3 results: 46, 38, 22\n\nDetailed documentation on format control strings is available in the \"Common Lisp the\nLanguage, 2nd edition\", Chapter 22 (available online at:\nhttp://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000)\nand in the Common Lisp HyperSpec at\nhttp://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm", :arglists ([writer format-in & args])}, :source "(defn\n cl-format\n \"An implementation of a Common Lisp compatible format function. cl-format formats its\\narguments to an output stream or string based on the format control string given. It\\nsupports sophisticated formatting of structured data.\\n\\nWriter satisfies IWriter, true to output via *print-fn* or nil to output\\nto a string, format-in is the format control string and the remaining arguments\\nare the data to be formatted.\\n\\nThe format control string is a string to be output with embedded 'format directives'\\ndescribing how to format the various arguments passed in.\\n\\nIf writer is nil, cl-format returns the formatted result string. Otherwise, cl-format\\nreturns nil.\\n\\nFor example:\\n (let [results [46 38 22]]\\n        (cl-format true \\\"There ~[are~;is~:;are~]~:* ~d result~:p: ~{~d~^, ~}~%\\\"\\n                   (count results) results))\\n\\nPrints via *print-fn*:\\n There are 3 results: 46, 38, 22\\n\\nDetailed documentation on format control strings is available in the \\\"Common Lisp the\\nLanguage, 2nd edition\\\", Chapter 22 (available online at:\\nhttp://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000)\\nand in the Common Lisp HyperSpec at\\nhttp://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm\"\n {:see-also\n  [[\"http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000\"\n    \"Common Lisp the Language\"]\n   [\"http://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm\"\n    \"Common Lisp HyperSpec\"]]}\n [writer format-in & args]\n (let\n  [compiled-format\n   (if (string? format-in) (compile-format format-in) format-in)\n   navigator\n   (init-navigator args)]\n  (execute-format writer compiled-format navigator)))\n"} {:sym *print-miser-width*, :meta {:doc "The column at which to enter miser style. Depending on the dispatch table,\nmiser style add newlines in more places to try to keep lines short allowing for further\nlevels of nesting."}, :source "(def *print-miser-width* 40)\n"} {:sym write, :meta {:doc "Write an object subject to the current bindings of the printer control variables.\nUse the kw-args argument to override individual variables for this call (and any\nrecursive calls). Returns the string result if :stream is nil or nil otherwise.\n\nThe following keyword arguments can be passed with values:\n  Keyword              Meaning                              Default value\n  :stream              Writer for output or nil             true (indicates *out*)\n  :base                Base to use for writing rationals    Current value of *print-base*\n  :circle*             If true, mark circular structures    Current value of *print-circle*\n  :length              Maximum elements to show in sublists Current value of *print-length*\n  :level               Maximum depth                        Current value of *print-level*\n  :lines*              Maximum lines of output              Current value of *print-lines*\n  :miser-width         Width to enter miser mode            Current value of *print-miser-width*\n  :dispatch            The pretty print dispatch function   Current value of *print-pprint-dispatch*\n  :pretty              If true, do pretty printing          Current value of *print-pretty*\n  :radix               If true, prepend a radix specifier   Current value of *print-radix*\n  :readably*           If true, print readably              Current value of *print-readably*\n  :right-margin        The column for the right margin      Current value of *print-right-margin*\n  :suppress-namespaces If true, no namespaces in symbols    Current value of *print-suppress-namespaces*\n\n  * = not yet supported\n", :arglists ([object & kw-args])}, :source "(defn\n write\n \"Write an object subject to the current bindings of the printer control variables.\\nUse the kw-args argument to override individual variables for this call (and any\\nrecursive calls). Returns the string result if :stream is nil or nil otherwise.\\n\\nThe following keyword arguments can be passed with values:\\n  Keyword              Meaning                              Default value\\n  :stream              Writer for output or nil             true (indicates *out*)\\n  :base                Base to use for writing rationals    Current value of *print-base*\\n  :circle*             If true, mark circular structures    Current value of *print-circle*\\n  :length              Maximum elements to show in sublists Current value of *print-length*\\n  :level               Maximum depth                        Current value of *print-level*\\n  :lines*              Maximum lines of output              Current value of *print-lines*\\n  :miser-width         Width to enter miser mode            Current value of *print-miser-width*\\n  :dispatch            The pretty print dispatch function   Current value of *print-pprint-dispatch*\\n  :pretty              If true, do pretty printing          Current value of *print-pretty*\\n  :radix               If true, prepend a radix specifier   Current value of *print-radix*\\n  :readably*           If true, print readably              Current value of *print-readably*\\n  :right-margin        The column for the right margin      Current value of *print-right-margin*\\n  :suppress-namespaces If true, no namespaces in symbols    Current value of *print-suppress-namespaces*\\n\\n  * = not yet supported\\n\"\n [object & kw-args]\n (let\n  [options (merge {:stream true} (apply hash-map kw-args))]\n  (binding\n   [cljs.pprint/*print-base*\n    (:base options cljs.pprint/*print-base*)\n    cljs.pprint/*print-circle*\n    (:circle options cljs.pprint/*print-circle*)\n    cljs.core/*print-length*\n    (:length options cljs.core/*print-length*)\n    cljs.core/*print-level*\n    (:level options cljs.core/*print-level*)\n    cljs.pprint/*print-lines*\n    (:lines options cljs.pprint/*print-lines*)\n    cljs.pprint/*print-miser-width*\n    (:miser-width options cljs.pprint/*print-miser-width*)\n    cljs.pprint/*print-pprint-dispatch*\n    (:dispatch options cljs.pprint/*print-pprint-dispatch*)\n    cljs.pprint/*print-pretty*\n    (:pretty options cljs.pprint/*print-pretty*)\n    cljs.pprint/*print-radix*\n    (:radix options cljs.pprint/*print-radix*)\n    cljs.core/*print-readably*\n    (:readably options cljs.core/*print-readably*)\n    cljs.pprint/*print-right-margin*\n    (:right-margin options cljs.pprint/*print-right-margin*)\n    cljs.pprint/*print-suppress-namespaces*\n    (:suppress-namespaces\n     options\n     cljs.pprint/*print-suppress-namespaces*)]\n   (binding\n    []\n    (let\n     [sb\n      (StringBuffer.)\n      optval\n      (if (contains? options :stream) (:stream options) true)\n      base-writer\n      (if\n       (or (true? optval) (nil? optval))\n       (StringBufferWriter. sb)\n       optval)]\n     (if\n      *print-pretty*\n      (with-pretty-writer base-writer (write-out object))\n      (binding [*out* base-writer] (pr object)))\n     (if (true? optval) (string-print (str sb)))\n     (if (nil? optval) (str sb)))))))\n"} {:sym -ppflush, :meta {:doc nil, :arglists ([pp])}, :protocol IPrettyFlush} {:sym *print-right-margin*, :meta {:doc "Pretty printing will try to avoid anything going beyond this column.\nSet it to nil to have pprint let the line be arbitrarily long. This will ignore all\nnon-mandatory newlines."}, :source "(def *print-right-margin* 72)\n"} {:sym write-out, :meta {:doc "Write an object to *out* subject to the current bindings of the printer control\nvariables. Use the kw-args argument to override individual variables for this call (and\nany recursive calls).\n\n*out* must be a PrettyWriter if pretty printing is enabled. This is the responsibility\nof the caller.\n\nThis method is primarily intended for use by pretty print dispatch functions that\nalready know that the pretty printer will have set up their environment appropriately.\nNormal library clients should use the standard \"write\" interface. ", :arglists ([object])}, :source "(defn\n write-out\n \"Write an object to *out* subject to the current bindings of the printer control\\nvariables. Use the kw-args argument to override individual variables for this call (and\\nany recursive calls).\\n\\n*out* must be a PrettyWriter if pretty printing is enabled. This is the responsibility\\nof the caller.\\n\\nThis method is primarily intended for use by pretty print dispatch functions that\\nalready know that the pretty printer will have set up their environment appropriately.\\nNormal library clients should use the standard \\\"write\\\" interface. \"\n [object]\n (let\n  [length-reached\n   (and\n    *current-length*\n    *print-length*\n    (>= *current-length* *print-length*))]\n  (if-not\n   *print-pretty*\n   (pr object)\n   (if\n    length-reached\n    (-write *out* \"...\")\n    (do\n     (if\n      *current-length*\n      (set! *current-length* (inc *current-length*)))\n     (*print-pprint-dispatch* object))))\n  length-reached))\n"} {:sym *print-base*, :meta {:doc "The base to use for printing integers and rationals."}, :source "(def *print-base* 10)\n"}), cljs.tools.reader.impl.utils ({:sym reader-conditional, :meta {:doc "Construct a data representation of a reader conditional.\n  If true, splicing? indicates read-cond-splicing.", :arglists ([form splicing?])}, :source "(defn\n reader-conditional\n \"Construct a data representation of a reader conditional.\\n  If true, splicing? indicates read-cond-splicing.\"\n [form splicing?]\n (ReaderConditional. splicing? form))\n"} {:sym whitespace?, :meta {:doc "Checks whether a given character is whitespace", :arglists ([ch])}, :source "(defn\n whitespace?\n \"Checks whether a given character is whitespace\"\n [ch]\n (when-not (nil? ch) (if (identical? ch \\,) true (.test ws-rx ch))))\n"} {:sym last-id, :meta {}, :source "(def last-id (atom 0))\n"} {:sym char, :meta {:doc nil, :arglists ([x])}, :source "(defn char [x] (when-not (nil? x) (cljs.core/char x)))\n"} {:sym numeric?, :meta {:doc "Checks whether a given character is numeric", :arglists ([ch])}, :source "(defn\n numeric?\n \"Checks whether a given character is numeric\"\n [ch]\n (when-not (nil? ch) (gstring/isNumeric ch)))\n"} {:sym second', :meta {:doc nil, :arglists ([[a b]])}, :source "(defn second' [[a b]] (when-not a b))\n"} {:sym desugar-meta, :meta {:doc "Resolves syntactical sugar in metadata", :arglists ([f])}, :source "(defn\n desugar-meta\n \"Resolves syntactical sugar in metadata\"\n [f]\n (cond\n  (keyword? f)\n  {f true}\n  (symbol? f)\n  {:tag f}\n  (string? f)\n  {:tag f}\n  :else\n  f))\n"} {:sym next-id, :meta {:doc nil, :arglists ([])}, :source "(defn next-id [] (swap! last-id inc))\n"} {:sym ex-info?, :meta {:doc nil, :arglists ([ex])}, :source "(defn ex-info? [ex] (instance? cljs.core.ExceptionInfo ex))\n"} {:sym reader-conditional?, :meta {:doc "Return true if the value is the data representation of a reader conditional", :arglists ([value])}, :source "(defn\n reader-conditional?\n \"Return true if the value is the data representation of a reader conditional\"\n [value]\n (instance? ReaderConditional value))\n"} {:sym newline?, :meta {:doc "Checks whether the character is a newline", :arglists ([c])}, :source "(defn\n newline?\n \"Checks whether the character is a newline\"\n [c]\n (or (identical? \\newline c) (identical? \"\\n\" c) (nil? c)))\n"} {:sym namespace-keys, :meta {:doc nil, :arglists ([ns keys])}, :source "(defn\n namespace-keys\n [ns keys]\n (for\n  [key keys]\n  (if\n   (or (symbol? key) (keyword? key))\n   (let\n    [[key-ns key-name]\n     ((juxt namespace name) key)\n     ->key\n     (if (symbol? key) symbol keyword)]\n    (cond\n     (nil? key-ns)\n     (->key ns key-name)\n     (= \"_\" key-ns)\n     (->key key-name)\n     :else\n     key))\n   key)))\n"} {:sym ws-rx, :meta {}, :source "(def ws-rx #\"[\\s]\")\n"}), cljs.source-map ({:sym update-result, :meta {:doc "Helper for decode. Take a source map and update it based on a\n  segment map.", :arglists ([result segmap gline])}, :source "(defn\n update-result\n \"Helper for decode. Take a source map and update it based on a\\n  segment map.\"\n [result segmap gline]\n (let\n  [{:keys [gcol source line col name]}\n   segmap\n   d\n   {:line line, :col col, :source source}\n   d\n   (if name (assoc d :name name) d)]\n  (update-in\n   result\n   [gline]\n   (fnil\n    (fn\n     [m]\n     (update-in\n      m\n      [gcol]\n      (fnil (fn* [p1__18459#] (conj p1__18459# d)) [])))\n    (sorted-map)))))\n"} {:sym invert-reverse-map, :meta {:doc "Given a ClojureScript to JavaScript source map, invert it. Useful when\n   mapping JavaScript stack traces when environment support is unavailable.", :arglists ([reverse-map])}, :source "(defn\n invert-reverse-map\n \"Given a ClojureScript to JavaScript source map, invert it. Useful when\\n   mapping JavaScript stack traces when environment support is unavailable.\"\n [reverse-map]\n (let\n  [inverted (atom (sorted-map))]\n  (doseq\n   [[line columns] reverse-map]\n   (doseq\n    [[column column-info] columns]\n    (doseq\n     [{:keys [gline gcol name]} column-info]\n     (swap!\n      inverted\n      update-in\n      [gline]\n      (fnil\n       (fn\n        [columns]\n        (update-in\n         columns\n         [gcol]\n         (fnil conj [])\n         {:line line, :col column, :name name}))\n       (sorted-map))))))\n  @inverted))\n"} {:sym decode, :meta {:doc "Convert a v3 source map JSON object into a source map mapping\n  generated JavaScript source locations to the original\n  ClojureScript.", :arglists [[source-map] [mappings source-map]]}, :source "(defn\n decode\n \"Convert a v3 source map JSON object into a source map mapping\\n  generated JavaScript source locations to the original\\n  ClojureScript.\"\n ([source-map] (decode (gobj/get source-map \"mappings\") source-map))\n ([mappings source-map]\n  (let\n   [sources\n    (gobj/get source-map \"sources\")\n    relseg-init\n    [0 0 0 0 0]\n    lines\n    (seq (string/split mappings #\";\"))]\n   (loop\n    [gline 0 lines lines relseg relseg-init result {}]\n    (if\n     lines\n     (let\n      [line\n       (first lines)\n       [result relseg]\n       (if\n        (string/blank? line)\n        [result relseg]\n        (let\n         [segs (seq (string/split line #\",\"))]\n         (loop\n          [segs segs relseg relseg result result]\n          (if\n           segs\n           (let\n            [seg\n             (first segs)\n             nrelseg\n             (seg-combine (base64-vlq/decode seg) relseg)]\n            (recur\n             (next segs)\n             nrelseg\n             (update-result\n              result\n              (seg->map nrelseg source-map)\n              gline)))\n           [result relseg]))))]\n      (recur (inc gline) (next lines) (assoc relseg 0 0) result))\n     result)))))\n"} {:sym seg->map, :meta {:doc "Take a source map segment represented as a vector\n   and return a map.", :arglists ([seg source-map])}, :source "(defn\n seg->map\n \"Take a source map segment represented as a vector\\n   and return a map.\"\n [seg source-map]\n (let\n  [[gcol source line col name] seg]\n  {:gcol gcol,\n   :source (aget (gobj/get source-map \"sources\") source),\n   :line line,\n   :col col,\n   :name\n   (when-let\n    [name (-> seg meta :name)]\n    (aget (gobj/get source-map \"names\") name))}))\n"} {:sym source-compare, :meta {:doc "Take a seq of source file names and return a comparator\n   that can be used to construct a sorted map. For reverse\n   source maps.", :arglists ([sources])}, :source "(defn\n source-compare\n \"Take a seq of source file names and return a comparator\\n   that can be used to construct a sorted map. For reverse\\n   source maps.\"\n [sources]\n (let\n  [sources (indexed-sources sources)]\n  (fn [a b] (compare (sources a) (sources b)))))\n"} {:sym decode-reverse, :meta {:doc "Convert a v3 source map JSON object into a reverse source map\n  mapping original ClojureScript source locations to the generated\n  JavaScript.", :arglists [[source-map] [mappings source-map]]}, :source "(defn\n decode-reverse\n \"Convert a v3 source map JSON object into a reverse source map\\n  mapping original ClojureScript source locations to the generated\\n  JavaScript.\"\n ([source-map]\n  (decode-reverse (gobj/get source-map \"mappings\") source-map))\n ([mappings source-map]\n  (let\n   [sources\n    (gobj/get source-map \"sources\")\n    relseg-init\n    [0 0 0 0 0]\n    lines\n    (seq (string/split mappings #\";\"))]\n   (loop\n    [gline\n     0\n     lines\n     lines\n     relseg\n     relseg-init\n     result\n     (sorted-map-by (source-compare sources))]\n    (if\n     lines\n     (let\n      [line\n       (first lines)\n       [result relseg]\n       (if\n        (string/blank? line)\n        [result relseg]\n        (let\n         [segs (seq (string/split line #\",\"))]\n         (loop\n          [segs segs relseg relseg result result]\n          (if\n           segs\n           (let\n            [seg\n             (first segs)\n             nrelseg\n             (seg-combine (base64-vlq/decode seg) relseg)]\n            (recur\n             (next segs)\n             nrelseg\n             (update-reverse-result\n              result\n              (seg->map nrelseg source-map)\n              gline)))\n           [result relseg]))))]\n      (recur (inc gline) (next lines) (assoc relseg 0 0) result))\n     result)))))\n"} {:sym lines->segs, :meta {:doc "Take a nested sorted map encoding line and column information\n   for a file and return a vector of vectors of encoded segments.\n   Each vector represents a line, and the internal vectors are segments\n   representing the contents of the line.", :arglists ([lines])}, :source "(defn\n lines->segs\n \"Take a nested sorted map encoding line and column information\\n   for a file and return a vector of vectors of encoded segments.\\n   Each vector represents a line, and the internal vectors are segments\\n   representing the contents of the line.\"\n [lines]\n (let\n  [relseg (atom [0 0 0 0 0])]\n  (reduce\n   (fn\n    [segs cols]\n    (swap!\n     relseg\n     (fn [[_ source line col name]] [0 source line col name]))\n    (conj\n     segs\n     (reduce\n      (fn\n       [cols [gcol sidx line col name :as seg]]\n       (let\n        [offset (map - seg @relseg)]\n        (swap!\n         relseg\n         (fn [[_ _ _ _ lname]] [gcol sidx line col (or name lname)]))\n        (conj cols (base64-vlq/encode offset))))\n      []\n      cols)))\n   []\n   lines)))\n"} {:sym merge-source-maps, :meta {:doc "Merge an internal source map representation of a single\n   ClojureScript file mapping original to generated with a\n   second source map mapping original JS to generated JS.\n   The is to support source maps that work through multiple\n   compilation steps like Google Closure optimization passes.", :arglists ([cljs-map js-map])}, :source "(defn\n merge-source-maps\n \"Merge an internal source map representation of a single\\n   ClojureScript file mapping original to generated with a\\n   second source map mapping original JS to generated JS.\\n   The is to support source maps that work through multiple\\n   compilation steps like Google Closure optimization passes.\"\n [cljs-map js-map]\n (loop\n  [line-map-seq (seq cljs-map) new-lines (sorted-map)]\n  (if\n   line-map-seq\n   (let\n    [[line col-map]\n     (first line-map-seq)\n     new-cols\n     (loop\n      [col-map-seq (seq col-map) new-cols (sorted-map)]\n      (if\n       col-map-seq\n       (let\n        [[col infos] (first col-map-seq)]\n        (recur\n         (next col-map-seq)\n         (assoc\n          new-cols\n          col\n          (reduce\n           (fn\n            [v {:keys [gline gcol]}]\n            (into v (get-in js-map [gline gcol])))\n           []\n           infos))))\n       new-cols))]\n    (recur (next line-map-seq) (assoc new-lines line new-cols)))\n   new-lines)))\n"} {:sym update-reverse-result, :meta {:doc "Helper for decode-reverse. Take a reverse source map and\n  update it with a segment map.", :arglists ([result segmap gline])}, :source "(defn\n update-reverse-result\n \"Helper for decode-reverse. Take a reverse source map and\\n  update it with a segment map.\"\n [result segmap gline]\n (let\n  [{:keys [gcol source line col name]}\n   segmap\n   d\n   {:gline gline, :gcol gcol}\n   d\n   (if name (assoc d :name name) d)]\n  (update-in\n   result\n   [source]\n   (fnil\n    (fn\n     [m]\n     (update-in\n      m\n      [line]\n      (fnil\n       (fn [m] (update-in m [col] (fnil (fn [v] (conj v d)) [])))\n       (sorted-map))))\n    (sorted-map)))))\n"} {:sym indexed-sources, :meta {:doc "Take a seq of source file names and return a map from\n   file number to integer index. For reverse source maps.", :arglists ([sources])}, :source "(defn\n indexed-sources\n \"Take a seq of source file names and return a map from\\n   file number to integer index. For reverse source maps.\"\n [sources]\n (->>\n  sources\n  (map-indexed (fn [a b] [a b]))\n  (reduce (fn [m [i v]] (assoc m v i)) {})))\n"} {:sym seg-combine, :meta {:doc "Combine a source map segment vector and a relative\n   source map segment vector and combine them to get\n   an absolute segment posititon information as a vector.", :arglists ([seg relseg])}, :source "(defn\n seg-combine\n \"Combine a source map segment vector and a relative\\n   source map segment vector and combine them to get\\n   an absolute segment posititon information as a vector.\"\n [seg relseg]\n (let\n  [[gcol source line col name]\n   seg\n   [rgcol rsource rline rcol rname]\n   relseg\n   nseg\n   [(+ gcol rgcol)\n    (+ (or source 0) rsource)\n    (+ (or line 0) rline)\n    (+ (or col 0) rcol)\n    (+ (or name 0) rname)]]\n  (if name (with-meta nseg {:name (+ name rname)}) nseg)))\n"}), cljs.repl ({:sym print-doc, :meta {:doc nil, :arglists ([{n :ns, nm :name, :as m}])}, :source "(defn\n print-doc\n [{n :ns, nm :name, :as m}]\n (println \"-------------------------\")\n (println (str (when-let [ns (:ns m)] (str ns \"/\")) (:name m)))\n (when (:protocol m) (println \"Protocol\"))\n (cond\n  (:forms m)\n  (doseq [f (:forms m)] (println \"  \" f))\n  (:arglists m)\n  (let\n   [arglists (:arglists m)]\n   (if\n    (or (:macro m) (:repl-special-function m))\n    (prn arglists)\n    (prn\n     (if (= 'quote (first arglists)) (second arglists) arglists)))))\n (if\n  (:special-form m)\n  (do\n   (println \"Special Form\")\n   (println \" \" (:doc m))\n   (if\n    (contains? m :url)\n    (when\n     (:url m)\n     (println (str \"\\n  Please see http://clojure.org/\" (:url m))))\n    (println\n     (str\n      \"\\n  Please see http://clojure.org/special_forms#\"\n      (:name m)))))\n  (do\n   (when (:macro m) (println \"Macro\"))\n   (when (:repl-special-function m) (println \"REPL Special Function\"))\n   (println \" \" (:doc m))\n   (when\n    (:protocol m)\n    (doseq\n     [[name {:keys [doc arglists]}] (:methods m)]\n     (println)\n     (println \" \" name)\n     (println \" \" arglists)\n     (when doc (println \" \" doc))))\n   (when\n    n\n    (when-let\n     [fnspec (spec/get-spec (symbol (str (ns-name n)) (name nm)))]\n     (print \"Spec\")\n     (doseq\n      [role [:args :ret :fn]]\n      (when-let\n       [spec (get fnspec role)]\n       (print (str \"\\n \" (name role) \":\") (spec/describe spec)))))))))\n"}), cljs.core.async.impl.ioc-helpers ({:sym EXCEPTION-FRAMES, :meta {}, :source "(def EXCEPTION-FRAMES 4)\n"} {:sym process-exception, :meta {:doc nil, :arglists ([state])}, :source "(defn\n process-exception\n [state]\n (let\n  [exception-frame\n   (aget-object state EXCEPTION-FRAMES)\n   catch-block\n   (:catch-block exception-frame)\n   catch-exception\n   (:catch-exception exception-frame)\n   exception\n   (aget-object state CURRENT-EXCEPTION)]\n  (cond\n   (and exception (not exception-frame))\n   (throw exception)\n   (and\n    exception\n    catch-block\n    (or\n     (= :default catch-exception)\n     (instance? catch-exception exception)))\n   (ioc/aset-all!\n    state\n    STATE-IDX\n    catch-block\n    VALUE-IDX\n    exception\n    CURRENT-EXCEPTION\n    nil\n    EXCEPTION-FRAMES\n    (assoc exception-frame :catch-block nil :catch-exception nil))\n   (and\n    exception\n    (not catch-block)\n    (not (:finally-block exception-frame)))\n   (do\n    (ioc/aset-all! state EXCEPTION-FRAMES (:prev exception-frame))\n    (recur state))\n   (and exception (not catch-block) (:finally-block exception-frame))\n   (ioc/aset-all!\n    state\n    STATE-IDX\n    (:finally-block exception-frame)\n    EXCEPTION-FRAMES\n    (assoc exception-frame :finally-block nil))\n   (and (not exception) (:finally-block exception-frame))\n   (do\n    (ioc/aset-all!\n     state\n     STATE-IDX\n     (:finally-block exception-frame)\n     EXCEPTION-FRAMES\n     (assoc exception-frame :finally-block nil)))\n   (and (not exception) (not (:finally-block exception-frame)))\n   (do\n    (ioc/aset-all!\n     state\n     STATE-IDX\n     (:continue-block exception-frame)\n     EXCEPTION-FRAMES\n     (:prev exception-frame)))\n   :else\n   (throw (js/Error. \"No matching clause\")))))\n"} {:sym STATE-IDX, :meta {}, :source "(def STATE-IDX 1)\n"} {:sym aset-object, :meta {:doc nil, :arglists ([arr idx o])}, :source "(defn aset-object [arr idx o] (aget arr idx o))\n"} {:sym add-exception-frame, :meta {:doc nil, :arglists ([state catch-block catch-exception finally-block continue-block])}, :source "(defn\n add-exception-frame\n [state catch-block catch-exception finally-block continue-block]\n (ioc/aset-all!\n  state\n  EXCEPTION-FRAMES\n  (->ExceptionFrame\n   catch-block\n   catch-exception\n   finally-block\n   continue-block\n   (aget-object state EXCEPTION-FRAMES))))\n"} {:sym run-state-machine-wrapped, :meta {:doc nil, :arglists ([state])}, :source "(defn\n run-state-machine-wrapped\n [state]\n (try\n  (run-state-machine state)\n  (catch\n   js/Object\n   ex\n   (impl/close! (aget-object state USER-START-IDX))\n   (throw ex))))\n"} {:sym FN-IDX, :meta {}, :source "(def FN-IDX 0)\n"} {:sym aget-object, :meta {:doc nil, :arglists ([arr idx])}, :source "(defn aget-object [arr idx] (aget arr idx))\n"} {:sym return-chan, :meta {:doc nil, :arglists ([state value])}, :source "(defn\n return-chan\n [state value]\n (let\n  [c (aget state USER-START-IDX)]\n  (when-not (nil? value) (impl/put! c value (fn-handler (fn [] nil))))\n  (impl/close! c)\n  c))\n"} {:sym BINDINGS-IDX, :meta {}, :source "(def BINDINGS-IDX 3)\n"} {:sym CURRENT-EXCEPTION, :meta {}, :source "(def CURRENT-EXCEPTION 5)\n"} {:sym run-state-machine, :meta {:doc nil, :arglists ([state])}, :source "(defn run-state-machine [state] ((aget-object state FN-IDX) state))\n"} {:sym finished?, :meta {:doc "Returns true if the machine is in a finished state", :arglists ([state-array])}, :source "(defn\n finished?\n \"Returns true if the machine is in a finished state\"\n [state-array]\n (keyword-identical? (aget state-array STATE-IDX) :finished))\n"} {:sym USER-START-IDX, :meta {}, :source "(def USER-START-IDX 6)\n"} {:sym put!, :meta {:doc nil, :arglists ([state blk c val])}, :source "(defn\n put!\n [state blk c val]\n (if-let\n  [cb\n   (impl/put!\n    c\n    val\n    (fn-handler\n     (fn\n      [ret-val]\n      (ioc/aset-all! state VALUE-IDX ret-val STATE-IDX blk)\n      (run-state-machine-wrapped state))))]\n  (do (ioc/aset-all! state VALUE-IDX @cb STATE-IDX blk) :recur)\n  nil))\n"} {:sym take!, :meta {:doc nil, :arglists ([state blk c])}, :source "(defn\n take!\n [state blk c]\n (if-let\n  [cb\n   (impl/take!\n    c\n    (fn-handler\n     (fn\n      [x]\n      (ioc/aset-all! state VALUE-IDX x STATE-IDX blk)\n      (run-state-machine-wrapped state))))]\n  (do (ioc/aset-all! state VALUE-IDX @cb STATE-IDX blk) :recur)\n  nil))\n"} {:sym VALUE-IDX, :meta {}, :source "(def VALUE-IDX 2)\n"}), clojure.string ({:sym ends-with?, :meta {:doc "True if s ends with substr.", :arglists ([s substr])}, :source "(defn\n ends-with?\n \"True if s ends with substr.\"\n [s substr]\n (gstring/endsWith s substr))\n"} {:sym capitalize, :meta {:doc "Converts first character of the string to upper-case, all other\n  characters to lower-case.", :arglists ([s])}, :source "(defn\n capitalize\n \"Converts first character of the string to upper-case, all other\\n  characters to lower-case.\"\n [s]\n (gstring/capitalize s))\n"} {:sym reverse, :meta {:doc "Returns s with its characters reversed.", :arglists ([s])}, :source "(defn\n reverse\n \"Returns s with its characters reversed.\"\n [s]\n (->\n  (.replace s re-surrogate-pair \"$2$1\")\n  (.. (split \"\") (reverse) (join \"\"))))\n"} {:sym join, :meta {:doc "Returns a string of all elements in coll, as returned by (seq coll),\n  separated by an optional separator.", :arglists [[coll] [separator coll]]}, :source "(defn\n join\n \"Returns a string of all elements in coll, as returned by (seq coll),\\n  separated by an optional separator.\"\n ([coll]\n  (loop\n   [sb (StringBuffer.) coll (seq coll)]\n   (if-not\n    (nil? coll)\n    (recur (. sb (append (str (first coll)))) (next coll))\n    (.toString sb))))\n ([separator coll]\n  (loop\n   [sb (StringBuffer.) coll (seq coll)]\n   (if-not\n    (nil? coll)\n    (do\n     (. sb (append (str (first coll))))\n     (let\n      [coll (next coll)]\n      (when-not (nil? coll) (. sb (append separator)))\n      (recur sb coll)))\n    (.toString sb)))))\n"} {:sym replace-first, :meta {:doc "Replaces the first instance of match with replacement in s.\n   match/replacement can be:\n\n   string / string\n   pattern / (string or function of match).", :arglists ([s match replacement])}, :source "(defn\n replace-first\n \"Replaces the first instance of match with replacement in s.\\n   match/replacement can be:\\n\\n   string / string\\n   pattern / (string or function of match).\"\n [s match replacement]\n (.replace s match replacement))\n"} {:sym starts-with?, :meta {:doc "True if s starts with substr.", :arglists ([s substr])}, :source "(defn\n starts-with?\n \"True if s starts with substr.\"\n [s substr]\n (gstring/startsWith s substr))\n"} {:sym escape, :meta {:doc "Return a new string, using cmap to escape each character ch\n   from s as follows:\n\n   If (cmap ch) is nil, append ch to the new string.\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead.", :arglists ([s cmap])}, :source "(defn\n escape\n \"Return a new string, using cmap to escape each character ch\\n   from s as follows:\\n\\n   If (cmap ch) is nil, append ch to the new string.\\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead.\"\n [s cmap]\n (let\n  [buffer (StringBuffer.) length (.-length s)]\n  (loop\n   [index 0]\n   (if\n    (== length index)\n    (. buffer (toString))\n    (let\n     [ch (.charAt s index) replacement (get cmap ch)]\n     (if-not\n      (nil? replacement)\n      (.append buffer (str replacement))\n      (.append buffer ch))\n     (recur (inc index)))))))\n"} {:sym last-index-of, :meta {:doc "Return last index of value (string or char) in s, optionally\n  searching backward from from-index or nil if not found.", :arglists [[s value] [s value from-index]]}, :source "(defn\n last-index-of\n \"Return last index of value (string or char) in s, optionally\\n  searching backward from from-index or nil if not found.\"\n ([s value]\n  (let [result (.lastIndexOf s value)] (if (neg? result) nil result)))\n ([s value from-index]\n  (let\n   [result (.lastIndexOf s value from-index)]\n   (if (neg? result) nil result))))\n"} {:sym includes?, :meta {:doc "True if s includes substr.", :arglists ([s substr])}, :source "(defn\n includes?\n \"True if s includes substr.\"\n [s substr]\n (gstring/contains s substr))\n"} {:sym replace, :meta {:doc "Replaces all instance of match with replacement in s.\n   match/replacement can be:\n\n   string / string\n   pattern / (string or function of match).", :arglists ([s match replacement])}, :source "(defn\n replace\n \"Replaces all instance of match with replacement in s.\\n   match/replacement can be:\\n\\n   string / string\\n   pattern / (string or function of match).\"\n [s match replacement]\n (cond\n  (string? match)\n  (.replace\n   s\n   (js/RegExp. (gstring/regExpEscape match) \"g\")\n   replacement)\n  (instance? js/RegExp match)\n  (if\n   (string? replacement)\n   (replace-all s match replacement)\n   (replace-all s match (replace-with replacement)))\n  :else\n  (throw (str \"Invalid match arg: \" match))))\n"} {:sym split-lines, :meta {:doc "Splits s on \n or \r\n.", :arglists ([s])}, :source "(defn split-lines \"Splits s on \\n or \\r\\n.\" [s] (split s #\"\\n|\\r\\n\"))\n"} {:sym lower-case, :meta {:doc "Converts string to all lower-case.", :arglists ([s])}, :source "(defn\n lower-case\n \"Converts string to all lower-case.\"\n [s]\n (.toLowerCase s))\n"} {:sym trim-newline, :meta {:doc "Removes all trailing newline \\n or return \\r characters from\n  string.  Similar to Perl's chomp.", :arglists ([s])}, :source "(defn\n trim-newline\n \"Removes all trailing newline \\\\n or return \\\\r characters from\\n  string.  Similar to Perl's chomp.\"\n [s]\n (loop\n  [index (.-length s)]\n  (if\n   (zero? index)\n   \"\"\n   (let\n    [ch (get s (dec index))]\n    (if\n     (or (identical? \\newline ch) (identical? \\return ch))\n     (recur (dec index))\n     (.substring s 0 index))))))\n"} {:sym upper-case, :meta {:doc "Converts string to all upper-case.", :arglists ([s])}, :source "(defn\n upper-case\n \"Converts string to all upper-case.\"\n [s]\n (.toUpperCase s))\n"} {:sym split, :meta {:doc "Splits string on a regular expression. Optional argument limit is\n  the maximum number of splits. Not lazy. Returns vector of the splits.", :arglists [[s re] [s re limit]]}, :source "(defn\n split\n \"Splits string on a regular expression. Optional argument limit is\\n  the maximum number of splits. Not lazy. Returns vector of the splits.\"\n ([s re] (split s re 0))\n ([s re limit]\n  (discard-trailing-if-needed\n   limit\n   (if\n    (identical? \"/(?:)/\" (str re))\n    (split-with-empty-regex s limit)\n    (if\n     (< limit 1)\n     (vec (.split (str s) re))\n     (loop\n      [s s limit limit parts []]\n      (if\n       (== 1 limit)\n       (conj parts s)\n       (let\n        [m (re-find re s)]\n        (if-not\n         (nil? m)\n         (let\n          [index (.indexOf s m)]\n          (recur\n           (.substring s (+ index (count m)))\n           (dec limit)\n           (conj parts (.substring s 0 index))))\n         (conj parts s))))))))))\n"} {:sym trimr, :meta {:doc "Removes whitespace from the right side of string.", :arglists ([s])}, :source "(defn\n trimr\n \"Removes whitespace from the right side of string.\"\n [s]\n (gstring/trimRight s))\n"} {:sym index-of, :meta {:doc "Return index of value (string or char) in s, optionally searching\n  forward from from-index or nil if not found.", :arglists [[s value] [s value from-index]]}, :source "(defn\n index-of\n \"Return index of value (string or char) in s, optionally searching\\n  forward from from-index or nil if not found.\"\n ([s value]\n  (let [result (.indexOf s value)] (if (neg? result) nil result)))\n ([s value from-index]\n  (let\n   [result (.indexOf s value from-index)]\n   (if (neg? result) nil result))))\n"} {:sym trim, :meta {:doc "Removes whitespace from both ends of string.", :arglists ([s])}, :source "(defn\n trim\n \"Removes whitespace from both ends of string.\"\n [s]\n (gstring/trim s))\n"} {:sym triml, :meta {:doc "Removes whitespace from the left side of string.", :arglists ([s])}, :source "(defn\n triml\n \"Removes whitespace from the left side of string.\"\n [s]\n (gstring/trimLeft s))\n"} {:sym blank?, :meta {:doc "True is s is nil, empty, or contains only whitespace.", :arglists ([s])}, :source "(defn\n blank?\n \"True is s is nil, empty, or contains only whitespace.\"\n [s]\n (gstring/isEmptySafe s))\n"}), cljs.spec.alpha ({:sym form, :meta {:doc "returns the spec as data", :arglists ([spec])}, :source "(defn form \"returns the spec as data\" [spec] (describe* (specize spec)))\n"} {:sym nilable-impl, :meta {:doc "Do not call this directly, use 'nilable'", :arglists ([form pred gfn])}, :source "(defn\n nilable-impl\n \"Do not call this directly, use 'nilable'\"\n [form pred gfn]\n (let\n  [spec (specize pred form)]\n  (reify\n   Specize\n   (specize* [s] s)\n   (specize* [s _] s)\n   Spec\n   (conform* [_ x] (if (nil? x) nil (conform* spec x)))\n   (unform* [_ x] (if (nil? x) nil (unform* spec x)))\n   (explain*\n    [_ path via in x]\n    (when-not\n     (c/or (pvalid? spec x) (nil? x))\n     (conj\n      (explain-1 form pred (conj path :clojure.core/pred) via in x)\n      {:path (conj path :clojure.core/nil),\n       :pred 'nil?,\n       :val x,\n       :via via,\n       :in in})))\n   (gen*\n    [_ overrides path rmap]\n    (if\n     gfn\n     (gfn)\n     (gen/frequency\n      [[1 (gen/delay (gen/return nil))]\n       [9\n        (gen/delay\n         (gensub\n          pred\n          overrides\n          (conj path :clojure.core/pred)\n          rmap\n          form))]])))\n   (with-gen* [_ gfn] (nilable-impl form pred gfn))\n   (describe*\n    [_]\n    (clojure.core/sequence\n     (clojure.core/seq\n      (clojure.core/concat\n       (clojure.core/list 'clojure.core/nilable)\n       (clojure.core/list (s/mres form)))))))))\n"} {:sym *recursion-limit*, :meta {}, :source "(def\n *recursion-limit*\n \"A soft limit on how many times a branching spec (or/alt/*/opt-keys/multi-spec)\\n  can be recursed through during generation. After this a\\n  non-recursive branch will be chosen.\"\n 4)\n"} {:sym *coll-error-limit*, :meta {}, :source "(def\n *coll-error-limit*\n \"The number of errors reported by explain in a collection spec'ed with 'every'\"\n 20)\n"} {:sym explain-printer, :meta {:doc "Default printer for explain-data. nil indicates a successful validation.", :arglists ([ed])}, :source "(defn\n explain-printer\n \"Default printer for explain-data. nil indicates a successful validation.\"\n [ed]\n (if\n  ed\n  (let\n   [problems\n    (sort-by\n     (fn* [p1__18463#] (- (count (:path p1__18463#))))\n     (:clojure.core/problems ed))]\n   (print\n    (with-out-str\n     (doseq\n      [{:keys [path pred val reason via in], :as prob} problems]\n      (when-not (empty? in) (print \"In:\" (pr-str in) \"\"))\n      (print \"val: \")\n      (pr val)\n      (print \" fails\")\n      (when-not (empty? via) (print \" spec:\" (pr-str (last via))))\n      (when-not (empty? path) (print \" at:\" (pr-str path)))\n      (print \" predicate: \")\n      (pr (abbrev pred))\n      (when reason (print \", \" reason))\n      (doseq\n       [[k v] prob]\n       (when-not\n        (#{:path :pred :via :val :reason :in} k)\n        (print \"\\n\\t\" (pr-str k) \" \")\n        (pr v)))\n      (newline))\n     (doseq\n      [[k v] ed]\n      (when-not\n       (#{:clojure.core/problems} k)\n       (print (pr-str k) \" \")\n       (pr v)\n       (newline))))))\n  (println \"Success!\")))\n"} {:sym Specize, :meta {:doc nil}, :methods (specize*)} {:sym alt-impl, :meta {:doc "Do not call this directly, use 'alt'", :arglists ([ks ps forms])}, :source "(defn\n alt-impl\n \"Do not call this directly, use 'alt'\"\n [ks ps forms]\n (assoc (alt* ps ks forms) :id (random-uuid)))\n"} {:sym def-impl, :meta {:doc "Do not call this directly, use 'def'", :arglists ([k form spec])}, :source "(defn\n def-impl\n \"Do not call this directly, use 'def'\"\n [k form spec]\n (assert\n  (c/and (ident? k) (namespace k))\n  \"k must be namespaced keyword or resolveable symbol\")\n (let\n  [spec\n   (if\n    (c/or (spec? spec) (regex? spec) (get @registry-ref spec))\n    spec\n    (spec-impl form spec nil nil))]\n  (swap! registry-ref assoc k (with-name spec k))\n  k))\n"} {:sym *explain-out*, :meta {}, :source "(def *explain-out* explain-printer)\n"} {:sym regex-spec-impl, :meta {:doc "Do not call this directly, use 'spec' with a regex op argument", :arglists ([re gfn])}, :source "(defn\n regex-spec-impl\n \"Do not call this directly, use 'spec' with a regex op argument\"\n [re gfn]\n (reify\n  Specize\n  (specize* [s] s)\n  (specize* [s _] s)\n  Spec\n  (conform*\n   [_ x]\n   (if\n    (c/or (nil? x) (coll? x))\n    (re-conform re (seq x))\n    :clojure.core/invalid))\n  (unform* [_ x] (op-unform re x))\n  (explain*\n   [_ path via in x]\n   (if\n    (c/or (nil? x) (coll? x))\n    (re-explain path via in re (seq x))\n    [{:path path, :pred (op-describe re), :val x, :via via, :in in}]))\n  (gen*\n   [_ overrides path rmap]\n   (if gfn (gfn) (re-gen re overrides path rmap (op-describe re))))\n  (with-gen* [_ gfn] (regex-spec-impl re gfn))\n  (describe* [_] (op-describe re))))\n"} {:sym merge-spec-impl, :meta {:doc "Do not call this directly, use 'merge'", :arglists ([forms preds gfn])}, :source "(defn\n merge-spec-impl\n \"Do not call this directly, use 'merge'\"\n [forms preds gfn]\n (reify\n  Specize\n  (specize* [s] s)\n  (specize* [s _] s)\n  Spec\n  (conform*\n   [_ x]\n   (let\n    [ms\n     (map\n      (fn* [p1__18475# p2__18476#] (dt p1__18475# x p2__18476#))\n      preds\n      forms)]\n    (if (some invalid? ms) :clojure.core/invalid (apply c/merge ms))))\n  (unform*\n   [_ x]\n   (apply\n    c/merge\n    (map (fn* [p1__18477#] (unform p1__18477# x)) (reverse preds))))\n  (explain*\n   [_ path via in x]\n   (apply\n    concat\n    (map\n     (fn*\n      [p1__18478# p2__18479#]\n      (explain-1 p1__18478# p2__18479# path via in x))\n     forms\n     preds)))\n  (gen*\n   [_ overrides path rmap]\n   (if\n    gfn\n    (gfn)\n    (gen/fmap\n     (fn* [p1__18480#] (apply c/merge p1__18480#))\n     (apply\n      gen/tuple\n      (map\n       (fn*\n        [p1__18481# p2__18482#]\n        (gensub p1__18481# overrides path rmap p2__18482#))\n       preds\n       forms)))))\n  (with-gen* [_ gfn] (merge-spec-impl forms preds gfn))\n  (describe*\n   [_]\n   (clojure.core/sequence\n    (clojure.core/seq\n     (clojure.core/concat\n      (clojure.core/list 'clojure.core/merge)\n      forms))))))\n"} {:sym explain-data*, :meta {:doc nil, :arglists ([spec path via in x])}, :source "(defn\n explain-data*\n [spec path via in x]\n (when-let\n  [probs (explain* (specize spec) path via in x)]\n  (when-not\n   (empty? probs)\n   {:clojure.core/problems probs,\n    :clojure.core/spec spec,\n    :clojure.core/value x})))\n"} {:sym MAX_INT, :meta {}, :source "(def MAX_INT 9007199254740991)\n"} {:sym check-asserts, :meta {:doc "Enable or disable spec asserts that have been compiled\nwith '*compile-asserts*' true.  See 'assert'.\nInitially set to boolean value of cljs.spec.alpha/*runtime-asserts*.\nDefaults to false.", :arglists ([flag])}, :source "(defn\n check-asserts\n \"Enable or disable spec asserts that have been compiled\\nwith '*compile-asserts*' true.  See 'assert'.\\nInitially set to boolean value of cljs.spec.alpha/*runtime-asserts*.\\nDefaults to false.\"\n [flag]\n (set! *runtime-asserts* flag))\n"} {:sym assert*, :meta {:doc "Do not call this directly, use 'assert'.", :arglists ([spec x])}, :source "(defn\n assert*\n \"Do not call this directly, use 'assert'.\"\n [spec x]\n (if\n  (valid? spec x)\n  x\n  (let\n   [ed\n    (c/merge\n     (assoc\n      (explain-data* spec [] [] [] x)\n      :clojure.core/failure\n      :assertion-failed))]\n   (throw\n    (js/Error.\n     (str\n      \"Spec assertion failed\\n\"\n      (with-out-str (explain-out ed))))))))\n"} {:sym inst-in-range?, :meta {:doc "Return true if inst at or after start and before end", :arglists ([start end inst])}, :source "(defn\n inst-in-range?\n \"Return true if inst at or after start and before end\"\n [start end inst]\n (c/and\n  (inst? inst)\n  (let\n   [t (inst-ms inst)]\n   (c/and (<= (inst-ms start) t) (< t (inst-ms end))))))\n"} {:sym and-spec-impl, :meta {:doc "Do not call this directly, use 'and'", :arglists ([forms preds gfn])}, :source "(defn\n and-spec-impl\n \"Do not call this directly, use 'and'\"\n [forms preds gfn]\n (let\n  [specs\n   (delay (mapv specize preds forms))\n   cform\n   (case\n    (count preds)\n    2\n    (fn\n     [x]\n     (let\n      [specs @specs ret (conform* (specs 0) x)]\n      (if\n       (invalid? ret)\n       :clojure.core/invalid\n       (conform* (specs 1) ret))))\n    3\n    (fn\n     [x]\n     (let\n      [specs @specs ret (conform* (specs 0) x)]\n      (if\n       (invalid? ret)\n       :clojure.core/invalid\n       (let\n        [ret (conform* (specs 1) ret)]\n        (if\n         (invalid? ret)\n         :clojure.core/invalid\n         (conform* (specs 2) ret))))))\n    (fn\n     [x]\n     (let\n      [specs @specs]\n      (loop\n       [ret x i 0]\n       (if\n        (< i (count specs))\n        (let\n         [nret (conform* (specs i) ret)]\n         (if\n          (invalid? nret)\n          :clojure.core/invalid\n          (recur nret (inc i))))\n        ret)))))]\n  (reify\n   Specize\n   (specize* [s] s)\n   (specize* [s _] s)\n   Spec\n   (conform* [_ x] (cform x))\n   (unform*\n    [_ x]\n    (reduce\n     (fn* [p1__18474# p2__18473#] (unform p2__18473# p1__18474#))\n     x\n     (reverse preds)))\n   (explain*\n    [_ path via in x]\n    (explain-pred-list forms preds path via in x))\n   (gen*\n    [_ overrides path rmap]\n    (if\n     gfn\n     (gfn)\n     (gensub (first preds) overrides path rmap (first forms))))\n   (with-gen* [_ gfn] (and-spec-impl forms preds gfn))\n   (describe*\n    [_]\n    (clojure.core/sequence\n     (clojure.core/seq\n      (clojure.core/concat\n       (clojure.core/list 'clojure.core/and)\n       forms)))))))\n"} {:sym describe*, :meta {:doc nil, :arglists ([spec])}, :protocol Spec} {:sym map-spec-impl, :meta {:doc "Do not call this directly, use 'spec' with a map argument", :arglists ([{:keys [req-un opt-un keys-pred pred-exprs opt-keys req-specs req req-keys opt-specs pred-forms opt gfn], :as argm}])}, :source "(defn\n map-spec-impl\n \"Do not call this directly, use 'spec' with a map argument\"\n [{:keys\n   [req-un\n    opt-un\n    keys-pred\n    pred-exprs\n    opt-keys\n    req-specs\n    req\n    req-keys\n    opt-specs\n    pred-forms\n    opt\n    gfn],\n   :as argm}]\n (let\n  [k->s\n   (zipmap (concat req-keys opt-keys) (concat req-specs opt-specs))\n   keys->specnames\n   (fn* [p1__18465#] (c/or (k->s p1__18465#) p1__18465#))\n   id\n   (random-uuid)]\n  (reify\n   Specize\n   (specize* [s] s)\n   (specize* [s _] s)\n   Spec\n   (conform*\n    [_ m]\n    (if\n     (keys-pred m)\n     (let\n      [reg (registry)]\n      (loop\n       [ret m [[k v] & ks :as keys] m]\n       (if\n        keys\n        (let\n         [sname (keys->specnames k)]\n         (if-let\n          [s (get reg sname)]\n          (let\n           [cv (conform s v)]\n           (if\n            (invalid? cv)\n            :clojure.core/invalid\n            (recur (if (identical? cv v) ret (assoc ret k cv)) ks)))\n          (recur ret ks)))\n        ret)))\n     :clojure.core/invalid))\n   (unform*\n    [_ m]\n    (let\n     [reg (registry)]\n     (loop\n      [ret m [k & ks :as keys] (c/keys m)]\n      (if\n       keys\n       (if\n        (contains? reg (keys->specnames k))\n        (let\n         [cv (get m k) v (unform (keys->specnames k) cv)]\n         (recur (if (identical? cv v) ret (assoc ret k v)) ks))\n        (recur ret ks))\n       ret))))\n   (explain*\n    [_ path via in x]\n    (if-not\n     (map? x)\n     [{:path path, :pred 'map?, :val x, :via via, :in in}]\n     (let\n      [reg (registry)]\n      (apply\n       concat\n       (when-let\n        [probs\n         (->>\n          (map\n           (fn [pred form] (when-not (pred x) form))\n           pred-exprs\n           pred-forms)\n          (keep identity)\n          seq)]\n        (map\n         (fn*\n          [p1__18466#]\n          (identity\n           {:path path, :pred p1__18466#, :val x, :via via, :in in}))\n         probs))\n       (map\n        (fn\n         [[k v]]\n         (when-not\n          (c/or\n           (not (contains? reg (keys->specnames k)))\n           (pvalid? (keys->specnames k) v k))\n          (explain-1\n           (keys->specnames k)\n           (keys->specnames k)\n           (conj path k)\n           via\n           (conj in k)\n           v)))\n        (seq x))))))\n   (gen*\n    [_ overrides path rmap]\n    (if\n     gfn\n     (gfn)\n     (let\n      [rmap\n       (inck rmap id)\n       gen\n       (fn [k s] (gensub s overrides (conj path k) rmap k))\n       ogen\n       (fn\n        [k s]\n        (when-not\n         (recur-limit? rmap id path k)\n         [k (gen/delay (gensub s overrides (conj path k) rmap k))]))\n       req-gens\n       (map gen req-keys req-specs)\n       opt-gens\n       (remove nil? (map ogen opt-keys opt-specs))]\n      (when\n       (every? identity (concat req-gens opt-gens))\n       (let\n        [reqs (zipmap req-keys req-gens) opts (into {} opt-gens)]\n        (gen/bind\n         (gen/choose 0 (count opts))\n         (fn*\n          [p1__18467#]\n          (let\n           [args\n            (concat (seq reqs) (when (seq opts) (shuffle (seq opts))))]\n           (->>\n            args\n            (take (c/+ p1__18467# (count reqs)))\n            (apply concat)\n            (apply gen/hash-map))))))))))\n   (with-gen* [_ gfn] (map-spec-impl (assoc argm :gfn gfn)))\n   (describe*\n    [_]\n    (cons\n     'clojure.core/keys\n     (cond->\n      []\n      req\n      (conj :req req)\n      opt\n      (conj :opt opt)\n      req-un\n      (conj :req-un req-un)\n      opt-un\n      (conj :opt-un opt-un)))))))\n"} {:sym explain, :meta {:doc "Given a spec and a value that fails to conform, prints an explanation to *out*.", :arglists ([spec x])}, :source "(defn\n explain\n \"Given a spec and a value that fails to conform, prints an explanation to *out*.\"\n [spec x]\n (explain-out (explain-data spec x)))\n"} {:sym with-gen*, :meta {:doc nil, :arglists ([spec gfn])}, :protocol Spec} {:sym or-spec-impl, :meta {:doc "Do not call this directly, use 'or'", :arglists ([keys forms preds gfn])}, :source "(defn\n or-spec-impl\n \"Do not call this directly, use 'or'\"\n [keys forms preds gfn]\n (let\n  [id\n   (random-uuid)\n   kps\n   (zipmap keys preds)\n   specs\n   (delay (mapv specize preds forms))\n   cform\n   (case\n    (count preds)\n    2\n    (fn\n     [x]\n     (let\n      [specs @specs ret (conform* (specs 0) x)]\n      (if\n       (invalid? ret)\n       (let\n        [ret (conform* (specs 1) x)]\n        (if\n         (invalid? ret)\n         :clojure.core/invalid\n         (tagged-ret [(keys 1) ret])))\n       (tagged-ret [(keys 0) ret]))))\n    3\n    (fn\n     [x]\n     (let\n      [specs @specs ret (conform* (specs 0) x)]\n      (if\n       (invalid? ret)\n       (let\n        [ret (conform* (specs 1) x)]\n        (if\n         (invalid? ret)\n         (let\n          [ret (conform* (specs 2) x)]\n          (if\n           (invalid? ret)\n           :clojure.core/invalid\n           (tagged-ret [(keys 2) ret])))\n         (tagged-ret [(keys 1) ret])))\n       (tagged-ret [(keys 0) ret]))))\n    (fn\n     [x]\n     (let\n      [specs @specs]\n      (loop\n       [i 0]\n       (if\n        (< i (count specs))\n        (let\n         [spec (specs i)]\n         (let\n          [ret (conform* spec x)]\n          (if\n           (invalid? ret)\n           (recur (inc i))\n           (tagged-ret [(keys i) ret]))))\n        :clojure.core/invalid)))))]\n  (reify\n   Specize\n   (specize* [s] s)\n   (specize* [s _] s)\n   Spec\n   (conform* [_ x] (cform x))\n   (unform* [_ [k x]] (unform (kps k) x))\n   (explain*\n    [this path via in x]\n    (when-not\n     (pvalid? this x)\n     (apply\n      concat\n      (map\n       (fn\n        [k form pred]\n        (when-not\n         (pvalid? pred x)\n         (explain-1 form pred (conj path k) via in x)))\n       keys\n       forms\n       preds))))\n   (gen*\n    [_ overrides path rmap]\n    (if\n     gfn\n     (gfn)\n     (let\n      [gen\n       (fn\n        [k p f]\n        (let\n         [rmap (inck rmap id)]\n         (when-not\n          (recur-limit? rmap id path k)\n          (gen/delay (gensub p overrides (conj path k) rmap f)))))\n       gs\n       (remove nil? (map gen keys preds forms))]\n      (when-not (empty? gs) (gen/one-of gs)))))\n   (with-gen* [_ gfn] (or-spec-impl keys forms preds gfn))\n   (describe*\n    [_]\n    (clojure.core/sequence\n     (clojure.core/seq\n      (clojure.core/concat\n       (clojure.core/list 'clojure.core/or)\n       (mapcat vector keys forms))))))))\n"} {:sym *fspec-iterations*, :meta {}, :source "(def\n *fspec-iterations*\n \"The number of times an anonymous fn specified by fspec will be (generatively) tested during conform\"\n 21)\n"} {:sym Spec, :meta {:doc nil}, :methods (conform* describe* explain* gen* unform* with-gen*)} {:sym unform, :meta {:doc "Given a spec and a value created by or compliant with a call to\n  'conform' with the same spec, returns a value with all conform\n   destructuring undone.", :arglists ([spec x])}, :source "(defn\n unform\n \"Given a spec and a value created by or compliant with a call to\\n  'conform' with the same spec, returns a value with all conform\\n   destructuring undone.\"\n [spec x]\n (unform* (specize spec) x))\n"} {:sym valid?, :meta {:doc "Helper function that returns true when x is valid for spec.", :arglists [[spec x] [spec x form]]}, :source "(defn\n valid?\n \"Helper function that returns true when x is valid for spec.\"\n ([spec x]\n  (let [spec (specize spec)] (not (invalid? (conform* spec x)))))\n ([spec x form]\n  (let [spec (specize spec form)] (not (invalid? (conform* spec x))))))\n"} {:sym gen, :meta {:doc "Given a spec, returns the generator for it, or throws if none can\n  be constructed. Optionally an overrides map can be provided which\n  should map spec names or paths (vectors of keywords) to no-arg\n  generator-creating fns. These will be used instead of the generators at those\n  names/paths. Note that parent generator (in the spec or overrides\n  map) will supersede those of any subtrees. A generator for a regex\n  op must always return a sequential collection (i.e. a generator for\n  s/? should return either an empty sequence/vector or a\n  sequence/vector with one item in it)", :arglists [[spec] [spec overrides]]}, :source "(defn\n gen\n \"Given a spec, returns the generator for it, or throws if none can\\n  be constructed. Optionally an overrides map can be provided which\\n  should map spec names or paths (vectors of keywords) to no-arg\\n  generator-creating fns. These will be used instead of the generators at those\\n  names/paths. Note that parent generator (in the spec or overrides\\n  map) will supersede those of any subtrees. A generator for a regex\\n  op must always return a sequential collection (i.e. a generator for\\n  s/? should return either an empty sequence/vector or a\\n  sequence/vector with one item in it)\"\n ([spec] (gen spec nil))\n ([spec overrides]\n  (gensub\n   spec\n   overrides\n   []\n   {:clojure.core/recursion-limit *recursion-limit*}\n   spec)))\n"} {:sym nonconforming, :meta {:doc "takes a spec and returns a spec that has the same properties except\n  'conform' returns the original (not the conformed) value. Note, will specize regex ops.", :arglists ([spec])}, :source "(defn\n nonconforming\n \"takes a spec and returns a spec that has the same properties except\\n  'conform' returns the original (not the conformed) value. Note, will specize regex ops.\"\n [spec]\n (let\n  [spec (specize spec)]\n  (reify\n   Specize\n   (specize* [s] s)\n   (specize* [s _] s)\n   Spec\n   (conform*\n    [_ x]\n    (let\n     [ret (conform* spec x)]\n     (if (invalid? ret) :clojure.core/invalid x)))\n   (unform* [_ x] (unform* spec x))\n   (explain* [_ path via in x] (explain* spec path via in x))\n   (gen* [_ overrides path rmap] (gen* spec overrides path rmap))\n   (with-gen* [_ gfn] (nonconforming (with-gen* spec gfn)))\n   (describe*\n    [_]\n    (clojure.core/sequence\n     (clojure.core/seq\n      (clojure.core/concat\n       (clojure.core/list 'clojure.core/nonconforming)\n       (clojure.core/list (describe* spec)))))))))\n"} {:sym unform*, :meta {:doc nil, :arglists ([spec y])}, :protocol Spec} {:sym abbrev, :meta {:doc nil, :arglists ([form])}, :source "(defn\n abbrev\n [form]\n (cond\n  (seq? form)\n  (walk/postwalk\n   (fn\n    [form]\n    (cond\n     (c/and (symbol? form) (namespace form))\n     (-> form name symbol)\n     (c/and (seq? form) (= 'fn (first form)) (= '[%] (second form)))\n     (last form)\n     :else\n     form))\n   form)\n  (c/and (symbol? form) (namespace form))\n  (-> form name symbol)\n  :else\n  form))\n"} {:sym regex?, :meta {:doc "returns x if x is a (cljs.spec.alpha) regex op, else logical false", :arglists ([x])}, :source "(defn\n regex?\n \"returns x if x is a (cljs.spec.alpha) regex op, else logical false\"\n [x]\n (c/and (:clojure.core/op x) x))\n"} {:sym int-in-range?, :meta {:doc "Return true if start <= val, val < end and val is a fixed\n  precision integer.", :arglists ([start end val])}, :source "(defn\n int-in-range?\n \"Return true if start <= val, val < end and val is a fixed\\n  precision integer.\"\n [start end val]\n (cond\n  (integer? val)\n  (c/and (<= start val) (< val end))\n  (instance? goog.math.Long val)\n  (c/and (.lessThanOrEqual start val) (.lessThan val end))\n  (instance? goog.math.Integer val)\n  (c/and (.lessThanOrEqual start val) (.lessThan val end))\n  :else\n  false))\n"} {:sym spec?, :meta {:doc "returns x if x is a spec object, else logical false", :arglists ([x])}, :source "(defn\n spec?\n \"returns x if x is a spec object, else logical false\"\n [x]\n (when (implements? Spec x) x))\n"} {:sym registry, :meta {:doc "returns the registry map, prefer 'get-spec' to lookup a spec by name", :arglists ([])}, :source "(defn\n registry\n \"returns the registry map, prefer 'get-spec' to lookup a spec by name\"\n []\n @registry-ref)\n"} {:sym rep+impl, :meta {:doc "Do not call this directly, use '+'", :arglists ([form p])}, :source "(defn\n rep+impl\n \"Do not call this directly, use '+'\"\n [form p]\n (pcat*\n  {:ps [p (rep* p p [] true form)],\n   :forms\n   (clojure.core/vec\n    (clojure.core/sequence\n     (clojure.core/seq\n      (clojure.core/concat\n       (clojure.core/list form)\n       (clojure.core/list\n        (clojure.core/sequence\n         (clojure.core/seq\n          (clojure.core/concat\n           (clojure.core/list 'clojure.core/*)\n           (clojure.core/list form))))))))),\n   :ret [],\n   :rep+ form}))\n"} {:sym exercise, :meta {:doc "generates a number (default 10) of values compatible with spec and maps conform over them,\n  returning a sequence of [val conformed-val] tuples. Optionally takes\n  a generator overrides map as per gen", :arglists [[spec] [spec n] [spec n overrides]]}, :source "(defn\n exercise\n \"generates a number (default 10) of values compatible with spec and maps conform over them,\\n  returning a sequence of [val conformed-val] tuples. Optionally takes\\n  a generator overrides map as per gen\"\n ([spec] (exercise spec 10))\n ([spec n] (exercise spec n nil))\n ([spec n overrides]\n  (map\n   (fn* [p1__18498#] (vector p1__18498# (conform spec p1__18498#)))\n   (gen/sample (gen spec overrides) n))))\n"} {:sym explain-data, :meta {:doc "Given a spec and a value x which ought to conform, returns nil if x\n  conforms, else a map with at least the key ::problems whose value is\n  a collection of problem-maps, where problem-map has at least :path :pred and :val\n  keys describing the predicate and the value that failed at that\n  path.", :arglists ([spec x])}, :source "(defn\n explain-data\n \"Given a spec and a value x which ought to conform, returns nil if x\\n  conforms, else a map with at least the key ::problems whose value is\\n  a collection of problem-maps, where problem-map has at least :path :pred and :val\\n  keys describing the predicate and the value that failed at that\\n  path.\"\n [spec x]\n (explain-data*\n  spec\n  []\n  (if-let [name (spec-name spec)] [name] [])\n  []\n  x))\n"} {:sym tuple-impl, :meta {:doc "Do not call this directly, use 'tuple'", :arglists [[forms preds] [forms preds gfn]]}, :source "(defn\n tuple-impl\n \"Do not call this directly, use 'tuple'\"\n ([forms preds] (tuple-impl forms preds nil))\n ([forms preds gfn]\n  (let\n   [specs (delay (mapv specize preds forms)) cnt (count preds)]\n   (reify\n    Specize\n    (specize* [s] s)\n    (specize* [s _] s)\n    Spec\n    (conform*\n     [_ x]\n     (let\n      [specs @specs]\n      (if-not\n       (c/and (vector? x) (= (count x) cnt))\n       :clojure.core/invalid\n       (loop\n        [ret x i 0]\n        (if\n         (= i cnt)\n         ret\n         (let\n          [v (x i) cv (conform* (specs i) v)]\n          (if\n           (invalid? cv)\n           :clojure.core/invalid\n           (recur\n            (if (identical? cv v) ret (assoc ret i cv))\n            (inc i)))))))))\n    (unform*\n     [_ x]\n     (assert (c/and (vector? x) (= (count x) (count preds))))\n     (loop\n      [ret x i 0]\n      (if\n       (= i (count x))\n       ret\n       (let\n        [cv (x i) v (unform (preds i) cv)]\n        (recur (if (identical? cv v) ret (assoc ret i v)) (inc i))))))\n    (explain*\n     [_ path via in x]\n     (cond\n      (not (vector? x))\n      [{:path path, :pred 'vector?, :val x, :via via, :in in}]\n      (not= (count x) (count preds))\n      [{:path path,\n        :pred\n        (clojure.core/sequence\n         (clojure.core/seq\n          (clojure.core/concat\n           (clojure.core/list 'clojure.core/=)\n           (clojure.core/list\n            (clojure.core/sequence\n             (clojure.core/seq\n              (clojure.core/concat\n               (clojure.core/list 'clojure.core/count)\n               (clojure.core/list '%)))))\n           (clojure.core/list (count preds))))),\n        :val x,\n        :via via,\n        :in in}]\n      :else\n      (apply\n       concat\n       (map\n        (fn\n         [i form pred]\n         (let\n          [v (x i)]\n          (when-not\n           (pvalid? pred v)\n           (explain-1 form pred (conj path i) via (conj in i) v))))\n        (range (count preds))\n        forms\n        preds))))\n    (gen*\n     [_ overrides path rmap]\n     (if\n      gfn\n      (gfn)\n      (let\n       [gen\n        (fn [i p f] (gensub p overrides (conj path i) rmap f))\n        gs\n        (map gen (range (count preds)) preds forms)]\n       (when (every? identity gs) (apply gen/tuple gs)))))\n    (with-gen* [_ gfn] (tuple-impl forms preds gfn))\n    (describe*\n     [_]\n     (clojure.core/sequence\n      (clojure.core/seq\n       (clojure.core/concat\n        (clojure.core/list 'clojure.core/tuple)\n        forms))))))))\n"} {:sym multi-spec-impl, :meta {:doc "Do not call this directly, use 'multi-spec'", :arglists [[form mmvar retag] [form mmvar retag gfn]]}, :source "(defn\n multi-spec-impl\n \"Do not call this directly, use 'multi-spec'\"\n ([form mmvar retag] (multi-spec-impl form mmvar retag nil))\n ([form mmvar retag gfn]\n  (let\n   [id\n    (random-uuid)\n    predx\n    (fn*\n     [p1__18468#]\n     (let\n      [mm @mmvar]\n      (c/and\n       (-get-method mm ((-dispatch-fn mm) p1__18468#))\n       (mm p1__18468#))))\n    dval\n    (fn* [p1__18469#] ((-dispatch-fn @mmvar) p1__18469#))\n    tag\n    (if\n     (keyword? retag)\n     (fn* [p1__18470# p2__18471#] (assoc p1__18470# retag p2__18471#))\n     retag)]\n   (reify\n    Specize\n    (specize* [s] s)\n    (specize* [s _] s)\n    Spec\n    (conform*\n     [_ x]\n     (if-let [pred (predx x)] (dt pred x form) :clojure.core/invalid))\n    (unform*\n     [_ x]\n     (if-let\n      [pred (predx x)]\n      (unform pred x)\n      (throw\n       (js/Error.\n        (str\n         \"No method of: \"\n         form\n         \" for dispatch value: \"\n         (dval x))))))\n    (explain*\n     [_ path via in x]\n     (let\n      [dv (dval x) path (conj path dv)]\n      (if-let\n       [pred (predx x)]\n       (explain-1 form pred path via in x)\n       [{:path path,\n         :pred form,\n         :val x,\n         :reason \"no method\",\n         :via via,\n         :in in}])))\n    (gen*\n     [_ overrides path rmap]\n     (if\n      gfn\n      (gfn)\n      (let\n       [gen\n        (fn\n         [[k f]]\n         (let\n          [p (f nil)]\n          (let\n           [rmap (inck rmap id)]\n           (when-not\n            (recur-limit? rmap id path k)\n            (gen/delay\n             (gen/fmap\n              (fn* [p1__18472#] (tag p1__18472# k))\n              (gensub\n               p\n               overrides\n               (conj path k)\n               rmap\n               (list 'method form k))))))))\n        gs\n        (->>\n         (methods @mmvar)\n         (remove (fn [[k]] (invalid? k)))\n         (map gen)\n         (remove nil?))]\n       (when (every? identity gs) (gen/one-of gs)))))\n    (with-gen* [_ gfn] (multi-spec-impl form mmvar retag gfn))\n    (describe*\n     [_]\n     (clojure.core/sequence\n      (clojure.core/seq\n       (clojure.core/concat\n        (clojure.core/list 'clojure.core/multi-spec)\n        (clojure.core/list form)\n        (clojure.core/list retag)))))))))\n"} {:sym conform, :meta {:doc "Given a spec and a value, returns :cljs.spec.alpha/invalid if value does\n  not match spec, else the (possibly destructured) value.", :arglists ([spec x])}, :source "(defn\n conform\n \"Given a spec and a value, returns :cljs.spec.alpha/invalid if value does\\n  not match spec, else the (possibly destructured) value.\"\n [spec x]\n (conform* (specize spec) x))\n"} {:sym gen*, :meta {:doc nil, :arglists ([spec overrides path rmap])}, :protocol Spec} {:sym fspec-impl, :meta {:doc "Do not call this directly, use 'fspec'", :arglists ([argspec aform retspec rform fnspec fform gfn])}, :source "(defn\n fspec-impl\n \"Do not call this directly, use 'fspec'\"\n [argspec aform retspec rform fnspec fform gfn]\n (let\n  [specs {:args argspec, :ret retspec, :fn fnspec}]\n  (reify\n   ILookup\n   (-lookup [this k] (get specs k))\n   (-lookup [_ k not-found] (get specs k not-found))\n   Specize\n   (specize* [s] s)\n   (specize* [s _] s)\n   Spec\n   (conform*\n    [_ f]\n    (if\n     (ifn? f)\n     (if\n      (identical? f (validate-fn f specs *fspec-iterations*))\n      f\n      :clojure.core/invalid)\n     :clojure.core/invalid))\n   (unform* [_ f] f)\n   (explain*\n    [_ path via in f]\n    (if\n     (ifn? f)\n     (let\n      [args (validate-fn f specs 100)]\n      (if\n       (identical? f args)\n       nil\n       (let\n        [ret (try (apply f args) (catch js/Error t t))]\n        (if\n         (instance? js/Error ret)\n         [{:path path,\n           :pred '(apply fn),\n           :val args,\n           :reason (.-message ret),\n           :via via,\n           :in in}]\n         (let\n          [cret (dt retspec ret rform)]\n          (if\n           (invalid? cret)\n           (explain-1 rform retspec (conj path :ret) via in ret)\n           (when\n            fnspec\n            (let\n             [cargs (conform argspec args)]\n             (explain-1\n              fform\n              fnspec\n              (conj path :fn)\n              via\n              in\n              {:args cargs, :ret cret})))))))))\n     [{:path path, :pred 'ifn?, :val f, :via via, :in in}]))\n   (gen*\n    [_ overrides _ _]\n    (if\n     gfn\n     (gfn)\n     (gen/return\n      (fn\n       [& args]\n       (assert\n        (pvalid? argspec args)\n        (with-out-str (explain argspec args)))\n       (gen/generate (gen retspec overrides))))))\n   (with-gen*\n    [_ gfn]\n    (fspec-impl argspec aform retspec rform fnspec fform gfn))\n   (describe*\n    [_]\n    (clojure.core/sequence\n     (clojure.core/seq\n      (clojure.core/concat\n       (clojure.core/list 'clojure.core/fspec)\n       (clojure.core/list :args)\n       (clojure.core/list aform)\n       (clojure.core/list :ret)\n       (clojure.core/list rform)\n       (clojure.core/list :fn)\n       (clojure.core/list fform))))))))\n"} {:sym *coll-check-limit*, :meta {}, :source "(def\n *coll-check-limit*\n \"The number of items validated in a collection spec'ed with 'every'\"\n 101)\n"} {:sym get-spec, :meta {:doc "Returns spec registered for keyword/symbol/var k, or nil.", :arglists ([k])}, :source "(defn\n get-spec\n \"Returns spec registered for keyword/symbol/var k, or nil.\"\n [k]\n (get (registry) (if (keyword? k) k (->sym k))))\n"} {:sym every-impl, :meta {:doc "Do not call this directly, use 'every', 'every-kv', 'coll-of' or 'map-of'", :arglists [[form pred opts] [form pred {gen-into :into, describe-form :clojure.core/describe, :keys [kind :clojure.core/kind-form count max-count min-count distinct gen-max :clojure.core/kfn :clojure.core/cpred conform-keys :clojure.core/conform-all], :or {gen-max 20}, :as opts} gfn]]}, :source "(defn\n every-impl\n \"Do not call this directly, use 'every', 'every-kv', 'coll-of' or 'map-of'\"\n ([form pred opts] (every-impl form pred opts nil))\n ([form\n   pred\n   {gen-into :into,\n    describe-form :clojure.core/describe,\n    :keys\n    [kind\n     :clojure.core/kind-form\n     count\n     max-count\n     min-count\n     distinct\n     gen-max\n     :clojure.core/kfn\n     :clojure.core/cpred\n     conform-keys\n     :clojure.core/conform-all],\n    :or {gen-max 20},\n    :as opts}\n   gfn]\n  (let\n   [conform-into\n    gen-into\n    spec\n    (delay (specize pred))\n    check?\n    (fn* [p1__18483#] (valid? @spec p1__18483#))\n    kfn\n    (c/or kfn (fn [i v] i))\n    addcv\n    (fn [ret i v cv] (conj ret cv))\n    cfns\n    (fn\n     [x]\n     (cond\n      (c/and\n       (vector? x)\n       (c/or (not conform-into) (vector? conform-into)))\n      [identity\n       (fn [ret i v cv] (if (identical? v cv) ret (assoc ret i cv)))\n       identity]\n      (c/and\n       (map? x)\n       (c/or (c/and kind (not conform-into)) (map? conform-into)))\n      [(if conform-keys empty identity)\n       (fn\n        [ret i v cv]\n        (if\n         (c/and (identical? v cv) (not conform-keys))\n         ret\n         (assoc ret (nth (if conform-keys cv v) 0) (nth cv 1))))\n       identity]\n      (c/or\n       (list? conform-into)\n       (seq? conform-into)\n       (c/and (not conform-into) (c/or (list? x) (seq? x))))\n      [empty addcv reverse]\n      :else\n      [(fn* [p1__18484#] (empty (c/or conform-into p1__18484#)))\n       addcv\n       identity]))]\n   (reify\n    Specize\n    (specize* [s] s)\n    (specize* [s _] s)\n    Spec\n    (conform*\n     [_ x]\n     (let\n      [spec @spec]\n      (cond\n       (not (cpred x))\n       :clojure.core/invalid\n       conform-all\n       (let\n        [[init add complete] (cfns x)]\n        (loop\n         [ret (init x) i 0 [v & vs :as vseq] (seq x)]\n         (if\n          vseq\n          (let\n           [cv (conform* spec v)]\n           (if\n            (invalid? cv)\n            :clojure.core/invalid\n            (recur (add ret i v cv) (inc i) vs)))\n          (complete ret))))\n       :else\n       (if\n        (indexed? x)\n        (let\n         [step (max 1 (long (/ (c/count x) *coll-check-limit*)))]\n         (loop\n          [i 0]\n          (if\n           (>= i (c/count x))\n           x\n           (if\n            (valid? spec (nth x i))\n            (recur (c/+ i step))\n            :clojure.core/invalid))))\n        (let\n         [limit *coll-check-limit*]\n         (loop\n          [i 0 [v & vs :as vseq] (seq x)]\n          (cond\n           (c/or (nil? vseq) (= i limit))\n           x\n           (valid? spec v)\n           (recur (inc i) vs)\n           :else\n           :clojure.core/invalid)))))))\n    (unform*\n     [_ x]\n     (if\n      conform-all\n      (let\n       [spec @spec [init add complete] (cfns x)]\n       (loop\n        [ret (init x) i 0 [v & vs :as vseq] (seq x)]\n        (if\n         (>= i (c/count x))\n         (complete ret)\n         (recur (add ret i v (unform* spec v)) (inc i) vs))))\n      x))\n    (explain*\n     [_ path via in x]\n     (c/or\n      (coll-prob\n       x\n       kind\n       kind-form\n       distinct\n       count\n       min-count\n       max-count\n       path\n       via\n       in)\n      (apply\n       concat\n       ((if conform-all identity (partial take *coll-error-limit*))\n        (keep\n         identity\n         (map\n          (fn\n           [i v]\n           (let\n            [k (kfn i v)]\n            (when-not\n             (check? v)\n             (let\n              [prob (explain-1 form pred path via (conj in k) v)]\n              prob))))\n          (range)\n          x))))))\n    (gen*\n     [_ overrides path rmap]\n     (if\n      gfn\n      (gfn)\n      (let\n       [pgen (gensub pred overrides path rmap form)]\n       (gen/bind\n        (cond\n         gen-into\n         (gen/return (empty gen-into))\n         kind\n         (gen/fmap\n          (fn*\n           [p1__18485#]\n           (if (empty? p1__18485#) p1__18485# (empty p1__18485#)))\n          (gensub kind overrides path rmap form))\n         :else\n         (gen/return []))\n        (fn\n         [init]\n         (gen/fmap\n          (fn*\n           [p1__18486#]\n           (if (vector? init) p1__18486# (into init p1__18486#)))\n          (cond\n           distinct\n           (if\n            count\n            (gen/vector-distinct\n             pgen\n             {:num-elements count, :max-tries 100})\n            (gen/vector-distinct\n             pgen\n             {:min-elements (c/or min-count 0),\n              :max-elements\n              (c/or\n               max-count\n               (max gen-max (c/* 2 (c/or min-count 0)))),\n              :max-tries 100}))\n           count\n           (gen/vector pgen count)\n           (c/or min-count max-count)\n           (gen/vector\n            pgen\n            (c/or min-count 0)\n            (c/or max-count (max gen-max (c/* 2 (c/or min-count 0)))))\n           :else\n           (gen/vector pgen 0 gen-max))))))))\n    (with-gen* [_ gfn] (every-impl form pred opts gfn))\n    (describe*\n     [_]\n     (c/or\n      describe-form\n      (clojure.core/sequence\n       (clojure.core/seq\n        (clojure.core/concat\n         (clojure.core/list 'clojure.core/every)\n         (clojure.core/list (s/mres form))\n         (mapcat identity opts))))))))))\n"} {:sym spec-impl, :meta {:doc "Do not call this directly, use 'spec'", :arglists [[form pred gfn cpred?] [form pred gfn cpred? unc]]}, :source "(defn\n spec-impl\n \"Do not call this directly, use 'spec'\"\n ([form pred gfn cpred?] (spec-impl form pred gfn cpred? nil))\n ([form pred gfn cpred? unc]\n  (cond\n   (spec? pred)\n   (cond-> pred gfn (with-gen gfn))\n   (regex? pred)\n   (regex-spec-impl pred gfn)\n   (ident? pred)\n   (cond-> (the-spec pred) gfn (with-gen gfn))\n   :else\n   (reify\n    Specize\n    (specize* [s] s)\n    (specize* [s _] s)\n    Spec\n    (conform*\n     [_ x]\n     (let\n      [ret (pred x)]\n      (if cpred? ret (if ret x :clojure.core/invalid))))\n    (unform*\n     [_ x]\n     (if\n      cpred?\n      (if unc (unc x) (throw (js/Error. \"no unform fn for conformer\")))\n      x))\n    (explain*\n     [_ path via in x]\n     (when\n      (invalid? (dt pred x form cpred?))\n      [{:path path, :pred form, :val x, :via via, :in in}]))\n    (gen* [_ _ _ _] (if gfn (gfn) (gen/gen-for-pred pred)))\n    (with-gen* [_ gfn] (spec-impl form pred gfn cpred? unc))\n    (describe* [_] form)))))\n"} {:sym invalid?, :meta {:doc "tests the validity of a conform return value", :arglists ([ret])}, :source "(defn\n invalid?\n \"tests the validity of a conform return value\"\n [ret]\n (keyword-identical? :clojure.core/invalid ret))\n"} {:sym amp-impl, :meta {:doc "Do not call this directly, use '&'", :arglists ([re preds pred-forms])}, :source "(defn\n amp-impl\n \"Do not call this directly, use '&'\"\n [re preds pred-forms]\n {:clojure.core/op :clojure.core/amp,\n  :p1 re,\n  :ps preds,\n  :forms pred-forms})\n"} {:sym cat-impl, :meta {:doc "Do not call this directly, use 'cat'", :arglists ([ks ps forms])}, :source "(defn\n cat-impl\n \"Do not call this directly, use 'cat'\"\n [ks ps forms]\n (pcat* {:ks ks, :ps ps, :forms forms, :ret {}}))\n"} {:sym explain-str, :meta {:doc "Given a spec and a value that fails to conform, returns an explanation as a string.", :arglists ([spec x])}, :source "(defn\n explain-str\n \"Given a spec and a value that fails to conform, returns an explanation as a string.\"\n [spec x]\n (with-out-str (explain spec x)))\n"} {:sym *compile-asserts*, :meta {:doc "If true, compiler will enable spec asserts, which are then\nsubject to runtime control via check-asserts? If false, compiler\nwill eliminate all spec assert overhead. See 'assert'.\nInitially set to the negation of the ':elide-asserts' compiler option.\nDefaults to true."}, :source "(defonce *compile-asserts* (s/init-compile-asserts))\n"} {:sym with-gen, :meta {:doc "Takes a spec and a no-arg, generator-returning fn and returns a version of that spec that uses that generator", :arglists ([spec gen-fn])}, :source "(defn\n with-gen\n \"Takes a spec and a no-arg, generator-returning fn and returns a version of that spec that uses that generator\"\n [spec gen-fn]\n (let\n  [spec (reg-resolve spec)]\n  (if\n   (regex? spec)\n   (assoc spec :clojure.core/gfn gen-fn)\n   (with-gen* (specize spec) gen-fn))))\n"} {:sym conform*, :meta {:doc nil, :arglists ([spec x])}, :protocol Spec} {:sym check-asserts?, :meta {:doc "Returns the value set by check-asserts.", :arglists ([])}, :source "(defn\n check-asserts?\n \"Returns the value set by check-asserts.\"\n []\n *runtime-asserts*)\n"} {:sym rep-impl, :meta {:doc "Do not call this directly, use '*'", :arglists ([form p])}, :source "(defn\n rep-impl\n \"Do not call this directly, use '*'\"\n [form p]\n (rep* p p [] false form))\n"} {:sym describe, :meta {:doc "returns an abbreviated description of the spec as data", :arglists ([spec])}, :source "(defn\n describe\n \"returns an abbreviated description of the spec as data\"\n [spec]\n (abbrev (form spec)))\n"} {:sym explain-out, :meta {:doc "Prints explanation data (per 'explain-data') to *out* using the printer in *explain-out*,\n    by default explain-printer.", :arglists ([ed])}, :source "(defn\n explain-out\n \"Prints explanation data (per 'explain-data') to *out* using the printer in *explain-out*,\\n    by default explain-printer.\"\n [ed]\n (*explain-out* ed))\n"} {:sym specize*, :meta {:doc nil, :arglists ([_] [_ form])}, :protocol Specize} {:sym maybe-impl, :meta {:doc "Do not call this directly, use '?'", :arglists ([p form])}, :source "(defn\n maybe-impl\n \"Do not call this directly, use '?'\"\n [p form]\n (assoc\n  (alt* [p (accept :clojure.core/nil)] nil [form :clojure.core/nil])\n  :maybe\n  form))\n"} {:sym explain*, :meta {:doc nil, :arglists ([spec path via in x])}, :protocol Spec}), cljs.reader ({:sym *default-data-reader-fn*, :meta {}, :source "(def *default-data-reader-fn* (atom nil))\n"} {:sym read, :meta {:doc "Reads the first object from an cljs.tools.reader.reader-types/IPushbackReader.\n   Returns the object read. If EOF, throws if eof-error? is true otherwise returns eof.\n   If no reader is provided, *in* will be used.\n\n   Reads data in the edn format (subset of Clojure data):\n   http://edn-format.org\n\n   cljs.tools.reader.edn/read doesn't depend on dynamic Vars, all configuration\n   is done by passing an opt map.\n\n   opts is a map that can include the following keys:\n   :eof - value to return on end-of-file. When not supplied, eof throws an exception.\n   :readers  - a map of tag symbols to data-reader functions to be considered before default-data-readers.\n              When not supplied, only the default-data-readers will be used.\n   :default - A function of two args, that will, if present and no reader is found for a tag,\n              be called with the tag and the value.", :arglists [[reader] [{:keys [eof], :as opts} reader] [reader eof-error? eof opts]]}, :source "(defn\n read\n \"Reads the first object from an cljs.tools.reader.reader-types/IPushbackReader.\\n   Returns the object read. If EOF, throws if eof-error? is true otherwise returns eof.\\n   If no reader is provided, *in* will be used.\\n\\n   Reads data in the edn format (subset of Clojure data):\\n   http://edn-format.org\\n\\n   cljs.tools.reader.edn/read doesn't depend on dynamic Vars, all configuration\\n   is done by passing an opt map.\\n\\n   opts is a map that can include the following keys:\\n   :eof - value to return on end-of-file. When not supplied, eof throws an exception.\\n   :readers  - a map of tag symbols to data-reader functions to be considered before default-data-readers.\\n              When not supplied, only the default-data-readers will be used.\\n   :default - A function of two args, that will, if present and no reader is found for a tag,\\n              be called with the tag and the value.\"\n ([reader]\n  (edn/read\n   {:readers @*tag-table*,\n    :default @*default-data-reader-fn*,\n    :eof nil}\n   reader))\n ([{:keys [eof], :as opts} reader]\n  (edn/read\n   (update\n    (merge opts {:default @*default-data-reader-fn*})\n    :readers\n    (fn [m] (merge @*tag-table* m)))\n   reader))\n ([reader eof-error? eof opts]\n  (edn/read\n   reader\n   eof-error?\n   eof\n   (update\n    (merge opts {:default @*default-data-reader-fn*})\n    :readers\n    (fn [m] (merge @*tag-table* m))))))\n"} {:sym *tag-table*, :meta {}, :source "(def\n *tag-table*\n (atom\n  (add-data-readers\n   {'inst read-date, 'uuid read-uuid, 'queue read-queue, 'js read-js})))\n"} {:sym parse-and-validate-timestamp, :meta {:doc nil, :arglists ([s])}, :source "(defn\n parse-and-validate-timestamp\n [s]\n (let\n  [[_\n    years\n    months\n    days\n    hours\n    minutes\n    seconds\n    fraction\n    offset-sign\n    offset-hours\n    offset-minutes\n    :as\n    v]\n   (re-matches timestamp-regex s)]\n  (if-not\n   v\n   (throw (js/Error. (str \"Unrecognized date/time syntax: \" s)))\n   (let\n    [years\n     (parse-int years)\n     months\n     (or (parse-int months) 1)\n     days\n     (or (parse-int days) 1)\n     hours\n     (or (parse-int hours) 0)\n     minutes\n     (or (parse-int minutes) 0)\n     seconds\n     (or (parse-int seconds) 0)\n     fraction\n     (or (parse-int (zero-fill-right-and-truncate fraction 3)) 0)\n     offset-sign\n     (if (= offset-sign \"-\") -1 1)\n     offset-hours\n     (or (parse-int offset-hours) 0)\n     offset-minutes\n     (or (parse-int offset-minutes) 0)\n     offset\n     (* offset-sign (+ (* offset-hours 60) offset-minutes))]\n    [years\n     (check 1 months 12 \"timestamp month field must be in range 1..12\")\n     (check\n      1\n      days\n      (days-in-month months (leap-year? years))\n      \"timestamp day field must be in range 1..last day in month\")\n     (check 0 hours 23 \"timestamp hour field must be in range 0..23\")\n     (check\n      0\n      minutes\n      59\n      \"timestamp minute field must be in range 0..59\")\n     (check\n      0\n      seconds\n      (if (= minutes 59) 60 59)\n      \"timestamp second field must be in range 0..60\")\n     (check\n      0\n      fraction\n      999\n      \"timestamp millisecond field must be in range 0..999\")\n     offset]))))\n"} {:sym register-tag-parser!, :meta {:doc nil, :arglists ([tag f])}, :source "(defn\n register-tag-parser!\n [tag f]\n (let\n  [old-parser (get @*tag-table* tag)]\n  (swap! *tag-table* assoc tag f)\n  old-parser))\n"} {:sym register-default-tag-parser!, :meta {:doc nil, :arglists ([f])}, :source "(defn\n register-default-tag-parser!\n [f]\n (let\n  [old-parser @*default-data-reader-fn*]\n  (swap! *default-data-reader-fn* (fn [_] f))\n  old-parser))\n"} {:sym deregister-default-tag-parser!, :meta {:doc nil, :arglists ([])}, :source "(defn\n deregister-default-tag-parser!\n []\n (let\n  [old-parser @*default-data-reader-fn*]\n  (swap! *default-data-reader-fn* (fn [_] nil))\n  old-parser))\n"} {:sym read-string, :meta {:doc "Reads one object from the string s.\n   Returns nil when s is nil or empty.\n\n   Reads data in the edn format (subset of Clojure data):\n   http://edn-format.org\n\n   opts is a map as per cljs.tools.reader.edn/read", :arglists [[s] [opts s]]}, :source "(defn\n read-string\n \"Reads one object from the string s.\\n   Returns nil when s is nil or empty.\\n\\n   Reads data in the edn format (subset of Clojure data):\\n   http://edn-format.org\\n\\n   opts is a map as per cljs.tools.reader.edn/read\"\n ([s]\n  (edn/read-string\n   {:readers @*tag-table*,\n    :default @*default-data-reader-fn*,\n    :eof nil}\n   s))\n ([opts s]\n  (edn/read-string\n   (update\n    (merge {:default @*default-data-reader-fn*} opts)\n    :readers\n    (fn [m] (merge @*tag-table* m)))\n   s)))\n"} {:sym deregister-tag-parser!, :meta {:doc nil, :arglists ([tag])}, :source "(defn\n deregister-tag-parser!\n [tag]\n (let\n  [old-parser (get @*tag-table* tag)]\n  (swap! *tag-table* dissoc tag)\n  old-parser))\n"} {:sym parse-timestamp, :meta {:doc nil, :arglists ([ts])}, :source "(defn\n parse-timestamp\n [ts]\n (if-let\n  [[years months days hours minutes seconds ms offset]\n   (parse-and-validate-timestamp ts)]\n  (js/Date.\n   (-\n    (.UTC js/Date years (dec months) days hours minutes seconds ms)\n    (* offset 60 1000)))\n  (throw (js/Error. (str \"Unrecognized date/time syntax: \" ts)))))\n"}), clojure.walk ({:sym walk, :meta {:doc "Traverses form, an arbitrary data structure.  inner and outer are\n  functions.  Applies inner to each element of form, building up a\n  data structure of the same type, then applies outer to the result.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.", :arglists ([inner outer form])}, :source "(defn\n walk\n \"Traverses form, an arbitrary data structure.  inner and outer are\\n  functions.  Applies inner to each element of form, building up a\\n  data structure of the same type, then applies outer to the result.\\n  Recognizes all Clojure data structures. Consumes seqs as with doall.\"\n {:added \"1.1\"}\n [inner outer form]\n (cond\n  (list? form)\n  (outer (apply list (map inner form)))\n  (seq? form)\n  (outer (doall (map inner form)))\n  (record? form)\n  (outer (reduce (fn [r x] (conj r (inner x))) form form))\n  (coll? form)\n  (outer (into (empty form) (map inner form)))\n  :else\n  (outer form)))\n"} {:sym postwalk, :meta {:doc "Performs a depth-first, post-order traversal of form.  Calls f on\n  each sub-form, uses f's return value in place of the original.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.", :arglists ([f form])}, :source "(defn\n postwalk\n \"Performs a depth-first, post-order traversal of form.  Calls f on\\n  each sub-form, uses f's return value in place of the original.\\n  Recognizes all Clojure data structures. Consumes seqs as with doall.\"\n {:added \"1.1\"}\n [f form]\n (walk (partial postwalk f) f form))\n"} {:sym prewalk, :meta {:doc "Like postwalk, but does pre-order traversal.", :arglists ([f form])}, :source "(defn\n prewalk\n \"Like postwalk, but does pre-order traversal.\"\n {:added \"1.1\"}\n [f form]\n (walk (partial prewalk f) identity (f form)))\n"} {:sym keywordize-keys, :meta {:doc "Recursively transforms all map keys from strings to keywords.", :arglists ([m])}, :source "(defn\n keywordize-keys\n \"Recursively transforms all map keys from strings to keywords.\"\n {:added \"1.1\"}\n [m]\n (let\n  [f (fn [[k v]] (if (string? k) [(keyword k) v] [k v]))]\n  (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))\n"} {:sym stringify-keys, :meta {:doc "Recursively transforms all map keys from keywords to strings.", :arglists ([m])}, :source "(defn\n stringify-keys\n \"Recursively transforms all map keys from keywords to strings.\"\n {:added \"1.1\"}\n [m]\n (let\n  [f (fn [[k v]] (if (keyword? k) [(name k) v] [k v]))]\n  (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))\n"} {:sym prewalk-replace, :meta {:doc "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the root of the tree first.", :arglists ([smap form])}, :source "(defn\n prewalk-replace\n \"Recursively transforms form by replacing keys in smap with their\\n  values.  Like clojure/replace but works on any data structure.  Does\\n  replacement at the root of the tree first.\"\n {:added \"1.1\"}\n [smap form]\n (prewalk (fn [x] (if (contains? smap x) (smap x) x)) form))\n"} {:sym postwalk-replace, :meta {:doc "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the leaves of the tree first.", :arglists ([smap form])}, :source "(defn\n postwalk-replace\n \"Recursively transforms form by replacing keys in smap with their\\n  values.  Like clojure/replace but works on any data structure.  Does\\n  replacement at the leaves of the tree first.\"\n {:added \"1.1\"}\n [smap form]\n (postwalk (fn [x] (if (contains? smap x) (smap x) x)) form))\n"}), cljs.core.async.impl.timers ({:sym MAX_LEVEL, :meta {}, :source "(def MAX_LEVEL 15)\n"} {:sym P, :meta {}, :source "(def P (/ 1 2))\n"} {:sym random-level, :meta {:doc nil, :arglists [[] [level]]}, :source "(defn\n random-level\n ([] (random-level 0))\n ([level]\n  (if\n   (and (< (.random js/Math) P) (< level MAX_LEVEL))\n   (recur (inc level))\n   level)))\n"} {:sym skip-list-node, :meta {:doc nil, :arglists [[level] [k v level]]}, :source "(defn\n skip-list-node\n ([level] (skip-list-node nil nil level))\n ([k v level]\n  (let\n   [arr (make-array (inc level))]\n   (loop\n    [i 0]\n    (when (< i (alength arr)) (aset arr i nil) (recur (inc i))))\n   (SkipListNode. k v arr))))\n"} {:sym least-greater-node, :meta {:doc nil, :arglists [[x k level] [x k level update]]}, :source "(defn\n least-greater-node\n ([x k level] (least-greater-node x k level nil))\n ([x k level update]\n  (if-not\n   (neg? level)\n   (let\n    [x\n     (loop\n      [x x]\n      (if-let\n       [x' (aget (.-forward x) level)]\n       (if (< (.-key x') k) (recur x') x)\n       x))]\n    (when-not (nil? update) (aset update level x))\n    (recur x k (dec level) update))\n   x)))\n"} {:sym skip-list, :meta {:doc nil, :arglists ([])}, :source "(defn skip-list [] (SkipList. (skip-list-node 0) 0))\n"} {:sym timeouts-map, :meta {}, :source "(def timeouts-map (skip-list))\n"} {:sym TIMEOUT_RESOLUTION_MS, :meta {}, :source "(def TIMEOUT_RESOLUTION_MS 10)\n"} {:sym timeout, :meta {:doc "returns a channel that will close after msecs", :arglists ([msecs])}, :source "(defn\n timeout\n \"returns a channel that will close after msecs\"\n [msecs]\n (let\n  [timeout\n   (+ (.valueOf (js/Date.)) msecs)\n   me\n   (.ceilingEntry timeouts-map timeout)]\n  (or\n   (when\n    (and me (< (.-key me) (+ timeout TIMEOUT_RESOLUTION_MS)))\n    (.-val me))\n   (let\n    [timeout-channel (channels/chan nil)]\n    (.put timeouts-map timeout timeout-channel)\n    (dispatch/queue-delay\n     (fn\n      []\n      (.remove timeouts-map timeout)\n      (impl/close! timeout-channel))\n     msecs)\n    timeout-channel))))\n"}), cljs.spec.gen.alpha ({:sym quick-check, :meta {:doc nil, :arglists ([& args])}, :source "(defn quick-check [& args] (apply @quick-check-ref args))\n"} {:sym for-all*, :meta {:doc "Dynamically loaded clojure.test.check.properties/for-all*.", :arglists ([& args])}, :source "(defn\n for-all*\n \"Dynamically loaded clojure.test.check.properties/for-all*.\"\n [& args]\n (apply @for-all*-ref args))\n"} {:sym delay-impl, :meta {:doc nil, :arglists ([gfnd])}, :source "(defn\n delay-impl\n [gfnd]\n (generator (fn [rnd size] ((:gen @gfnd) rnd size))))\n"} {:sym cat, :meta {:doc "Returns a generator of a sequence catenated from results of\ngens, each of which should generate something sequential.", :arglists ([& gens])}, :source "(defn\n cat\n \"Returns a generator of a sequence catenated from results of\\ngens, each of which should generate something sequential.\"\n [& gens]\n (fmap (fn* [p1__18499#] (apply concat p1__18499#)) (apply tuple gens)))\n"} {:sym gen-for-pred, :meta {:doc "Given a predicate, returns a built-in generator if one exists.", :arglists ([pred])}, :source "(defn\n gen-for-pred\n \"Given a predicate, returns a built-in generator if one exists.\"\n [pred]\n (if (set? pred) (elements pred) (get @gen-builtins pred)))\n"})}, :nses ({:var-syms [wrap-security code->results wrap-timeout eval_soup.core.proxy$java.lang.SecurityManager$ff19274a with-security], :type :clj, :sym eval-soup.core} {:var-syms [chan? code->results], :type :cljs, :sym eval-soup.core}), :ns-meta nil, :vars [{:sym code->results, :meta {:doc "Evaluates each form, providing the results in a callback.\n  If any of the forms are strings, it will read them first.", :arglists [[forms cb] [forms cb {:keys [*current-ns *state custom-load timeout disable-timeout?], :or {*current-ns (atom (quote cljs.user)), *state *cljs-state, custom-load custom-load!, timeout 4000, disable-timeout? false}, :as opts}]]}, :source "(defn\n code->results\n \"Evaluates each form, providing the results in a callback.\\n  If any of the forms are strings, it will read them first.\"\n ([forms cb] (code->results forms cb {}))\n ([forms\n   cb\n   {:keys [*current-ns *state custom-load timeout disable-timeout?],\n    :or\n    {*current-ns (atom 'cljs.user),\n     *state *cljs-state,\n     custom-load custom-load!,\n     timeout 4000,\n     disable-timeout? false},\n    :as opts}]\n  (let\n   [init-forms\n    (vec\n     (concat\n      ['(ns cljs.user)]\n      (when-not\n       disable-timeout?\n       ['(def ps-last-time (atom 0))\n        '(defn\n          ps-reset-timeout!\n          []\n          (reset! ps-last-time (.getTime (js/Date.))))\n        '(defn\n          ps-check-for-timeout!\n          [timeout]\n          (when\n           (> (- (.getTime (js/Date.)) @ps-last-time) timeout)\n           (throw (js/Error. \"Execution timed out.\"))))])\n      ['(set! *print-err-fn* (fn [_])) (list 'ns @*current-ns)]))\n    timeout-cb\n    (fn\n     [results]\n     (eval-forms\n      (add-timeouts-if-necessary timeout forms results)\n      cb\n      *state\n      *current-ns\n      custom-load))\n    init-cb\n    (fn\n     [results]\n     (eval-forms\n      (if disable-timeout? forms (map wrap-macroexpand forms))\n      (if disable-timeout? cb timeout-cb)\n      *state\n      *current-ns\n      custom-load))]\n   (eval-forms init-forms init-cb *state *current-ns custom-load))))\n", :examples [{:doc "Define a var and then use it.", :with-callback callback, :body (code->results [(quote (def n 4)) (quote (conj [1 2 3] n))] callback), :body-str "(code->results ['(def n 4) '(conj [1 2 3] n)] callback)\n", :id "eval-soup.core/code->results/0"} {:doc "You can use strings too.", :with-callback callback, :body (code->results ["(def n 4)" "(conj [1 2 3] n)"] callback), :body-str "(code->results [\"(def n 4)\" \"(conj [1 2 3] n)\"] callback)\n", :id "eval-soup.core/code->results/1"} {:doc "Timeout after two seconds.\n   \n   You can turn off timeout protection by passing `:disable-timeout? true`\n   in the options map.", :with-callback callback, :body (code->results [(quote (while true))] callback {:timeout 1000}), :body-str "(code->results ['(while true)] callback {:timeout 1000})\n", :id "eval-soup.core/code->results/2"}]}], :rel-path "../../"}</script>
        <script type="text/javascript" src="../../main.js"></script>
    </body>
</html>
