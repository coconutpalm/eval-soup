<!doctype html>
<html>
    <head>
        <meta charset="UTF-8">
        <link rel="stylesheet" type="text/css" href="../style.css">
        <link rel="stylesheet" type="text/css" href="../paren-soup-light.css">
    </head>
    <body>
        <span id="app"><div data-reactroot="" data-reactid="1" data-react-checksum="575337731"><div data-reactid="2"><div class="nses" data-reactid="3"><div data-reactid="4"><a href="../clj/eval-soup.core.html" data-reactid="5">eval-soup.core</a></div><div data-reactid="6"><div class="tag" data-reactid="7">CLJS</div><a href="../cljs/eval-soup.core.html" data-reactid="8">eval-soup.core</a></div></div></div><div style="left:300px;" class="vars" data-reactid="9"><!-- react-empty: 10 --><div data-reactid="11"><center data-reactid="12"><h1 data-reactid="13">eval-soup.core</h1></center></div><div class="var-info" data-reactid="14"><a href="../clj/eval-soup.core/code-&#x27;g&#x27;results.html" data-reactid="15"><h2 data-reactid="16">(code-&gt;results forms)</h2><h2 data-reactid="17">(code-&gt;results forms {:keys [timeout disable-timeout? disable-security?], :or {timeout 4000, disable-timeout? false, disable-security? false}, :as opts})</h2></a><div class="section doc" data-reactid="18">Returns a vector of the evaluated result of each of the given forms.
  If any of the forms are strings, it will read them first.</div><div class="section" data-reactid="19"><h2 data-reactid="20">Example</h2><div class="section" data-reactid="21"><div class="section doc" data-reactid="22">You can reference vars you previously made.</div><div class="paren-soup" data-reactid="23"><div style="display:none;" class="instarepl" data-reactid="24"></div><div class="content" data-reactid="25"><span class='collection list'><span class='delimiter'>(</span><span class='symbol'>code-&gt;results</span> <span class='collection vector'><span class='delimiter'>[</span>&apos;<span class='collection list'><span class='delimiter'>(</span><span class='symbol'>def</span> <span class='symbol'>n</span> <span class='number'>4</span><span class='delimiter'>)</span></span> &apos;<span class='collection list'><span class='delimiter'>(</span><span class='symbol'>conj</span> <span class='collection vector'><span class='delimiter'>[</span><span class='number'>1</span> <span class='number'>2</span> <span class='number'>3</span><span class='delimiter'>]</span></span> <span class='symbol'>n</span><span class='delimiter'>)</span></span><span class='delimiter'>]</span></span><span class='delimiter'>)</span></span>
</div></div></div><div class="section" data-reactid="26"><div class="section doc" data-reactid="27">You can pass the code as strings too.</div><div class="paren-soup" data-reactid="28"><div style="display:none;" class="instarepl" data-reactid="29"></div><div class="content" data-reactid="30"><span class='collection list'><span class='delimiter'>(</span><span class='symbol'>code-&gt;results</span> <span class='collection vector'><span class='delimiter'>[</span><span class='string'>&quot;(def n 4)&quot;</span> <span class='string'>&quot;(conj [1 2 3] n)&quot;</span><span class='delimiter'>]</span></span><span class='delimiter'>)</span></span>
</div></div></div><div class="section" data-reactid="31"><div class="section doc" data-reactid="32">If your code exceeds the timeout, you&#x27;ll see an exception.
   
   You can turn off timeout protection by passing `:disable-timeout? true`
   in the options map.</div><div class="paren-soup" data-reactid="33"><div style="display:none;" class="instarepl" data-reactid="34"></div><div class="content" data-reactid="35"><span class='collection list'><span class='delimiter'>(</span><span class='symbol'>code-&gt;results</span> <span class='collection vector'><span class='delimiter'>[</span>&apos;<span class='collection list'><span class='delimiter'>(</span><span class='symbol'>while</span> <span class='boolean'>true</span><span class='delimiter'>)</span></span><span class='delimiter'>]</span></span> <span class='collection map'><span class='delimiter'>{</span><span class='keyword'>:timeout</span> <span class='number'>1000</span><span class='delimiter'>}</span></span><span class='delimiter'>)</span></span>
</div></div></div><div class="section" data-reactid="36"><div class="section doc" data-reactid="37">If your code tries to exit, you&#x27;ll see an exception.
   
   You can turn off exit protection by passing `:disable-security? true`
   in the options map.</div><div class="paren-soup" data-reactid="38"><div style="display:none;" class="instarepl" data-reactid="39"></div><div class="content" data-reactid="40"><span class='collection list'><span class='delimiter'>(</span><span class='symbol'>code-&gt;results</span> <span class='collection vector'><span class='delimiter'>[</span>&apos;<span class='collection list'><span class='delimiter'>(</span><span class='symbol'>System/exit</span> <span class='number'>0</span><span class='delimiter'>)</span></span><span class='delimiter'>]</span></span><span class='delimiter'>)</span></span>
</div></div></div></div><div class="section" data-reactid="41"><a href="../clj/eval-soup.core/code-&#x27;g&#x27;results.html" data-reactid="42"><h3 data-reactid="43">+ Source</h3></a></div></div><div class="var-info" data-reactid="44"><a href="../clj/eval-soup.core/with-security.html" data-reactid="45"><h2 data-reactid="46">(with-security &amp; body)</h2></a><div class="section doc" data-reactid="47">Convenience macro that wraps the body with wrap-security
  and then immediately executes it.</div><div class="section" data-reactid="48"><a href="../clj/eval-soup.core/with-security.html" data-reactid="49"><h3 data-reactid="50">+ Source</h3></a></div></div><div class="var-info" data-reactid="51"><a href="../clj/eval-soup.core/wrap-security.html" data-reactid="52"><h2 data-reactid="53">(wrap-security thunk)</h2></a><div class="section doc" data-reactid="54">Returns a function that wraps the given function in a sandbox.
  It uses eval_soup/java.policy to define permissions. By default,
  it only disallows exiting via System/exit.</div><div class="section" data-reactid="55"><a href="../clj/eval-soup.core/wrap-security.html" data-reactid="56"><h3 data-reactid="57">+ Source</h3></a></div></div><div class="var-info" data-reactid="58"><a href="../clj/eval-soup.core/wrap-timeout.html" data-reactid="59"><h2 data-reactid="60">(wrap-timeout thunk timeout)</h2></a><div class="section doc" data-reactid="61">Returns a function that wraps the given function in a timeout checker.
  The timeout is specified in milliseconds. If the timeout is reached,
  an exceptino will be thrown.</div><div class="section" data-reactid="62"><a href="../clj/eval-soup.core/wrap-timeout.html" data-reactid="63"><h3 data-reactid="64">+ Source</h3></a></div></div><div class="footer" data-reactid="65"><!-- react-text: 66 -->Generated by <!-- /react-text --><a href="https://github.com/oakes/Dynadoc" target="_blank" data-reactid="67">Dynadoc</a></div></div></div></span>
        <script type="text/edn" id="initial-state">{:type :clj, :ns-sym eval-soup.core, :static? true, :cljs-nses-and-vars {cljs.core ({:sym sort-by, :meta {:doc "Returns a sorted sequence of the items in coll, where the sort\n   order is determined by comparing (keyfn item).  Comp can be\n   boolean-valued comparison funcion, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :arglists [[keyfn coll] [keyfn comp coll]]}, :source "(defn\n sort-by\n \"Returns a sorted sequence of the items in coll, where the sort\\n   order is determined by comparing (keyfn item).  Comp can be\\n   boolean-valued comparison funcion, or a -/0/+ valued comparator.\\n   Comp defaults to compare.\"\n ([keyfn coll] (sort-by keyfn compare coll))\n ([keyfn comp coll]\n  (sort (fn [x y] ((fn->comparator comp) (keyfn x) (keyfn y))) coll)))\n"} {:sym ITransientAssociative, :meta {:doc "Protocol for adding associativity to transient collections."}, :methods (-assoc!)} {:sym chunk-first, :meta {:doc nil, :arglists ([s])}, :source "(defn chunk-first [s] (-chunked-first s))\n"} {:sym m3-hash-int, :meta {:doc nil, :arglists ([in])}, :source "(defn\n m3-hash-int\n [in]\n (if\n  (zero? in)\n  in\n  (let [k1 (m3-mix-K1 in) h1 (m3-mix-H1 m3-seed k1)] (m3-fmix h1 4))))\n"} {:sym pr-str*, :meta {:doc "Support so that collections can implement toString without\n   loading all the printing machinery.", :arglists ([obj])}, :source "(defn\n pr-str*\n \"Support so that collections can implement toString without\\n   loading all the printing machinery.\"\n [obj]\n (let\n  [sb (StringBuffer.) writer (StringBufferWriter. sb)]\n  (-pr-writer obj writer (pr-opts))\n  (-flush writer)\n  (str sb)))\n"} {:sym tree-seq, :meta {:doc "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n  branch? must be a fn of one arg that returns true if passed a node\n  that can have children (but may not).  children must be a fn of one\n  arg that returns a sequence of the children. Will only be called on\n  nodes for which branch? returns true. Root is the root node of the\n  tree.", :arglists ([branch? children root])}, :source "(defn\n tree-seq\n \"Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\\n  branch? must be a fn of one arg that returns true if passed a node\\n  that can have children (but may not).  children must be a fn of one\\n  arg that returns a sequence of the children. Will only be called on\\n  nodes for which branch? returns true. Root is the root node of the\\n  tree.\"\n [branch? children root]\n (let\n  [walk\n   (fn\n    walk\n    [node]\n    (lazy-seq\n     (cons node (when (branch? node) (mapcat walk (children node))))))]\n  (walk root)))\n"} {:sym unchecked-remainder-int, :meta {:doc nil, :arglists ([x n])}, :source "(defn\n unchecked-remainder-int\n [x n]\n (cljs.core/unchecked-remainder-int x n))\n"} {:sym seq, :meta {:doc "Returns a seq on the collection. If the collection is\n  empty, returns nil.  (seq nil) returns nil. seq also works on\n  Strings.", :arglists ([coll])}, :source "(defn\n seq\n \"Returns a seq on the collection. If the collection is\\n  empty, returns nil.  (seq nil) returns nil. seq also works on\\n  Strings.\"\n [coll]\n (when-not\n  (nil? coll)\n  (cond\n   (implements? ISeqable coll)\n   (-seq coll)\n   (array? coll)\n   (when-not (zero? (alength coll)) (IndexedSeq. coll 0 nil))\n   (string? coll)\n   (when-not (zero? (alength coll)) (IndexedSeq. coll 0 nil))\n   (native-satisfies? ISeqable coll)\n   (-seq coll)\n   :else\n   (throw (js/Error. (str coll \" is not ISeqable\"))))))\n"} {:sym reduce, :meta {:doc "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called.", :arglists [[f coll] [f val coll]]}, :source "(defn\n reduce\n \"f should be a function of 2 arguments. If val is not supplied,\\n  returns the result of applying f to the first 2 items in coll, then\\n  applying f to that result and the 3rd item, etc. If coll contains no\\n  items, f must accept no arguments as well, and reduce returns the\\n  result of calling f with no arguments.  If coll has only 1 item, it\\n  is returned and f is not called.  If val is supplied, returns the\\n  result of applying f to val and the first item in coll, then\\n  applying f to that result and the 2nd item, etc. If coll contains no\\n  items, returns val and f is not called.\"\n ([f coll]\n  (cond\n   (implements? IReduce coll)\n   (-reduce coll f)\n   (array? coll)\n   (array-reduce coll f)\n   (string? coll)\n   (array-reduce coll f)\n   (native-satisfies? IReduce coll)\n   (-reduce coll f)\n   (iterable? coll)\n   (iter-reduce coll f)\n   :else\n   (seq-reduce f coll)))\n ([f val coll]\n  (cond\n   (implements? IReduce coll)\n   (-reduce coll f val)\n   (array? coll)\n   (array-reduce coll f val)\n   (string? coll)\n   (array-reduce coll f val)\n   (native-satisfies? IReduce coll)\n   (-reduce coll f val)\n   (iterable? coll)\n   (iter-reduce coll f val)\n   :else\n   (seq-reduce f val coll))))\n"} {:sym contains?, :meta {:doc "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'.", :arglists ([coll v])}, :source "(defn\n contains?\n \"Returns true if key is present in the given collection, otherwise\\n  returns false.  Note that for numerically indexed collections like\\n  vectors and arrays, this tests if the numeric key is within the\\n  range of indexes. 'contains?' operates constant or logarithmic time;\\n  it will not perform a linear search for a value.  See also 'some'.\"\n [coll v]\n (if\n  (identical? (get coll v lookup-sentinel) lookup-sentinel)\n  false\n  true))\n"} {:sym every?, :meta {:doc "Returns true if (pred x) is logical true for every x in coll, else\n  false.", :arglists ([pred coll])}, :source "(defn\n every?\n \"Returns true if (pred x) is logical true for every x in coll, else\\n  false.\"\n [pred coll]\n (cond\n  (nil? (seq coll))\n  true\n  (pred (first coll))\n  (recur pred (next coll))\n  :else\n  false))\n"} {:sym keep-indexed, :meta {:doc "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided.", :arglists [[f] [f coll]]}, :source "(defn\n keep-indexed\n \"Returns a lazy sequence of the non-nil results of (f index item). Note,\\n  this means false return values will be included.  f must be free of\\n  side-effects.  Returns a stateful transducer when no collection is\\n  provided.\"\n ([f]\n  (fn\n   [rf]\n   (let\n    [ia (volatile! -1)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input]\n      (let\n       [i (vswap! ia inc) v (f i input)]\n       (if (nil? v) result (rf result v))))))))\n ([f coll]\n  (letfn\n   [(keepi\n     [idx coll]\n     (lazy-seq\n      (when-let\n       [s (seq coll)]\n       (if\n        (chunked-seq? s)\n        (let\n         [c (chunk-first s) size (count c) b (chunk-buffer size)]\n         (dotimes\n          [i size]\n          (let\n           [x (f (+ idx i) (-nth c i))]\n           (when-not (nil? x) (chunk-append b x))))\n         (chunk-cons (chunk b) (keepi (+ idx size) (chunk-rest s))))\n        (let\n         [x (f idx (first s))]\n         (if\n          (nil? x)\n          (keepi (inc idx) (rest s))\n          (cons x (keepi (inc idx) (rest s)))))))))]\n   (keepi 0 coll))))\n"} {:sym subs, :meta {:doc "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive.", :arglists [[s start] [s start end]]}, :source "(defn\n subs\n \"Returns the substring of s beginning at start inclusive, and ending\\n  at end (defaults to length of string), exclusive.\"\n ([s start] (.substring s start))\n ([s start end] (.substring s start end)))\n"} {:sym IFind, :meta {:doc "Protocol for implementing entry finding in collections."}, :methods (-find)} {:sym MODULE_URIS, :meta {}, :source "(def MODULE_URIS nil)\n"} {:sym take-last, :meta {:doc "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec.", :arglists ([n coll])}, :source "(defn\n take-last\n \"Returns a seq of the last n items in coll.  Depending on the type\\n  of coll may be no better than linear time.  For vectors, see also subvec.\"\n [n coll]\n (loop\n  [s (seq coll) lead (seq (drop n coll))]\n  (if lead (recur (next s) (next lead)) s)))\n"} {:sym bit-set, :meta {:doc "Set bit at index n", :arglists ([x n])}, :source "(defn bit-set \"Set bit at index n\" [x n] (cljs.core/bit-set x n))\n"} {:sym string-hash-cache-count, :meta {}, :source "(def string-hash-cache-count 0)\n"} {:sym qualified-keyword?, :meta {:doc "Return true if x is a keyword with a namespace", :arglists ([x])}, :source "(defn\n qualified-keyword?\n \"Return true if x is a keyword with a namespace\"\n [x]\n (boolean (and (keyword? x) (namespace x) true)))\n"} {:sym -with-meta, :meta {:doc "Returns a new object with value of o and metadata meta added to it.", :arglists ([o meta])}, :protocol IWithMeta} {:sym unchecked-subtract-int, :meta {:doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n unchecked-subtract-int\n \"If no ys are supplied, returns the negation of x, else subtracts\\n  the ys from x and returns the result.\"\n ([x] (cljs.core/unchecked-subtract-int x))\n ([x y] (cljs.core/unchecked-subtract-int x y))\n ([x y & more]\n  (reduce\n   unchecked-subtract-int\n   (cljs.core/unchecked-subtract-int x y)\n   more)))\n"} {:sym -iterator, :meta {:doc "Returns an iterator for coll.", :arglists ([coll])}, :protocol IIterable} {:sym *print-namespace-maps*, :meta {:doc "*print-namespace-maps* controls whether the printer will print\n  namespace map literal syntax.\n\n  Defaults to false, but the REPL binds it to true."}, :source "(def *print-namespace-maps* false)\n"} {:sym first, :meta {:doc "Returns the first item in the collection. Calls seq on its\n  argument. If coll is nil, returns nil.", :arglists ([coll])}, :source "(defn\n first\n \"Returns the first item in the collection. Calls seq on its\\n  argument. If coll is nil, returns nil.\"\n [coll]\n (when-not\n  (nil? coll)\n  (if\n   (implements? ISeq coll)\n   (-first coll)\n   (let [s (seq coll)] (when-not (nil? s) (-first s))))))\n"} {:sym native-satisfies?, :meta {:doc "Internal - do not use!", :arglists ([p x])}, :source "(defn\n native-satisfies?\n \"Internal - do not use!\"\n [p x]\n (let\n  [x (if (nil? x) nil x)]\n  (cond\n   (unchecked-get p (goog/typeOf x))\n   true\n   (unchecked-get p \"_\")\n   true\n   :else\n   false)))\n"} {:sym seq?, :meta {:doc "Return true if s satisfies ISeq", :arglists ([s])}, :source "(defn\n seq?\n \"Return true if s satisfies ISeq\"\n [s]\n (if (nil? s) false (satisfies? ISeq s)))\n"} {:sym -sorted-seq-from, :meta {:doc "Returns a sorted seq from coll in either ascending or descending order.\n     If ascending is true, the result should contain all items which are > or >=\n     than k. If ascending is false, the result should contain all items which\n     are < or <= than k, e.g.\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) => (3 4 5)\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) => (3 2 1)", :arglists ([coll k ascending?])}, :protocol ISorted} {:sym inst-ms, :meta {:doc "Return the number of milliseconds since January 1, 1970, 00:00:00 GMT", :arglists ([inst])}, :source "(defn\n inst-ms\n \"Return the number of milliseconds since January 1, 1970, 00:00:00 GMT\"\n [inst]\n (inst-ms* inst))\n"} {:sym iterate, :meta {:doc "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects", :arglists ([f x])}, :source "(defn\n iterate\n \"Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects\"\n {:added \"1.0\"}\n [f x]\n (cons x (lazy-seq (iterate f (f x)))))\n"} {:sym -empty, :meta {:doc "Returns an empty collection of the same category as coll. Used\n     by cljs.core/empty.", :arglists ([coll])}, :protocol IEmptyableCollection} {:sym ILookup, :meta {:doc "Protocol for looking up a value in a data structure."}, :methods (-lookup)} {:sym -chunked-rest, :meta {:doc "Return a new collection of coll with the first chunk removed.", :arglists ([coll])}, :protocol IChunkedSeq} {:sym fn?, :meta {:doc "Return true if f is a JavaScript function or satisfies the Fn protocol.", :arglists ([f])}, :source "(defn\n fn?\n \"Return true if f is a JavaScript function or satisfies the Fn protocol.\"\n [f]\n (or (goog/isFunction f) (satisfies? Fn f)))\n"} {:sym -assoc, :meta {:doc "Returns a new collection of coll with a mapping from key k to\n     value v added to it.", :arglists ([coll k v])}, :protocol IAssociative} {:sym keyword-identical?, :meta {:doc "Efficient test to determine that two keywords are identical.", :arglists ([x y])}, :source "(defn\n keyword-identical?\n \"Efficient test to determine that two keywords are identical.\"\n [x y]\n (if\n  (identical? x y)\n  true\n  (if\n   (and (keyword? x) (keyword? y))\n   (identical? (.-fqn x) (.-fqn y))\n   false)))\n"} {:sym *print-err-fn*, :meta {:doc "Each runtime environment provides a different way to print error output.\n  Whatever function *print-err-fn* is bound to will be passed any\n  Strings which should be printed."}, :source "(defonce *print-err-fn* nil)\n"} {:sym dissoc, :meta {:doc "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s).", :arglists [[coll] [coll k] [coll k & ks]]}, :source "(defn\n dissoc\n \"dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\\n  that does not contain a mapping for key(s).\"\n ([coll] coll)\n ([coll k] (when-not (nil? coll) (-dissoc coll k)))\n ([coll k & ks]\n  (when-not\n   (nil? coll)\n   (let\n    [ret (dissoc coll k)]\n    (if ks (recur ret (first ks) (next ks)) ret)))))\n"} {:sym atom, :meta {:doc "Creates and returns an Atom with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  If metadata-map is supplied, it will be come the metadata on the\n  atom. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an Error.  If either of these error conditions\n  occur, then the value of the atom will not change.", :arglists [[x] [x & {:keys [meta validator]}]]}, :source "(defn\n atom\n \"Creates and returns an Atom with an initial value of x and zero or\\n  more options (in any order):\\n\\n  :meta metadata-map\\n\\n  :validator validate-fn\\n\\n  If metadata-map is supplied, it will be come the metadata on the\\n  atom. validate-fn must be nil or a side-effect-free fn of one\\n  argument, which will be passed the intended new state on any state\\n  change. If the new state is unacceptable, the validate-fn should\\n  return false or throw an Error.  If either of these error conditions\\n  occur, then the value of the atom will not change.\"\n ([x] (Atom. x nil nil nil))\n ([x & {:keys [meta validator]}] (Atom. x meta validator nil)))\n"} {:sym bit-shift-right, :meta {:doc "Bitwise shift right", :arglists ([x n])}, :source "(defn\n bit-shift-right\n \"Bitwise shift right\"\n [x n]\n (cljs.core/bit-shift-right x n))\n"} {:sym *clojurescript-version*, :meta {}, :source "(def *clojurescript-version* \"1.9.946\")\n"} {:sym -first, :meta {:doc "Returns the first item in the collection coll. Used by cljs.core/first.", :arglists ([coll])}, :protocol ISeq} {:sym peek, :meta {:doc "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil.", :arglists ([coll])}, :source "(defn\n peek\n \"For a list or queue, same as first, for a vector, same as, but much\\n  more efficient than, last. If the collection is empty, returns nil.\"\n [coll]\n (when-not (nil? coll) (-peek coll)))\n"} {:sym IKVReduce, :meta {:doc "Protocol for associative types that can reduce themselves\n  via a function of key and val. Called by cljs.core/reduce-kv."}, :methods (-kv-reduce)} {:sym aget, :meta {:doc "Returns the value at the index/indices. Works on JavaScript arrays.", :arglists [[array idx] [array idx & idxs]]}, :source "(defn\n aget\n \"Returns the value at the index/indices. Works on JavaScript arrays.\"\n ([array idx] (cljs.core/aget array idx))\n ([array idx & idxs] (apply aget (aget array idx) idxs)))\n"} {:sym -write, :meta {:doc "Writes s with writer and returns the result.", :arglists ([writer s])}, :protocol IWriter} {:sym iter, :meta {:doc nil, :arglists ([coll])}, :source "(defn\n iter\n [coll]\n (cond\n  (iterable? coll)\n  (-iterator coll)\n  (nil? coll)\n  (nil-iter)\n  (string? coll)\n  (string-iter coll)\n  (array? coll)\n  (array-iter coll)\n  (seqable? coll)\n  (seq-iter coll)\n  :else\n  (throw (js/Error. (str \"Cannot create iterator from \" coll)))))\n"} {:sym last, :meta {:doc "Return the last item in coll, in linear time", :arglists ([s])}, :source "(defn\n last\n \"Return the last item in coll, in linear time\"\n [s]\n (let [sn (next s)] (if-not (nil? sn) (recur sn) (first s))))\n"} {:sym namespace, :meta {:doc "Returns the namespace String of a symbol or keyword, or nil if not present.", :arglists ([x])}, :source "(defn\n namespace\n \"Returns the namespace String of a symbol or keyword, or nil if not present.\"\n [x]\n (if\n  (implements? INamed x)\n  (-namespace x)\n  (throw (js/Error. (str \"Doesn't support namespace: \" x)))))\n"} {:sym -conj, :meta {:doc "Returns a new collection of coll with o added to it. The new item\n     should be added to the most efficient place, e.g.\n     (conj [1 2 3 4] 5) => [1 2 3 4 5]\n     (conj '(2 3 4 5) 1) => '(1 2 3 4 5)", :arglists ([coll o])}, :protocol ICollection} {:sym =, :meta {:doc "Equality. Returns true if x equals y, false if not. Compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define -equiv (and thus =) as a value, not an identity,\n  comparison.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n =\n \"Equality. Returns true if x equals y, false if not. Compares\\n  numbers and collections in a type-independent manner.  Clojure's immutable data\\n  structures define -equiv (and thus =) as a value, not an identity,\\n  comparison.\"\n ([x] true)\n ([x y] (if (nil? x) (nil? y) (or (identical? x y) (-equiv x y))))\n ([x y & more]\n  (if\n   (= x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (= y (first more)))\n   false)))\n"} {:sym ITransientMap, :meta {:doc "Protocol for adding mapping functionality to transient collections."}, :methods (-dissoc!)} {:sym take, :meta {:doc "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided.", :arglists [[n] [n coll]]}, :source "(defn\n take\n \"Returns a lazy sequence of the first n items in coll, or all items if\\n  there are fewer than n.  Returns a stateful transducer when\\n  no collection is provided.\"\n ([n]\n  {:pre [(number? n)]}\n  (fn\n   [rf]\n   (let\n    [na (volatile! n)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input]\n      (let\n       [n\n        @na\n        nn\n        (vswap! na dec)\n        result\n        (if (pos? n) (rf result input) result)]\n       (if (not (pos? nn)) (ensure-reduced result) result)))))))\n ([n coll]\n  {:pre [(number? n)]}\n  (lazy-seq\n   (when\n    (pos? n)\n    (when-let\n     [s (seq coll)]\n     (cons (first s) (take (dec n) (rest s))))))))\n"} {:sym vector?, :meta {:doc "Return true if x satisfies IVector", :arglists ([x])}, :source "(defn\n vector?\n \"Return true if x satisfies IVector\"\n [x]\n (satisfies? IVector x))\n"} {:sym boolean, :meta {:doc "Coerce to boolean", :arglists ([x])}, :source "(defn\n boolean\n \"Coerce to boolean\"\n [x]\n (cond (nil? x) false (false? x) false :else true))\n"} {:sym IChunk, :meta {:doc "Protocol for accessing the items of a chunk."}, :methods (-drop-first)} {:sym bit-shift-left, :meta {:doc "Bitwise shift left", :arglists ([x n])}, :source "(defn\n bit-shift-left\n \"Bitwise shift left\"\n [x n]\n (cljs.core/bit-shift-left x n))\n"} {:sym any?, :meta {:doc "Returns true if given any argument.", :arglists ([x])}, :source "(defn any? \"Returns true if given any argument.\" [x] true)\n"} {:sym aclone, :meta {:doc "Returns a javascript array, cloned from the passed in array", :arglists ([arr])}, :source "(defn\n aclone\n \"Returns a javascript array, cloned from the passed in array\"\n [arr]\n (let\n  [len (alength arr) new-arr (make-array len)]\n  (dotimes [i len] (aset new-arr i (aget arr i)))\n  new-arr))\n"} {:sym vreset!, :meta {:doc "Sets the value of volatile to newval without regard for the\n   current value. Returns newval.", :arglists ([vol newval])}, :source "(defn\n vreset!\n \"Sets the value of volatile to newval without regard for the\\n   current value. Returns newval.\"\n [vol newval]\n (-vreset! vol newval))\n"} {:sym chunk, :meta {:doc nil, :arglists ([b])}, :source "(defn chunk [b] (.chunk b))\n"} {:sym dec, :meta {:doc "Returns a number one less than num.", :arglists ([x])}, :source "(defn dec \"Returns a number one less than num.\" [x] (- x 1))\n"} {:sym APersistentVector, :meta {:doc "Marker protocol"}, :methods ()} {:sym map, :meta {:doc "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided.", :arglists [[f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]]}, :source "(defn\n map\n \"Returns a lazy sequence consisting of the result of applying f to\\n  the set of first items of each coll, followed by applying f to the\\n  set of second items in each coll, until any one of the colls is\\n  exhausted.  Any remaining items in other colls are ignored. Function\\n  f should accept number-of-colls arguments. Returns a transducer when\\n  no collection is provided.\"\n ([f]\n  (fn\n   [rf]\n   (fn\n    ([] (rf))\n    ([result] (rf result))\n    ([result input] (rf result (f input)))\n    ([result input & inputs] (rf result (apply f input inputs))))))\n ([f coll]\n  (lazy-seq\n   (when-let\n    [s (seq coll)]\n    (if\n     (chunked-seq? s)\n     (let\n      [c (chunk-first s) size (count c) b (chunk-buffer size)]\n      (dotimes [i size] (chunk-append b (f (-nth c i))))\n      (chunk-cons (chunk b) (map f (chunk-rest s))))\n     (cons (f (first s)) (map f (rest s)))))))\n ([f c1 c2]\n  (lazy-seq\n   (let\n    [s1 (seq c1) s2 (seq c2)]\n    (when\n     (and s1 s2)\n     (cons (f (first s1) (first s2)) (map f (rest s1) (rest s2)))))))\n ([f c1 c2 c3]\n  (lazy-seq\n   (let\n    [s1 (seq c1) s2 (seq c2) s3 (seq c3)]\n    (when\n     (and s1 s2 s3)\n     (cons\n      (f (first s1) (first s2) (first s3))\n      (map f (rest s1) (rest s2) (rest s3)))))))\n ([f c1 c2 c3 & colls]\n  (let\n   [step\n    (fn\n     step\n     [cs]\n     (lazy-seq\n      (let\n       [ss (map seq cs)]\n       (when\n        (every? identity ss)\n        (cons (map first ss) (step (map rest ss)))))))]\n   (map\n    (fn* [p1__18133#] (apply f p1__18133#))\n    (step (conj colls c3 c2 c1))))))\n"} {:sym <, :meta {:doc "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n <\n \"Returns non-nil if nums are in monotonically increasing order,\\n  otherwise false.\"\n ([x] true)\n ([x y] (cljs.core/< x y))\n ([x y & more]\n  (if\n   (cljs.core/< x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (cljs.core/< y (first more)))\n   false)))\n"} {:sym rest, :meta {:doc "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument.", :arglists ([coll])}, :source "(defn\n rest\n \"Returns a possibly empty seq of the items after the first. Calls seq on its\\n  argument.\"\n [coll]\n (if-not\n  (nil? coll)\n  (if\n   (implements? ISeq coll)\n   (-rest coll)\n   (let [s (seq coll)] (if s (-rest s) ())))\n  ()))\n"} {:sym -drop-first, :meta {:doc "Return a new chunk of coll with the first item removed.", :arglists ([coll])}, :protocol IChunk} {:sym boolean?, :meta {:doc "Return true if x is a Boolean", :arglists ([x])}, :source "(defn\n boolean?\n \"Return true if x is a Boolean\"\n [x]\n (or (cljs.core/true? x) (cljs.core/false? x)))\n"} {:sym -clone, :meta {:doc "Creates a clone of value.", :arglists ([value])}, :protocol ICloneable} {:sym char?, :meta {:doc "Returns true if x is a JavaScript string of length one.", :arglists ([x])}, :source "(defn\n char?\n \"Returns true if x is a JavaScript string of length one.\"\n [x]\n (and (string? x) (== 1 (.-length x))))\n"} {:sym -reduce, :meta {:doc "f should be a function of 2 arguments. If start is not supplied,\n     returns the result of applying f to the first 2 items in coll, then\n     applying f to that result and the 3rd item, etc.", :arglists ([coll f] [coll f start])}, :protocol IReduce} {:sym -count, :meta {:doc "Calculates the count of coll in constant time. Used by cljs.core/count.", :arglists ([coll])}, :protocol ICounted} {:sym swap-vals!, :meta {:doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.\n  Returns [old new], the value of the atom before and after the swap.", :arglists [[a f] [a f x] [a f x y] [a f x y & more]]}, :source "(defn\n swap-vals!\n \"Atomically swaps the value of atom to be:\\n  (apply f current-value-of-atom args). Note that f may be called\\n  multiple times, and thus should be free of side effects.\\n  Returns [old new], the value of the atom before and after the swap.\"\n {:added \"1.9\"}\n ([a f] (reset-vals! a (f (.-state a))))\n ([a f x] (reset-vals! a (f (.-state a) x)))\n ([a f x y] (reset-vals! a (f (.-state a) x y)))\n ([a f x y & more] (reset-vals! a (apply f (.-state a) x y more))))\n"} {:sym keep, :meta {:doc "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided.", :arglists [[f] [f coll]]}, :source "(defn\n keep\n \"Returns a lazy sequence of the non-nil results of (f item). Note,\\n  this means false return values will be included.  f must be free of\\n  side-effects.  Returns a transducer when no collection is provided.\"\n ([f]\n  (fn\n   [rf]\n   (fn\n    ([] (rf))\n    ([result] (rf result))\n    ([result input]\n     (let [v (f input)] (if (nil? v) result (rf result v)))))))\n ([f coll]\n  (lazy-seq\n   (when-let\n    [s (seq coll)]\n    (if\n     (chunked-seq? s)\n     (let\n      [c (chunk-first s) size (count c) b (chunk-buffer size)]\n      (dotimes\n       [i size]\n       (let [x (f (-nth c i))] (when-not (nil? x) (chunk-append b x))))\n      (chunk-cons (chunk b) (keep f (chunk-rest s))))\n     (let\n      [x (f (first s))]\n      (if (nil? x) (keep f (rest s)) (cons x (keep f (rest s))))))))))\n"} {:sym char, :meta {:doc "Coerce to char", :arglists ([x])}, :source "(defn\n char\n \"Coerce to char\"\n [x]\n (cond\n  (number? x)\n  (.fromCharCode js/String x)\n  (and (string? x) (== (.-length x) 1))\n  x\n  :else\n  (throw (js/Error. \"Argument to char must be a character or number\"))))\n"} {:sym mapcat, :meta {:doc "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided", :arglists [[f] [f & colls]]}, :source "(defn\n mapcat\n \"Returns the result of applying concat to the result of applying map\\n  to f and colls.  Thus function f should return a collection. Returns\\n  a transducer when no collections are provided\"\n {:added \"1.0\", :static true}\n ([f] (comp (map f) cat))\n ([f & colls] (apply concat (apply map f colls))))\n"} {:sym unchecked-long, :meta {:doc "Coerce to long by stripping decimal places. Identical to `int'.", :arglists ([x])}, :source "(defn\n unchecked-long\n \"Coerce to long by stripping decimal places. Identical to `int'.\"\n [x]\n (fix x))\n"} {:sym m3-seed, :meta {}, :source "(def m3-seed 0)\n"} {:sym some?, :meta {:doc "Returns true if x is not nil, false otherwise.", :arglists ([x])}, :source "(defn\n some?\n \"Returns true if x is not nil, false otherwise.\"\n [x]\n (not (nil? x)))\n"} {:sym unchecked-negate, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-negate [x] (cljs.core/unchecked-negate x))\n"} {:sym symbol-identical?, :meta {:doc "Efficient test to determine that two symbols are identical.", :arglists ([x y])}, :source "(defn\n symbol-identical?\n \"Efficient test to determine that two symbols are identical.\"\n [x y]\n (if\n  (identical? x y)\n  true\n  (if\n   (and (symbol? x) (symbol? y))\n   (identical? (.-str x) (.-str y))\n   false)))\n"} {:sym *command-line-args*, :meta {:doc "A sequence of the supplied command line arguments, or nil if\n  none were supplied"}, :source "(def *command-line-args* nil)\n"} {:sym reverse, :meta {:doc "Returns a seq of the items in coll in reverse order. Not lazy.", :arglists ([coll])}, :source "(defn\n reverse\n \"Returns a seq of the items in coll in reverse order. Not lazy.\"\n [coll]\n (if (reversible? coll) (rseq coll) (reduce conj () coll)))\n"} {:sym inst?, :meta {:doc "Return true if x satisfies Inst", :arglists ([x])}, :source "(defn inst? \"Return true if x satisfies Inst\" [x] (satisfies? Inst x))\n"} {:sym bit-count, :meta {:doc "Counts the number of bits set in n", :arglists ([v])}, :source "(defn\n bit-count\n \"Counts the number of bits set in n\"\n [v]\n (let\n  [v\n   (- v (bit-and (bit-shift-right v 1) 1431655765))\n   v\n   (+ (bit-and v 858993459) (bit-and (bit-shift-right v 2) 858993459))]\n  (bit-shift-right\n   (* (bit-and (+ v (bit-shift-right v 4)) 252645135) 16843009)\n   24)))\n"} {:sym sort, :meta {:doc "Returns a sorted sequence of the items in coll. Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :arglists [[coll] [comp coll]]}, :source "(defn\n sort\n \"Returns a sorted sequence of the items in coll. Comp can be\\n   boolean-valued comparison function, or a -/0/+ valued comparator.\\n   Comp defaults to compare.\"\n ([coll] (sort compare coll))\n ([comp coll]\n  (if\n   (seq coll)\n   (let\n    [a (to-array coll)]\n    (garray/stableSort a (fn->comparator comp))\n    (seq a))\n   ())))\n"} {:sym unchecked-inc-int, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-inc-int [x] (cljs.core/unchecked-inc-int x))\n"} {:sym -compare, :meta {:doc "Returns a negative number, zero, or a positive number when x is logically\n     'less than', 'equal to', or 'greater than' y.", :arglists ([x y])}, :protocol IComparable} {:sym map-indexed, :meta {:doc "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item. Returns a stateful transducer when\n  no collection is provided.", :arglists [[f] [f coll]]}, :source "(defn\n map-indexed\n \"Returns a lazy sequence consisting of the result of applying f to 0\\n  and the first item of coll, followed by applying f to 1 and the second\\n  item in coll, etc, until coll is exhausted. Thus function f should\\n  accept 2 arguments, index and item. Returns a stateful transducer when\\n  no collection is provided.\"\n ([f]\n  (fn\n   [rf]\n   (let\n    [i (volatile! -1)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input] (rf result (f (vswap! i inc) input)))))))\n ([f coll]\n  (letfn\n   [(mapi\n     [idx coll]\n     (lazy-seq\n      (when-let\n       [s (seq coll)]\n       (if\n        (chunked-seq? s)\n        (let\n         [c (chunk-first s) size (count c) b (chunk-buffer size)]\n         (dotimes [i size] (chunk-append b (f (+ idx i) (-nth c i))))\n         (chunk-cons (chunk b) (mapi (+ idx size) (chunk-rest s))))\n        (cons (f idx (first s)) (mapi (inc idx) (rest s)))))))]\n   (mapi 0 coll))))\n"} {:sym comp, :meta {:doc "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc.", :arglists [[] [f] [f g] [f g h] [f1 f2 f3 & fs]]}, :source "(defn\n comp\n \"Takes a set of functions and returns a fn that is the composition\\n  of those fns.  The returned fn takes a variable number of args,\\n  applies the rightmost of fns to the args, the next\\n  fn (right-to-left) to the result, etc.\"\n ([] identity)\n ([f] f)\n ([f g]\n  (fn\n   ([] (f (g)))\n   ([x] (f (g x)))\n   ([x y] (f (g x y)))\n   ([x y z] (f (g x y z)))\n   ([x y z & args] (f (apply g x y z args)))))\n ([f g h]\n  (fn\n   ([] (f (g (h))))\n   ([x] (f (g (h x))))\n   ([x y] (f (g (h x y))))\n   ([x y z] (f (g (h x y z))))\n   ([x y z & args] (f (g (apply h x y z args))))))\n ([f1 f2 f3 & fs]\n  (let\n   [fs (reverse (list* f1 f2 f3 fs))]\n   (fn\n    [& args]\n    (loop\n     [ret (apply (first fs) args) fs (next fs)]\n     (if fs (recur ((first fs) ret) (next fs)) ret))))))\n"} {:sym array-chunk, :meta {:doc nil, :arglists [[arr] [arr off] [arr off end]]}, :source "(defn\n array-chunk\n ([arr] (ArrayChunk. arr 0 (alength arr)))\n ([arr off] (ArrayChunk. arr off (alength arr)))\n ([arr off end] (ArrayChunk. arr off end)))\n"} {:sym bit-shift-right-zero-fill, :meta {:doc "DEPRECATED: Bitwise shift right with zero fill", :arglists ([x n])}, :source "(defn\n bit-shift-right-zero-fill\n \"DEPRECATED: Bitwise shift right with zero fill\"\n [x n]\n (cljs.core/bit-shift-right-zero-fill x n))\n"} {:sym -as-transient, :meta {:doc "Returns a new, transient version of the collection, in constant time.", :arglists ([coll])}, :protocol IEditableCollection} {:sym simple-symbol?, :meta {:doc "Return true if x is a symbol without a namespace", :arglists ([x])}, :source "(defn\n simple-symbol?\n \"Return true if x is a symbol without a namespace\"\n [x]\n (and (symbol? x) (nil? (namespace x))))\n"} {:sym IIndexed, :meta {:doc "Protocol for collections to provide indexed-based access to their items."}, :methods (-nth)} {:sym disj, :meta {:doc "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s).", :arglists [[coll] [coll k] [coll k & ks]]}, :source "(defn\n disj\n \"disj[oin]. Returns a new set of the same (hashed/sorted) type, that\\n  does not contain key(s).\"\n ([coll] coll)\n ([coll k] (when-not (nil? coll) (-disjoin coll k)))\n ([coll k & ks]\n  (when-not\n   (nil? coll)\n   (let\n    [ret (disj coll k)]\n    (if ks (recur ret (first ks) (next ks)) ret)))))\n"} {:sym IPrintWithWriter, :meta {:doc "The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append."}, :methods (-pr-writer)} {:sym IVector, :meta {:doc "Protocol for adding vector functionality to collections."}, :methods (-assoc-n)} {:sym IIterable, :meta {:doc "Protocol for iterating over a collection."}, :methods (-iterator)} {:sym cons, :meta {:doc "Returns a new seq where x is the first element and coll is the rest.", :arglists ([x coll])}, :source "(defn\n cons\n \"Returns a new seq where x is the first element and coll is the rest.\"\n [x coll]\n (if\n  (or (nil? coll) (implements? ISeq coll))\n  (Cons. nil x coll nil)\n  (Cons. nil x (seq coll) nil)))\n"} {:sym floats, :meta {:doc nil, :arglists ([x])}, :source "(defn floats [x] x)\n"} {:sym pos?, :meta {:doc "Returns true if num is greater than zero, else false", :arglists ([x])}, :source "(defn\n pos?\n \"Returns true if num is greater than zero, else false\"\n [x]\n (cljs.core/pos? x))\n"} {:sym fnil, :meta {:doc "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched.", :arglists [[f x] [f x y] [f x y z]]}, :source "(defn\n fnil\n \"Takes a function f, and returns a function that calls f, replacing\\n  a nil first argument to f with the supplied value x. Higher arity\\n  versions can replace arguments in the second and third\\n  positions (y, z). Note that the function f can take any number of\\n  arguments, not just the one(s) being nil-patched.\"\n ([f x]\n  (fn\n   ([a] (f (if (nil? a) x a)))\n   ([a b] (f (if (nil? a) x a) b))\n   ([a b c] (f (if (nil? a) x a) b c))\n   ([a b c & ds] (apply f (if (nil? a) x a) b c ds))))\n ([f x y]\n  (fn\n   ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n   ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) c))\n   ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) c ds))))\n ([f x y z]\n  (fn\n   ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n   ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c)))\n   ([a b c & ds]\n    (apply\n     f\n     (if (nil? a) x a)\n     (if (nil? b) y b)\n     (if (nil? c) z c)\n     ds)))))\n"} {:sym nthrest, :meta {:doc "Returns the nth rest of coll, coll when n is 0.", :arglists ([coll n])}, :source "(defn\n nthrest\n \"Returns the nth rest of coll, coll when n is 0.\"\n [coll n]\n (loop\n  [n n xs coll]\n  (if (and (pos? n) (seq xs)) (recur (dec n) (rest xs)) xs)))\n"} {:sym *warn-on-infer*, :meta {}, :source "(def *warn-on-infer* false)\n"} {:sym -find, :meta {:doc "Returns the map entry for key, or nil if key not present.", :arglists ([coll k])}, :protocol IFind} {:sym sequential?, :meta {:doc "Returns true if coll satisfies ISequential", :arglists ([x])}, :source "(defn\n sequential?\n \"Returns true if coll satisfies ISequential\"\n [x]\n (satisfies? ISequential x))\n"} {:sym m3-mix-H1, :meta {:doc nil, :arglists ([h1 k1])}, :source "(defn\n m3-mix-H1\n [h1 k1]\n (int\n  (->\n   (int h1)\n   (bit-xor (int k1))\n   (int-rotate-left 13)\n   (imul 5)\n   (+ (int 3864292196)))))\n"} {:sym prim-seq, :meta {:doc "Create seq from a primitive JavaScript Array-like.", :arglists [[prim] [prim i]]}, :source "(defn\n prim-seq\n \"Create seq from a primitive JavaScript Array-like.\"\n ([prim] (prim-seq prim 0))\n ([prim i] (when (< i (alength prim)) (IndexedSeq. prim i nil))))\n"} {:sym *print-level*, :meta {:doc "*print-level* controls how many levels deep the printer will\n  print nested objects. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  level to print. Each argument to print is at level 0; if an argument is a\n  collection, its items are at level 1; and so on. If an object is a\n  collection and is at a level greater than or equal to the value bound to\n  *print-level*, the printer prints '#' to represent it. The root binding\n  is nil indicating no limit."}, :source "(def *print-level* nil)\n"} {:sym shuffle, :meta {:doc "Return a random permutation of coll", :arglists ([coll])}, :source "(defn\n shuffle\n \"Return a random permutation of coll\"\n [coll]\n (let [a (to-array coll)] (garray/shuffle a) (vec a)))\n"} {:sym hash-keyword, :meta {:doc nil, :arglists ([k])}, :source "(defn hash-keyword [k] (int (+ (hash-symbol k) 2654435769)))\n"} {:sym find, :meta {:doc "Returns the map entry for key, or nil if key not present.", :arglists ([coll k])}, :source "(defn\n find\n \"Returns the map entry for key, or nil if key not present.\"\n [coll k]\n (if\n  (ifind? coll)\n  (-find coll k)\n  (when\n   (and (not (nil? coll)) (associative? coll) (contains? coll k))\n   [k (get coll k)])))\n"} {:sym alength, :meta {:doc "Returns the length of the array. Works on arrays of all types.", :arglists ([array])}, :source "(defn\n alength\n \"Returns the length of the array. Works on arrays of all types.\"\n [array]\n (cljs.core/alength array))\n"} {:sym bit-xor, :meta {:doc "Bitwise exclusive or", :arglists [[x y] [x y & more]]}, :source "(defn\n bit-xor\n \"Bitwise exclusive or\"\n ([x y] (cljs.core/bit-xor x y))\n ([x y & more] (reduce bit-xor (cljs.core/bit-xor x y) more)))\n"} {:sym unsigned-bit-shift-right, :meta {:doc "Bitwise shift right with zero fill", :arglists ([x n])}, :source "(defn\n unsigned-bit-shift-right\n \"Bitwise shift right with zero fill\"\n [x n]\n (cljs.core/unsigned-bit-shift-right x n))\n"} {:sym neg?, :meta {:doc "Returns true if num is less than zero, else false", :arglists ([x])}, :source "(defn\n neg?\n \"Returns true if num is less than zero, else false\"\n [x]\n (cljs.core/neg? x))\n"} {:sym js-invoke, :meta {:doc "Invoke JavaScript object method via string. Needed when the\n  string is not a valid unquoted property name.", :arglists ([obj s & args])}, :source "(defn\n js-invoke\n \"Invoke JavaScript object method via string. Needed when the\\n  string is not a valid unquoted property name.\"\n [obj s & args]\n (.apply (unchecked-get obj s) obj (into-array args)))\n"} {:sym m3-mix-K1, :meta {:doc nil, :arglists ([k1])}, :source "(defn\n m3-mix-K1\n [k1]\n (-> (int k1) (imul m3-C1) (int-rotate-left 15) (imul m3-C2)))\n"} {:sym unchecked-float, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-float [x] x)\n"} {:sym undefined?, :meta {:doc "Returns true if x identical to the JavaScript undefined value.", :arglists ([x])}, :source "(defn\n undefined?\n \"Returns true if x identical to the JavaScript undefined value.\"\n [x]\n (cljs.core/undefined? x))\n"} {:sym IMeta, :meta {:doc "Protocol for accessing the metadata of an object."}, :methods (-meta)} {:sym reduced?, :meta {:doc "Returns true if x is the result of a call to reduced", :arglists ([r])}, :source "(defn\n reduced?\n \"Returns true if x is the result of a call to reduced\"\n [r]\n (instance? Reduced r))\n"} {:sym disj!, :meta {:doc "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s).", :arglists [[tcoll val] [tcoll val & vals]]}, :source "(defn\n disj!\n \"disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\\n  does not contain key(s).\"\n ([tcoll val] (-disjoin! tcoll val))\n ([tcoll val & vals]\n  (let\n   [ntcoll (-disjoin! tcoll val)]\n   (if vals (recur ntcoll (first vals) (next vals)) ntcoll))))\n"} {:sym -lookup, :meta {:doc "Use k to look up a value in o. If not-found is supplied and k is not\n     a valid value that can be used for look up, not-found is returned.", :arglists ([o k] [o k not-found])}, :protocol ILookup} {:sym float?, :meta {:doc "Returns true for JavaScript numbers, false otherwise.", :arglists ([x])}, :source "(defn\n float?\n \"Returns true for JavaScript numbers, false otherwise.\"\n [x]\n (number? x))\n"} {:sym ICloneable, :meta {:doc "Protocol for cloning a value."}, :methods (-clone)} {:sym booleans, :meta {:doc nil, :arglists ([x])}, :source "(defn booleans [x] x)\n"} {:sym int-array, :meta {:doc "Creates an array of ints. Does not coerce array, provided for compatibility\n  with Clojure.", :arglists [[size-or-seq] [size init-val-or-seq]]}, :source "(defn\n int-array\n \"Creates an array of ints. Does not coerce array, provided for compatibility\\n  with Clojure.\"\n ([size-or-seq]\n  (if\n   (number? size-or-seq)\n   (int-array size-or-seq nil)\n   (into-array size-or-seq)))\n ([size init-val-or-seq]\n  (let\n   [a (make-array size)]\n   (if\n    (seq? init-val-or-seq)\n    (let\n     [s (seq init-val-or-seq)]\n     (loop\n      [i 0 s s]\n      (if\n       (and s (< i size))\n       (do (aset a i (first s)) (recur (inc i) (next s)))\n       a)))\n    (do (dotimes [i size] (aset a i init-val-or-seq)) a)))))\n"} {:sym set?, :meta {:doc "Returns true if x satisfies ISet", :arglists ([x])}, :source "(defn\n set?\n \"Returns true if x satisfies ISet\"\n [x]\n (if (nil? x) false (satisfies? ISet x)))\n"} {:sym iterable?, :meta {:doc "Return true if x implements IIterable protocol.", :arglists ([x])}, :source "(defn\n iterable?\n \"Return true if x implements IIterable protocol.\"\n [x]\n (satisfies? IIterable x))\n"} {:sym -pr-writer, :meta {:doc nil, :arglists ([o writer opts])}, :protocol IPrintWithWriter} {:sym vary-meta, :meta {:doc "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata.", :arglists [[obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d & args]]}, :source "(defn\n vary-meta\n \"Returns an object of the same type and value as obj, with\\n  (apply f (meta obj) args) as its metadata.\"\n ([obj f] (with-meta obj (f (meta obj))))\n ([obj f a] (with-meta obj (f (meta obj) a)))\n ([obj f a b] (with-meta obj (f (meta obj) a b)))\n ([obj f a b c] (with-meta obj (f (meta obj) a b c)))\n ([obj f a b c d] (with-meta obj (f (meta obj) a b c d)))\n ([obj f a b c d & args]\n  (with-meta obj (apply f (meta obj) a b c d args))))\n"} {:sym INext, :meta {:doc "Protocol for accessing the next items of a collection."}, :methods (-next)} {:sym is_proto_, :meta {:doc nil, :arglists ([x])}, :source "(defn is_proto_ [x] (identical? (.-prototype (.-constructor x)) x))\n"} {:sym ICounted, :meta {:doc "Protocol for adding the ability to count a collection in constant time."}, :methods (-count)} {:sym IMapEntry, :meta {:doc "Protocol for examining a map entry."}, :methods (-key -val)} {:sym <=, :meta {:doc "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n <=\n \"Returns non-nil if nums are in monotonically non-decreasing order,\\n  otherwise false.\"\n ([x] true)\n ([x y] (cljs.core/<= x y))\n ([x y & more]\n  (if\n   (cljs.core/<= x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (cljs.core/<= y (first more)))\n   false)))\n"} {:sym MODULE_INFOS, :meta {}, :source "(def MODULE_INFOS nil)\n"} {:sym conj!, :meta {:doc "Adds val to the transient collection, and return tcoll. The 'addition'\n  may happen at different 'places' depending on the concrete type.", :arglists [[] [tcoll] [tcoll val] [tcoll val & vals]]}, :source "(defn\n conj!\n \"Adds val to the transient collection, and return tcoll. The 'addition'\\n  may happen at different 'places' depending on the concrete type.\"\n ([] (transient []))\n ([tcoll] tcoll)\n ([tcoll val] (-conj! tcoll val))\n ([tcoll val & vals]\n  (let\n   [ntcoll (-conj! tcoll val)]\n   (if vals (recur ntcoll (first vals) (next vals)) ntcoll))))\n"} {:sym -pop, :meta {:doc "Returns a new stack without the item on top of the stack. Is used\n     by cljs.core/pop.", :arglists ([coll])}, :protocol IStack} {:sym repeatedly, :meta {:doc "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it", :arglists [[f] [n f]]}, :source "(defn\n repeatedly\n \"Takes a function of no args, presumably with side effects, and\\n  returns an infinite (or length n if supplied) lazy sequence of calls\\n  to it\"\n ([f] (lazy-seq (cons (f) (repeatedly f))))\n ([n f] (take n (repeatedly f))))\n"} {:sym reset-vals!, :meta {:doc "Sets the value of atom to newval. Returns [old new], the value of the\n   atom before and after the reset.", :arglists ([a new-value])}, :source "(defn\n reset-vals!\n \"Sets the value of atom to newval. Returns [old new], the value of the\\n   atom before and after the reset.\"\n {:added \"1.9\"}\n [a new-value]\n (let\n  [validate (.-validator a)]\n  (when-not\n   (nil? validate)\n   (when-not\n    (validate new-value)\n    (throw (js/Error. \"Validator rejected reference state\"))))\n  (let\n   [old-value (.-state a)]\n   (set! (.-state a) new-value)\n   (when-not\n    (nil? (.-watches a))\n    (-notify-watches a old-value new-value))\n   [old-value new-value])))\n"} {:sym IStack, :meta {:doc "Protocol for collections to provide access to their items as stacks. The top\n  of the stack should be accessed in the most efficient way for the different\n  data structures."}, :methods (-peek -pop)} {:sym -remove-watch, :meta {:doc "Removes watcher that corresponds to key from this.", :arglists ([this key])}, :protocol IWatchable} {:sym IVolatile, :meta {:doc "Protocol for adding volatile functionality."}, :methods (-vreset!)} {:sym remove, :meta {:doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :arglists [[pred] [pred coll]]}, :source "(defn\n remove\n \"Returns a lazy sequence of the items in coll for which\\n  (pred item) returns false. pred must be free of side-effects.\\n  Returns a transducer when no collection is provided.\"\n ([pred] (filter (complement pred)))\n ([pred coll] (filter (complement pred) coll)))\n"} {:sym *, :meta {:doc "Returns the product of nums. (*) returns 1.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n *\n \"Returns the product of nums. (*) returns 1.\"\n ([] 1)\n ([x] x)\n ([x y] (cljs.core/* x y))\n ([x y & more] (reduce * (cljs.core/* x y) more)))\n"} {:sym min, :meta {:doc "Returns the least of the nums.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n min\n \"Returns the least of the nums.\"\n ([x] x)\n ([x y] (cljs.core/min x y))\n ([x y & more] (reduce min (cljs.core/min x y) more)))\n"} {:sym -persistent!, :meta {:doc "Creates a persistent data structure from tcoll and returns it.", :arglists ([tcoll])}, :protocol ITransientCollection} {:sym -nth, :meta {:doc "Returns the value at the index n in the collection coll.\n     Returns not-found if index n is out of bounds and not-found is supplied.", :arglists ([coll n] [coll n not-found])}, :protocol IIndexed} {:sym pop!, :meta {:doc "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns tcoll", :arglists ([tcoll])}, :source "(defn\n pop!\n \"Removes the last item from a transient vector. If\\n  the collection is empty, throws an exception. Returns tcoll\"\n [tcoll]\n (-pop! tcoll))\n"} {:sym chunk-append, :meta {:doc nil, :arglists ([b x])}, :source "(defn chunk-append [b x] (.add b x))\n"} {:sym *unchecked-arrays*, :meta {}, :source "(def *unchecked-arrays* false)\n"} {:sym IReversible, :meta {:doc "Protocol for reversing a seq."}, :methods (-rseq)} {:sym reversible?, :meta {:doc "Returns true if coll satisfies? IReversible.", :arglists ([coll])}, :source "(defn\n reversible?\n \"Returns true if coll satisfies? IReversible.\"\n [coll]\n (satisfies? IReversible coll))\n"} {:sym -realized?, :meta {:doc "Returns true if a value for x has been produced, false otherwise.", :arglists ([x])}, :protocol IPending} {:sym -add-watch, :meta {:doc "Adds a watcher function f to this. Keys must be unique per reference,\n     and can be used to remove the watch with -remove-watch.", :arglists ([this key f])}, :protocol IWatchable} {:sym -deref-with-timeout, :meta {:doc nil, :arglists ([o msec timeout-val])}, :protocol IDerefWithTimeout} {:sym conj, :meta {:doc "conj[oin]. Returns a new collection with the xs\n  'added'. (conj nil item) returns (item).  The 'addition' may\n  happen at different 'places' depending on the concrete type.", :arglists [[] [coll] [coll x] [coll x & xs]]}, :source "(defn\n conj\n \"conj[oin]. Returns a new collection with the xs\\n  'added'. (conj nil item) returns (item).  The 'addition' may\\n  happen at different 'places' depending on the concrete type.\"\n ([] [])\n ([coll] coll)\n ([coll x] (if-not (nil? coll) (-conj coll x) (list x)))\n ([coll x & xs]\n  (if xs (recur (conj coll x) (first xs) (next xs)) (conj coll x))))\n"} {:sym -sorted-seq, :meta {:doc "Returns a sorted seq from coll in either ascending or descending order.", :arglists ([coll ascending?])}, :protocol ISorted} {:sym transduce, :meta {:doc "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items.", :arglists [[xform f coll] [xform f init coll]]}, :source "(defn\n transduce\n \"reduce with a transformation of f (xf). If init is not\\n  supplied, (f) will be called to produce it. f should be a reducing\\n  step function that accepts both 1 and 2 arguments, if it accepts\\n  only 2 you can add the arity-1 with 'completing'. Returns the result\\n  of applying (the transformed) xf to init and the first item in coll,\\n  then applying xf to that result and the 2nd item, etc. If coll\\n  contains no items, returns init and f is not called. Note that\\n  certain transforms may inject or skip items.\"\n ([xform f coll] (transduce xform f (f) coll))\n ([xform f init coll]\n  (let [f (xform f) ret (reduce f init coll)] (f ret))))\n"} {:sym -swap!, :meta {:doc "Swaps the value of o to be (apply f current-value-of-atom args).", :arglists ([o f] [o f a] [o f a b] [o f a b xs])}, :protocol ISwap} {:sym *print-length*, :meta {:doc "*print-length* controls how many items of each collection the\n  printer will print. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  number of items of each collection to print. If a collection contains\n  more items, the printer will print items up to the limit followed by\n  '...' to represent the remaining items. The root binding is nil\n  indicating no limit."}, :source "(def *print-length* nil)\n"} {:sym js-delete, :meta {:doc "Delete a property from a JavaScript object.", :arglists ([obj key])}, :source "(defn\n js-delete\n \"Delete a property from a JavaScript object.\"\n [obj key]\n (cljs.core/js-delete obj key))\n"} {:sym truth_, :meta {:doc "Internal - do not use!", :arglists ([x])}, :source "(defn truth_ \"Internal - do not use!\" [x] (cljs.core/truth_ x))\n"} {:sym compare-and-set!, :meta {:doc "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is equal to oldval. Returns true if\n  set happened, else false.", :arglists ([a oldval newval])}, :source "(defn\n compare-and-set!\n \"Atomically sets the value of atom to newval if and only if the\\n  current value of the atom is equal to oldval. Returns true if\\n  set happened, else false.\"\n [a oldval newval]\n (if (= (-deref a) oldval) (do (reset! a newval) true) false))\n"} {:sym array-seq, :meta {:doc "Create a seq from a JavaScript array.", :arglists [[array] [array i]]}, :source "(defn\n array-seq\n \"Create a seq from a JavaScript array.\"\n ([array] (prim-seq array 0))\n ([array i] (prim-seq array i)))\n"} {:sym interleave, :meta {:doc "Returns a lazy seq of the first item in each coll, then the second etc.", :arglists [[] [c1] [c1 c2] [c1 c2 & colls]]}, :source "(defn\n interleave\n \"Returns a lazy seq of the first item in each coll, then the second etc.\"\n ([] ())\n ([c1] (lazy-seq c1))\n ([c1 c2]\n  (lazy-seq\n   (let\n    [s1 (seq c1) s2 (seq c2)]\n    (when\n     (and s1 s2)\n     (cons\n      (first s1)\n      (cons (first s2) (interleave (rest s1) (rest s2))))))))\n ([c1 c2 & colls]\n  (lazy-seq\n   (let\n    [ss (map seq (conj colls c2 c1))]\n    (when\n     (every? identity ss)\n     (concat (map first ss) (apply interleave (map rest ss))))))))\n"} {:sym map?, :meta {:doc "Return true if x satisfies IMap", :arglists ([x])}, :source "(defn\n map?\n \"Return true if x satisfies IMap\"\n [x]\n (if (nil? x) false (satisfies? IMap x)))\n"} {:sym m3-C1, :meta {}, :source "(def m3-C1 (int 3432918353))\n"} {:sym get, :meta {:doc "Returns the value mapped to key, not-found or nil if key not present.", :arglists [[o k] [o k not-found]]}, :source "(defn\n get\n \"Returns the value mapped to key, not-found or nil if key not present.\"\n ([o k]\n  (when-not\n   (nil? o)\n   (cond\n    (implements? ILookup o)\n    (-lookup o k)\n    (array? o)\n    (when (and (some? k) (< k (.-length o))) (aget o (int k)))\n    (string? o)\n    (when (and (some? k) (< k (.-length o))) (.charAt o (int k)))\n    (native-satisfies? ILookup o)\n    (-lookup o k)\n    :else\n    nil)))\n ([o k not-found]\n  (if-not\n   (nil? o)\n   (cond\n    (implements? ILookup o)\n    (-lookup o k not-found)\n    (array? o)\n    (if\n     (and (some? k) (>= k 0) (< k (.-length o)))\n     (aget o (int k))\n     not-found)\n    (string? o)\n    (if\n     (and (some? k) (>= k 0) (< k (.-length o)))\n     (.charAt o (int k))\n     not-found)\n    (native-satisfies? ILookup o)\n    (-lookup o k not-found)\n    :else\n    not-found)\n   not-found)))\n"} {:sym identity, :meta {:doc "Returns its argument.", :arglists ([x])}, :source "(defn identity \"Returns its argument.\" [x] x)\n"} {:sym into, :meta {:doc "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined. A transducer may be supplied.", :arglists [[] [to] [to from] [to xform from]]}, :source "(defn\n into\n \"Returns a new coll consisting of to-coll with all of the items of\\n  from-coll conjoined. A transducer may be supplied.\"\n ([] [])\n ([to] to)\n ([to from]\n  (if-not\n   (nil? to)\n   (if\n    (implements? IEditableCollection to)\n    (-with-meta\n     (persistent! (reduce -conj! (transient to) from))\n     (meta to))\n    (reduce -conj to from))\n   (reduce conj () from)))\n ([to xform from]\n  (if\n   (implements? IEditableCollection to)\n   (-with-meta\n    (persistent! (transduce xform conj! (transient to) from))\n    (meta to))\n   (transduce xform conj to from))))\n"} {:sym long, :meta {:doc "Coerce to long by stripping decimal places. Identical to `int'.", :arglists ([x])}, :source "(defn\n long\n \"Coerce to long by stripping decimal places. Identical to `int'.\"\n [x]\n (fix x))\n"} {:sym double, :meta {:doc nil, :arglists ([x])}, :source "(defn double [x] x)\n"} {:sym volatile?, :meta {:doc "Returns true if x is a volatile.", :arglists ([x])}, :source "(defn\n volatile?\n \"Returns true if x is a volatile.\"\n [x]\n (instance? Volatile x))\n"} {:sym -key, :meta {:doc "Returns the key of the map entry.", :arglists ([coll])}, :protocol IMapEntry} {:sym nfirst, :meta {:doc "Same as (next (first x))", :arglists ([coll])}, :source "(defn nfirst \"Same as (next (first x))\" [coll] (next (first coll)))\n"} {:sym meta, :meta {:doc "Returns the metadata of obj, returns nil if there is no metadata.", :arglists ([o])}, :source "(defn\n meta\n \"Returns the metadata of obj, returns nil if there is no metadata.\"\n [o]\n (when (and (not (nil? o)) (satisfies? IMeta o)) (-meta o)))\n"} {:sym -kv-reduce, :meta {:doc "Reduces an associative collection and returns the result. f should be\n     a function that takes three arguments.", :arglists ([coll f init])}, :protocol IKVReduce} {:sym IHash, :meta {:doc "Protocol for adding hashing functionality to a type."}, :methods (-hash)} {:sym bit-and-not, :meta {:doc "Bitwise and with complement", :arglists [[x y] [x y & more]]}, :source "(defn\n bit-and-not\n \"Bitwise and with complement\"\n ([x y] (cljs.core/bit-and-not x y))\n ([x y & more] (reduce bit-and-not (cljs.core/bit-and-not x y) more)))\n"} {:sym var?, :meta {:doc "Returns true if v is of type cljs.core.Var", :arglists ([v])}, :source "(defn\n var?\n \"Returns true if v is of type cljs.core.Var\"\n [v]\n (instance? cljs.core.Var v))\n"} {:sym -comparator, :meta {:doc "Returns the comparator for coll.", :arglists ([coll])}, :protocol ISorted} {:sym unchecked-add-int, :meta {:doc "Returns the sum of nums. (+) returns 0.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n unchecked-add-int\n \"Returns the sum of nums. (+) returns 0.\"\n ([] 0)\n ([x] x)\n ([x y] (cljs.core/unchecked-add-int x y))\n ([x y & more]\n  (reduce unchecked-add-int (cljs.core/unchecked-add-int x y) more)))\n"} {:sym hash-ordered-coll, :meta {:doc "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://clojure.org/data_structures#hash for full algorithms.", :arglists ([coll])}, :source "(defn\n hash-ordered-coll\n \"Returns the hash code, consistent with =, for an external ordered\\n   collection implementing Iterable.\\n   See http://clojure.org/data_structures#hash for full algorithms.\"\n [coll]\n (loop\n  [n 0 hash-code 1 coll (seq coll)]\n  (if-not\n   (nil? coll)\n   (recur\n    (inc n)\n    (bit-or (+ (imul 31 hash-code) (hash (first coll))) 0)\n    (next coll))\n   (mix-collection-hash hash-code n))))\n"} {:sym IEquiv, :meta {:doc "Protocol for adding value comparison functionality to a type."}, :methods (-equiv)} {:sym cycle, :meta {:doc "Returns a lazy (infinite!) sequence of repetitions of the items in coll.", :arglists ([coll])}, :source "(defn\n cycle\n \"Returns a lazy (infinite!) sequence of repetitions of the items in coll.\"\n [coll]\n (lazy-seq (when-let [s (seq coll)] (concat s (cycle s)))))\n"} {:sym -deref, :meta {:doc "Returns the value of the reference o.", :arglists ([o])}, :protocol IDeref} {:sym empty?, :meta {:doc "Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))", :arglists ([coll])}, :source "(defn\n empty?\n \"Returns true if coll has no items - same as (not (seq coll)).\\n  Please use the idiom (seq x) rather than (not (empty? x))\"\n [coll]\n (or (nil? coll) (not (seq coll))))\n"} {:sym short, :meta {:doc nil, :arglists ([x])}, :source "(defn short [x] x)\n"} {:sym -chunked-first, :meta {:doc "Returns the first chunk in coll.", :arglists ([coll])}, :protocol IChunkedSeq} {:sym filterv, :meta {:doc "Returns a vector of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.", :arglists ([pred coll])}, :source "(defn\n filterv\n \"Returns a vector of the items in coll for which\\n  (pred item) returns true. pred must be free of side-effects.\"\n [pred coll]\n (->\n  (reduce (fn [v o] (if (pred o) (conj! v o) v)) (transient []) coll)\n  persistent!))\n"} {:sym hash, :meta {:doc "Returns the hash code of its argument. Note this is the hash code\n   consistent with =.", :arglists ([o])}, :source "(defn\n hash\n \"Returns the hash code of its argument. Note this is the hash code\\n   consistent with =.\"\n [o]\n (cond\n  (implements? IHash o)\n  (bit-xor (-hash o) 0)\n  (number? o)\n  (if\n   (js/isFinite o)\n   (js-mod (Math/floor o) 2147483647)\n   (case o ##Inf 2146435072 ##-Inf -1048576 2146959360))\n  (true? o)\n  1231\n  (false? o)\n  1237\n  (string? o)\n  (m3-hash-int (hash-string o))\n  (instance? js/Date o)\n  (bit-xor (.valueOf o) 0)\n  (nil? o)\n  0\n  :else\n  (bit-xor (-hash o) 0)))\n"} {:sym quot, :meta {:doc "quot[ient] of dividing numerator by denominator.", :arglists ([n d])}, :source "(defn\n quot\n \"quot[ient] of dividing numerator by denominator.\"\n [n d]\n (let [rem (js-mod n d)] (fix (/ (- n rem) d))))\n"} {:sym unchecked-double, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-double [x] x)\n"} {:sym ranged-iterator, :meta {:doc nil, :arglists ([v start end])}, :source "(defn\n ranged-iterator\n [v start end]\n (let\n  [i start]\n  (RangedIterator.\n   i\n   (- i (js-mod i 32))\n   (when (< start (count v)) (unchecked-array-for v i))\n   v\n   start\n   end)))\n"} {:sym ITransientVector, :meta {:doc "Protocol for adding vector functionality to transient collections."}, :methods (-assoc-n! -pop!)} {:sym longs, :meta {:doc nil, :arglists ([x])}, :source "(defn longs [x] x)\n"} {:sym not=, :meta {:doc "Same as (not (= obj1 obj2))", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n not=\n \"Same as (not (= obj1 obj2))\"\n ([x] false)\n ([x y] (not (= x y)))\n ([x y & more] (not (apply = x y more))))\n"} {:sym set-print-err-fn!, :meta {:doc "Set *print-err-fn* to f.", :arglists ([f])}, :source "(defn\n set-print-err-fn!\n \"Set *print-err-fn* to f.\"\n [f]\n (set! *print-err-fn* f))\n"} {:sym string?, :meta {:doc "Returns true if x is a JavaScript string.", :arglists ([x])}, :source "(defn\n string?\n \"Returns true if x is a JavaScript string.\"\n [x]\n (goog/isString x))\n"} {:sym es6-iterator, :meta {:doc "EXPERIMENTAL: Return a ES2015 compatible iterator for coll.", :arglists ([coll])}, :source "(defn\n es6-iterator\n \"EXPERIMENTAL: Return a ES2015 compatible iterator for coll.\"\n [coll]\n (ES6Iterator. (seq coll)))\n"} {:sym m3-C2, :meta {}, :source "(def m3-C2 (int 461845907))\n"} {:sym *print-newline*, :meta {:doc "When set to logical false will drop newlines from printing calls.\n  This is to work around the implicit newlines emitted by standard JavaScript\n  console objects."}, :source "(def *print-newline* true)\n"} {:sym unchecked-multiply-int, :meta {:doc "Returns the product of nums. (*) returns 1.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n unchecked-multiply-int\n \"Returns the product of nums. (*) returns 1.\"\n ([] 1)\n ([x] x)\n ([x y] (cljs.core/unchecked-multiply-int x y))\n ([x y & more]\n  (reduce\n   unchecked-multiply-int\n   (cljs.core/unchecked-multiply-int x y)\n   more)))\n"} {:sym chunk-rest, :meta {:doc nil, :arglists ([s])}, :source "(defn chunk-rest [s] (-chunked-rest s))\n"} {:sym double?, :meta {:doc "Returns true for JavaScript numbers, false otherwise.", :arglists ([x])}, :source "(defn\n double?\n \"Returns true for JavaScript numbers, false otherwise.\"\n [x]\n (number? x))\n"} {:sym vec, :meta {:doc "Creates a new vector containing the contents of coll. JavaScript arrays\n  will be aliased and should not be modified.", :arglists ([coll])}, :source "(defn\n vec\n \"Creates a new vector containing the contents of coll. JavaScript arrays\\n  will be aliased and should not be modified.\"\n [coll]\n (if\n  (array? coll)\n  (.fromArray PersistentVector coll true)\n  (-persistent!\n   (reduce -conj! (-as-transient (.-EMPTY PersistentVector)) coll))))\n"} {:sym *print-meta*, :meta {:doc "If set to logical true, when printing an object, its metadata will also\n  be printed in a form that can be read back by the reader.\n\n  Defaults to false."}, :source "(def *print-meta* false)\n"} {:sym -notify-watches, :meta {:doc "Calls all watchers with this, oldval and newval.", :arglists ([this oldval newval])}, :protocol IWatchable} {:sym int, :meta {:doc "Coerce to int by stripping decimal places.", :arglists ([x])}, :source "(defn int \"Coerce to int by stripping decimal places.\" [x] (bit-or x 0))\n"} {:sym second, :meta {:doc "Same as (first (next x))", :arglists ([coll])}, :source "(defn second \"Same as (first (next x))\" [coll] (first (next coll)))\n"} {:sym IEditableCollection, :meta {:doc "Protocol for collections which can transformed to transients."}, :methods (-as-transient)} {:sym hash-combine, :meta {:doc nil, :arglists ([seed hash])}, :source "(defn\n hash-combine\n [seed hash]\n (bit-xor\n  seed\n  (+ hash 2654435769 (bit-shift-left seed 6) (bit-shift-right seed 2))))\n"} {:sym >, :meta {:doc "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n >\n \"Returns non-nil if nums are in monotonically decreasing order,\\n  otherwise false.\"\n ([x] true)\n ([x y] (cljs.core/> x y))\n ([x y & more]\n  (if\n   (cljs.core/> x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (cljs.core/> y (first more)))\n   false)))\n"} {:sym -name, :meta {:doc "Returns the name String of x.", :arglists ([x])}, :protocol INamed} {:sym int?, :meta {:doc "Return true if x satisfies integer? or is an instance of goog.math.Integer\n   or goog.math.Long.", :arglists ([x])}, :source "(defn\n int?\n \"Return true if x satisfies integer? or is an instance of goog.math.Integer\\n   or goog.math.Long.\"\n [x]\n (or\n  (integer? x)\n  (instance? goog.math.Integer x)\n  (instance? goog.math.Long x)))\n"} {:sym associative?, :meta {:doc "Returns true if coll implements Associative", :arglists ([x])}, :source "(defn\n associative?\n \"Returns true if coll implements Associative\"\n [x]\n (satisfies? IAssociative x))\n"} {:sym unchecked-int, :meta {:doc "Coerce to int by stripping decimal places.", :arglists ([x])}, :source "(defn\n unchecked-int\n \"Coerce to int by stripping decimal places.\"\n [x]\n (fix x))\n"} {:sym js-keys, :meta {:doc "Return the JavaScript keys for an object.", :arglists ([obj])}, :source "(defn\n js-keys\n \"Return the JavaScript keys for an object.\"\n [obj]\n (gobject/getKeys obj))\n"} {:sym inst-ms*, :meta {:doc nil, :arglists ([inst])}, :protocol Inst} {:sym keyword?, :meta {:doc "Return true if x is a Keyword", :arglists ([x])}, :source "(defn\n keyword?\n \"Return true if x is a Keyword\"\n [x]\n (instance? Keyword x))\n"} {:sym array-iter, :meta {:doc nil, :arglists ([x])}, :source "(defn array-iter [x] (ArrayIter. x 0))\n"} {:sym -rseq, :meta {:doc "Returns a seq of the items in coll in reversed order.", :arglists ([coll])}, :protocol IReversible} {:sym unchecked-multiply, :meta {:doc "Returns the product of nums. (*) returns 1.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n unchecked-multiply\n \"Returns the product of nums. (*) returns 1.\"\n ([] 1)\n ([x] x)\n ([x y] (cljs.core/unchecked-multiply x y))\n ([x y & more]\n  (reduce unchecked-multiply (cljs.core/unchecked-multiply x y) more)))\n"} {:sym even?, :meta {:doc "Returns true if n is even, throws an exception if n is not an integer", :arglists ([n])}, :source "(defn\n even?\n \"Returns true if n is even, throws an exception if n is not an integer\"\n [n]\n (if\n  (integer? n)\n  (zero? (bit-and n 1))\n  (throw (js/Error. (str \"Argument must be an integer: \" n)))))\n"} {:sym es6-iterator-seq, :meta {:doc "EXPERIMENTAL: Given an ES2015 compatible iterator return a seq.", :arglists ([iter])}, :source "(defn\n es6-iterator-seq\n \"EXPERIMENTAL: Given an ES2015 compatible iterator return a seq.\"\n [iter]\n (let\n  [v (.next iter)]\n  (if (.-done v) () (ES6IteratorSeq. (.-value v) iter nil))))\n"} {:sym unchecked-dec, :meta {:doc "Returns a number one less than x, an int.", :arglists ([x])}, :source "(defn\n unchecked-dec\n \"Returns a number one less than x, an int.\"\n [x]\n (cljs.core/unchecked-dec x))\n"} {:sym Inst, :meta {:doc nil}, :methods (inst-ms*)} {:sym double-array, :meta {:doc "Creates an array of doubles. Does not coerce array, provided for compatibility\n  with Clojure.", :arglists [[size-or-seq] [size init-val-or-seq]]}, :source "(defn\n double-array\n \"Creates an array of doubles. Does not coerce array, provided for compatibility\\n  with Clojure.\"\n ([size-or-seq]\n  (if\n   (number? size-or-seq)\n   (double-array size-or-seq nil)\n   (into-array size-or-seq)))\n ([size init-val-or-seq]\n  (let\n   [a (make-array size)]\n   (if\n    (seq? init-val-or-seq)\n    (let\n     [s (seq init-val-or-seq)]\n     (loop\n      [i 0 s s]\n      (if\n       (and s (< i size))\n       (do (aset a i (first s)) (recur (inc i) (next s)))\n       a)))\n    (do (dotimes [i size] (aset a i init-val-or-seq)) a)))))\n"} {:sym spread, :meta {:doc nil, :arglists ([arglist])}, :source "(defn\n spread\n [arglist]\n (when-not\n  (nil? arglist)\n  (let\n   [n (next arglist)]\n   (if\n    (nil? n)\n    (seq (first arglist))\n    (cons (first arglist) (spread n))))))\n"} {:sym rseq, :meta {:doc "Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil", :arglists ([rev])}, :source "(defn\n rseq\n \"Returns, in constant time, a seq of the items in rev (which\\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil\"\n [rev]\n (-rseq rev))\n"} {:sym IReset, :meta {:doc "Protocol for adding resetting functionality."}, :methods (-reset!)} {:sym IEmptyableCollection, :meta {:doc "Protocol for creating an empty collection."}, :methods (-empty)} {:sym *print-fn-bodies*, :meta {:doc "*print-fns-bodies* controls whether functions print their source or\n    only their names."}, :source "(def *print-fn-bodies* false)\n"} {:sym float, :meta {:doc nil, :arglists ([x])}, :source "(defn float [x] x)\n"} {:sym IRecord, :meta {:doc "Marker interface indicating a record object"}, :methods ()} {:sym concat, :meta {:doc "Returns a lazy seq representing the concatenation of the elements in the supplied colls.", :arglists [[] [x] [x y] [x y & zs]]}, :source "(defn\n concat\n \"Returns a lazy seq representing the concatenation of the elements in the supplied colls.\"\n ([] (lazy-seq nil))\n ([x] (lazy-seq x))\n ([x y]\n  (lazy-seq\n   (let\n    [s (seq x)]\n    (if\n     s\n     (if\n      (chunked-seq? s)\n      (chunk-cons (chunk-first s) (concat (chunk-rest s) y))\n      (cons (first s) (concat (rest s) y)))\n     y))))\n ([x y & zs]\n  (let\n   [cat\n    (fn\n     cat\n     [xys zs]\n     (lazy-seq\n      (let\n       [xys (seq xys)]\n       (if\n        xys\n        (if\n         (chunked-seq? xys)\n         (chunk-cons (chunk-first xys) (cat (chunk-rest xys) zs))\n         (cons (first xys) (cat (rest xys) zs)))\n        (when zs (cat (first zs) (next zs)))))))]\n   (cat (concat x y) zs))))\n"} {:sym IDerefWithTimeout, :meta {:doc nil}, :methods (-deref-with-timeout)} {:sym symbol, :meta {:doc "Returns a Symbol with the given namespace and name.", :arglists [[name] [ns name]]}, :source "(defn\n symbol\n \"Returns a Symbol with the given namespace and name.\"\n ([name]\n  (if\n   (symbol? name)\n   name\n   (let\n    [idx (.indexOf name \"/\")]\n    (if\n     (< idx 1)\n     (symbol nil name)\n     (symbol\n      (.substring name 0 idx)\n      (.substring name (inc idx) (. name -length)))))))\n ([ns name]\n  (let\n   [sym-str (if-not (nil? ns) (str ns \"/\" name) name)]\n   (Symbol. ns name sym-str nil nil))))\n"} {:sym to-array-2d, :meta {:doc "Returns a (potentially-ragged) 2-dimensional array\n  containing the contents of coll.", :arglists ([coll])}, :source "(defn\n to-array-2d\n \"Returns a (potentially-ragged) 2-dimensional array\\n  containing the contents of coll.\"\n [coll]\n (let\n  [ret (make-array (count coll))]\n  (loop\n   [i 0 xs (seq coll)]\n   (when-not\n    (nil? xs)\n    (aset ret i (to-array (first xs)))\n    (recur (inc i) (next xs))))\n  ret))\n"} {:sym mod, :meta {:doc "Modulus of num and div. Truncates toward negative infinity.", :arglists ([n d])}, :source "(defn\n mod\n \"Modulus of num and div. Truncates toward negative infinity.\"\n [n d]\n (js-mod (+ (js-mod n d) d) d))\n"} {:sym ISet, :meta {:doc "Protocol for adding set functionality to a collection."}, :methods (-disjoin)} {:sym pop, :meta {:doc "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item.\n  Note - not the same as next/butlast.", :arglists ([coll])}, :source "(defn\n pop\n \"For a list or queue, returns a new list/queue without the first\\n  item, for a vector, returns a new vector without the last item.\\n  Note - not the same as next/butlast.\"\n [coll]\n (when-not (nil? coll) (-pop coll)))\n"} {:sym IPending, :meta {:doc "Protocol for types which can have a deferred realization. Currently only\n  implemented by Delay and LazySeq."}, :methods (-realized?)} {:sym -entry-key, :meta {:doc "Returns the key for entry.", :arglists ([coll entry])}, :protocol ISorted} {:sym dissoc!, :meta {:doc "Returns a transient map that doesn't contain a mapping for key(s).", :arglists [[tcoll key] [tcoll key & ks]]}, :source "(defn\n dissoc!\n \"Returns a transient map that doesn't contain a mapping for key(s).\"\n ([tcoll key] (-dissoc! tcoll key))\n ([tcoll key & ks]\n  (let\n   [ntcoll (-dissoc! tcoll key)]\n   (if ks (recur ntcoll (first ks) (next ks)) ntcoll))))\n"} {:sym indexed?, :meta {:doc "Returns true if coll implements nth in constant time", :arglists ([x])}, :source "(defn\n indexed?\n \"Returns true if coll implements nth in constant time\"\n [x]\n (satisfies? IIndexed x))\n"} {:sym -, :meta {:doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n -\n \"If no ys are supplied, returns the negation of x, else subtracts\\n  the ys from x and returns the result.\"\n ([x] (cljs.core/- x))\n ([x y] (cljs.core/- x y))\n ([x y & more] (reduce - (cljs.core/- x y) more)))\n"} {:sym -equiv, :meta {:doc "Returns true if o and other are equal, false otherwise.", :arglists ([o other])}, :protocol IEquiv} {:sym assoc!, :meta {:doc "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll.", :arglists [[tcoll key val] [tcoll key val & kvs]]}, :source "(defn\n assoc!\n \"When applied to a transient map, adds mapping of key(s) to\\n  val(s). When applied to a transient vector, sets the val at index.\\n  Note - index must be <= (count vector). Returns coll.\"\n ([tcoll key val] (-assoc! tcoll key val))\n ([tcoll key val & kvs]\n  (let\n   [ntcoll (-assoc! tcoll key val)]\n   (if\n    kvs\n    (recur ntcoll (first kvs) (second kvs) (nnext kvs))\n    ntcoll))))\n"} {:sym reduce-kv, :meta {:doc "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals.", :arglists [[f init coll]]}, :source "(defn\n reduce-kv\n \"Reduces an associative collection. f should be a function of 3\\n  arguments. Returns the result of applying f to init, the first key\\n  and the first value in coll, then applying f to that result and the\\n  2nd key and value, etc. If coll contains no entries, returns init\\n  and f is not called. Note that reduce-kv is supported on vectors,\\n  where the keys will be the ordinals.\"\n ([f init coll] (if-not (nil? coll) (-kv-reduce coll f init) init)))\n"} {:sym reset!, :meta {:doc "Sets the value of atom to newval without regard for the\n  current value. Returns new-value.", :arglists ([a new-value])}, :source "(defn\n reset!\n \"Sets the value of atom to newval without regard for the\\n  current value. Returns new-value.\"\n [a new-value]\n (if\n  (instance? Atom a)\n  (let\n   [validate (.-validator a)]\n   (when-not\n    (nil? validate)\n    (when-not\n     (validate new-value)\n     (throw (js/Error. \"Validator rejected reference state\"))))\n   (let\n    [old-value (.-state a)]\n    (set! (.-state a) new-value)\n    (when-not\n     (nil? (.-watches a))\n     (-notify-watches a old-value new-value))\n    new-value))\n  (-reset! a new-value)))\n"} {:sym Fn, :meta {:doc "Marker protocol"}, :methods ()} {:sym ffirst, :meta {:doc "Same as (first (first x))", :arglists ([coll])}, :source "(defn ffirst \"Same as (first (first x))\" [coll] (first (first coll)))\n"} {:sym counted?, :meta {:doc "Returns true if coll implements count in constant time", :arglists ([x])}, :source "(defn\n counted?\n \"Returns true if coll implements count in constant time\"\n [x]\n (satisfies? ICounted x))\n"} {:sym assoc-in, :meta {:doc "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created.", :arglists ([m [k & ks] v])}, :source "(defn\n assoc-in\n \"Associates a value in a nested associative structure, where ks is a\\n  sequence of keys and v is the new value and returns a new nested structure.\\n  If any levels do not exist, hash-maps will be created.\"\n [m [k & ks] v]\n (if ks (assoc m k (assoc-in (get m k) ks v)) (assoc m k v)))\n"} {:sym bit-test, :meta {:doc "Test bit at index n", :arglists ([x n])}, :source "(defn bit-test \"Test bit at index n\" [x n] (cljs.core/bit-test x n))\n"} {:sym ISwap, :meta {:doc "Protocol for adding swapping functionality."}, :methods (-swap!)} {:sym zero?, :meta {:doc "Returns true if num is zero, else false", :arglists ([x])}, :source "(defn\n zero?\n \"Returns true if num is zero, else false\"\n [x]\n (cljs.core/zero? x))\n"} {:sym simple-keyword?, :meta {:doc "Return true if x is a keyword without a namespace", :arglists ([x])}, :source "(defn\n simple-keyword?\n \"Return true if x is a keyword without a namespace\"\n [x]\n (and (keyword? x) (nil? (namespace x))))\n"} {:sym *main-cli-fn*, :meta {:doc "When compiled for a command-line target, whatever function\n  *main-cli-fn* is set to will be called with the command-line\n  argv as arguments"}, :source "(def *main-cli-fn* nil)\n"} {:sym -assoc-n, :meta {:doc "Returns a new vector with value val added at position n.", :arglists ([coll n val])}, :protocol IVector} {:sym unchecked-dec-int, :meta {:doc "Returns a number one less than x, an int.", :arglists ([x])}, :source "(defn\n unchecked-dec-int\n \"Returns a number one less than x, an int.\"\n [x]\n (cljs.core/unchecked-dec-int x))\n"} {:sym persistent!, :meta {:doc "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception.", :arglists ([tcoll])}, :source "(defn\n persistent!\n \"Returns a new, persistent version of the transient collection, in\\n  constant time. The transient collection cannot be used after this\\n  call, any such use will throw an exception.\"\n [tcoll]\n (-persistent! tcoll))\n"} {:sym set-print-fn!, :meta {:doc "Set *print-fn* to f.", :arglists ([f])}, :source "(defn set-print-fn! \"Set *print-fn* to f.\" [f] (set! *print-fn* f))\n"} {:sym nnext, :meta {:doc "Same as (next (next x))", :arglists ([coll])}, :source "(defn nnext \"Same as (next (next x))\" [coll] (next (next coll)))\n"} {:sym not-every?, :meta {:doc "Returns false if (pred x) is logical true for every x in\n  coll, else true.", :arglists ([pred coll])}, :source "(defn\n not-every?\n \"Returns false if (pred x) is logical true for every x in\\n  coll, else true.\"\n [pred coll]\n (not (every? pred coll)))\n"} {:sym rem, :meta {:doc "remainder of dividing numerator by denominator.", :arglists ([n d])}, :source "(defn\n rem\n \"remainder of dividing numerator by denominator.\"\n [n d]\n (let [q (quot n d)] (- n (* d q))))\n"} {:sym ifind?, :meta {:doc "Returns true if coll implements IFind", :arglists ([x])}, :source "(defn\n ifind?\n \"Returns true if coll implements IFind\"\n [x]\n (satisfies? IFind x))\n"} {:sym some, :meta {:doc "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)", :arglists ([pred coll])}, :source "(defn\n some\n \"Returns the first logical true value of (pred x) for any x in coll,\\n  else nil.  One common idiom is to use a set as pred, for example\\n  this will return :fred if :fred is in the sequence, otherwise nil:\\n  (some #{:fred} coll)\"\n [pred coll]\n (when (seq coll) (or (pred (first coll)) (recur pred (next coll)))))\n"} {:sym INamed, :meta {:doc "Protocol for adding a name."}, :methods (-name -namespace)} {:sym IReduce, :meta {:doc "Protocol for seq types that can reduce themselves.\n  Called by cljs.core/reduce."}, :methods (-reduce)} {:sym neg-int?, :meta {:doc "Return true if x satisfies int? and is negative.", :arglists ([x])}, :source "(defn\n neg-int?\n \"Return true if x satisfies int? and is negative.\"\n [x]\n (cond\n  (integer? x)\n  (neg? x)\n  (instance? goog.math.Integer x)\n  (.isNegative x)\n  (instance? goog.math.Long x)\n  (.isNegative x)\n  :else\n  false))\n"} {:sym drop, :meta {:doc "Returns a lazy sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided.", :arglists [[n] [n coll]]}, :source "(defn\n drop\n \"Returns a lazy sequence of all but the first n items in coll.\\n  Returns a stateful transducer when no collection is provided.\"\n ([n]\n  {:pre [(number? n)]}\n  (fn\n   [rf]\n   (let\n    [na (volatile! n)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input]\n      (let\n       [n @na]\n       (vswap! na dec)\n       (if (pos? n) result (rf result input))))))))\n ([n coll]\n  {:pre [(number? n)]}\n  (let\n   [step\n    (fn\n     [n coll]\n     (let\n      [s (seq coll)]\n      (if (and (pos? n) s) (recur (dec n) (rest s)) s)))]\n   (lazy-seq (step n coll)))))\n"} {:sym js-obj, :meta {:doc "Create JavaSript object from an even number arguments representing\n  interleaved keys and values.", :arglists [[] [& keyvals]]}, :source "(defn\n js-obj\n \"Create JavaSript object from an even number arguments representing\\n  interleaved keys and values.\"\n ([] (cljs.core/js-obj))\n ([& keyvals] (apply gobject/create keyvals)))\n"} {:sym ITransientCollection, :meta {:doc "Protocol for adding basic functionality to transient collections."}, :methods (-conj! -persistent!)} {:sym nth, :meta {:doc "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences.", :arglists [[coll n] [coll n not-found]]}, :source "(defn\n nth\n \"Returns the value at the index. get returns nil if index out of\\n  bounds, nth throws an exception unless not-found is supplied.  nth\\n  also works for strings, arrays, regex Matchers and Lists, and,\\n  in O(n) time, for sequences.\"\n ([coll n]\n  (cond\n   (not (number? n))\n   (throw (js/Error. \"Index argument to nth must be a number\"))\n   (nil? coll)\n   coll\n   (implements? IIndexed coll)\n   (-nth coll n)\n   (array? coll)\n   (if\n    (and (>= n 0) (< n (.-length coll)))\n    (aget coll n)\n    (throw (js/Error. \"Index out of bounds\")))\n   (string? coll)\n   (if\n    (and (>= n 0) (< n (.-length coll)))\n    (.charAt coll n)\n    (throw (js/Error. \"Index out of bounds\")))\n   (implements? ISeq coll)\n   (linear-traversal-nth coll n)\n   (native-satisfies? IIndexed coll)\n   (-nth coll n)\n   :else\n   (throw\n    (js/Error.\n     (str\n      \"nth not supported on this type \"\n      (type->str (type coll)))))))\n ([coll n not-found]\n  (cond\n   (not (number? n))\n   (throw (js/Error. \"Index argument to nth must be a number.\"))\n   (nil? coll)\n   not-found\n   (implements? IIndexed coll)\n   (-nth coll n not-found)\n   (array? coll)\n   (if (and (>= n 0) (< n (.-length coll))) (aget coll n) not-found)\n   (string? coll)\n   (if (and (>= n 0) (< n (.-length coll))) (.charAt coll n) not-found)\n   (implements? ISeq coll)\n   (linear-traversal-nth coll n not-found)\n   (native-satisfies? IIndexed coll)\n   (-nth coll n not-found)\n   :else\n   (throw\n    (js/Error.\n     (str\n      \"nth not supported on this type \"\n      (type->str (type coll))))))))\n"} {:sym sorted?, :meta {:doc "Returns true if coll satisfies ISorted", :arglists ([x])}, :source "(defn\n sorted?\n \"Returns true if coll satisfies ISorted\"\n [x]\n (satisfies? ISorted x))\n"} {:sym nil?, :meta {:doc "Returns true if x is nil, false otherwise.", :arglists ([x])}, :source "(defn\n nil?\n \"Returns true if x is nil, false otherwise.\"\n [x]\n (coercive-= x nil))\n"} {:sym split-at, :meta {:doc "Returns a vector of [(take n coll) (drop n coll)]", :arglists ([n coll])}, :source "(defn\n split-at\n \"Returns a vector of [(take n coll) (drop n coll)]\"\n [n coll]\n [(take n coll) (drop n coll)])\n"} {:sym not-native, :meta {}, :source "(def not-native nil)\n"} {:sym bit-and, :meta {:doc "Bitwise and", :arglists [[x y] [x y & more]]}, :source "(defn\n bit-and\n \"Bitwise and\"\n ([x y] (cljs.core/bit-and x y))\n ([x y & more] (reduce bit-and (cljs.core/bit-and x y) more)))\n"} {:sym bounded-count, :meta {:doc "If coll is counted? returns its count, else will count at most the first n\n   elements of coll using its seq", :arglists ([n coll])}, :source "(defn\n bounded-count\n \"If coll is counted? returns its count, else will count at most the first n\\n   elements of coll using its seq\"\n {:added \"1.9\"}\n [n coll]\n (if\n  (counted? coll)\n  (count coll)\n  (loop\n   [i 0 s (seq coll)]\n   (if (and (not (nil? s)) (< i n)) (recur (inc i) (next s)) i))))\n"} {:sym update, :meta {:doc "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value.", :arglists [[m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more]]}, :source "(defn\n update\n \"'Updates' a value in an associative structure, where k is a\\n  key and f is a function that will take the old value\\n  and any supplied args and return the new value, and returns a new\\n  structure.  If the key does not exist, nil is passed as the old value.\"\n ([m k f] (assoc m k (f (get m k))))\n ([m k f x] (assoc m k (f (get m k) x)))\n ([m k f x y] (assoc m k (f (get m k) x y)))\n ([m k f x y z] (assoc m k (f (get m k) x y z)))\n ([m k f x y z & more] (assoc m k (apply f (get m k) x y z more))))\n"} {:sym list*, :meta {:doc "Creates a new list containing the items prepended to the rest, the\n  last of which will be treated as a sequence.", :arglists [[args] [a args] [a b args] [a b c args] [a b c d & more]]}, :source "(defn\n list*\n \"Creates a new list containing the items prepended to the rest, the\\n  last of which will be treated as a sequence.\"\n ([args] (seq args))\n ([a args] (cons a args))\n ([a b args] (cons a (cons b args)))\n ([a b c args] (cons a (cons b (cons c args))))\n ([a b c d & more] (cons a (cons b (cons c (cons d (spread more)))))))\n"} {:sym update-in, :meta {:doc "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created.", :arglists [[m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c] [m [k & ks] f a b c & args]]}, :source "(defn\n update-in\n \"'Updates' a value in a nested associative structure, where ks is a\\n  sequence of keys and f is a function that will take the old value\\n  and any supplied args and return the new value, and returns a new\\n  nested structure.  If any levels do not exist, hash-maps will be\\n  created.\"\n ([m [k & ks] f]\n  (if\n   ks\n   (assoc m k (update-in (get m k) ks f))\n   (assoc m k (f (get m k)))))\n ([m [k & ks] f a]\n  (if\n   ks\n   (assoc m k (update-in (get m k) ks f a))\n   (assoc m k (f (get m k) a))))\n ([m [k & ks] f a b]\n  (if\n   ks\n   (assoc m k (update-in (get m k) ks f a b))\n   (assoc m k (f (get m k) a b))))\n ([m [k & ks] f a b c]\n  (if\n   ks\n   (assoc m k (update-in (get m k) ks f a b c))\n   (assoc m k (f (get m k) a b c))))\n ([m [k & ks] f a b c & args]\n  (if\n   ks\n   (assoc m k (apply update-in (get m k) ks f a b c args))\n   (assoc m k (apply f (get m k) a b c args)))))\n"} {:sym ensure-reduced, :meta {:doc "If x is already reduced?, returns it, else returns (reduced x)", :arglists ([x])}, :source "(defn\n ensure-reduced\n \"If x is already reduced?, returns it, else returns (reduced x)\"\n [x]\n (if (reduced? x) x (reduced x)))\n"} {:sym instance?, :meta {:doc "Evaluates x and tests if it is an instance of the type\n  c. Returns true or false", :arglists ([c x])}, :source "(defn\n instance?\n \"Evaluates x and tests if it is an instance of the type\\n  c. Returns true or false\"\n [c x]\n (cljs.core/instance? c x))\n"} {:sym mix-collection-hash, :meta {:doc "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://clojure.org/data_structures#hash for full algorithms.", :arglists ([hash-basis count])}, :source "(defn\n mix-collection-hash\n \"Mix final collection hash for ordered or unordered collections.\\n   hash-basis is the combined collection hash, count is the number\\n   of elements included in the basis. Note this is the hash code\\n   consistent with =, different from .hashCode.\\n   See http://clojure.org/data_structures#hash for full algorithms.\"\n [hash-basis count]\n (let\n  [h1 m3-seed k1 (m3-mix-K1 hash-basis) h1 (m3-mix-H1 h1 k1)]\n  (m3-fmix h1 count)))\n"} {:sym unchecked-add, :meta {:doc "Returns the sum of nums. (+) returns 0.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n unchecked-add\n \"Returns the sum of nums. (+) returns 0.\"\n ([] 0)\n ([x] x)\n ([x y] (cljs.core/unchecked-add x y))\n ([x y & more]\n  (reduce unchecked-add (cljs.core/unchecked-add x y) more)))\n"} {:sym transformer-iterator, :meta {:doc nil, :arglists ([xform sourceIter multi])}, :source "(defn\n transformer-iterator\n [xform sourceIter multi]\n (let\n  [iterator\n   (TransformerIterator. EMPTY NONE false nil sourceIter multi)]\n  (set!\n   (.-xf iterator)\n   (xform\n    (fn\n     ([] nil)\n     ([acc] acc)\n     ([acc o]\n      (set! (.-buffer iterator) (.add (.-buffer iterator) o))\n      acc))))\n  iterator))\n"} {:sym not, :meta {:doc "Returns true if x is logical false, false otherwise.", :arglists ([x])}, :source "(defn\n not\n \"Returns true if x is logical false, false otherwise.\"\n [x]\n (cond (nil? x) true (false? x) true :else false))\n"} {:sym -vreset!, :meta {:doc "Sets the value of volatile o to new-value without regard for the\n     current value. Returns new-value.", :arglists ([o new-value])}, :protocol IVolatile} {:sym with-meta, :meta {:doc "Returns an object of the same type and value as obj, with\n  map m as its metadata.", :arglists ([o meta])}, :source "(defn\n with-meta\n \"Returns an object of the same type and value as obj, with\\n  map m as its metadata.\"\n [o meta]\n (if\n  (goog/isFunction o)\n  (MetaFn. o meta)\n  (when-not (nil? o) (-with-meta o meta))))\n"} {:sym unreduced, :meta {:doc "If x is reduced?, returns (deref x), else returns x", :arglists ([x])}, :source "(defn\n unreduced\n \"If x is reduced?, returns (deref x), else returns x\"\n [x]\n (if (reduced? x) (deref x) x))\n"} {:sym record?, :meta {:doc "Return true if x satisfies IRecord", :arglists ([x])}, :source "(defn\n record?\n \"Return true if x satisfies IRecord\"\n [x]\n (satisfies? IRecord x))\n"} {:sym type, :meta {:doc "Return x's constructor.", :arglists ([x])}, :source "(defn\n type\n \"Return x's constructor.\"\n [x]\n (when-not (nil? x) (.-constructor x)))\n"} {:sym identical?, :meta {:doc "Tests if 2 arguments are the same object", :arglists ([x y])}, :source "(defn\n identical?\n \"Tests if 2 arguments are the same object\"\n [x y]\n (cljs.core/identical? x y))\n"} {:sym -namespace, :meta {:doc "Returns the namespace String of x.", :arglists ([x])}, :protocol INamed} {:sym unchecked-divide-int, :meta {:doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n unchecked-divide-int\n \"If no denominators are supplied, returns 1/numerator,\\n  else returns numerator divided by all of the denominators.\"\n ([x] (unchecked-divide-int 1 x))\n ([x y] (cljs.core/divide x y))\n ([x y & more]\n  (reduce unchecked-divide-int (unchecked-divide-int x y) more)))\n"} {:sym *out*, :meta {}, :source "(def *out* nil)\n"} {:sym hash-string, :meta {:doc nil, :arglists ([k])}, :source "(defn\n hash-string\n [k]\n (when\n  (> string-hash-cache-count 255)\n  (set! string-hash-cache (js-obj))\n  (set! string-hash-cache-count 0))\n (if\n  (nil? k)\n  0\n  (let\n   [h (unchecked-get string-hash-cache k)]\n   (if (number? h) h (add-to-string-hash-cache k)))))\n"} {:sym set-validator!, :meta {:doc "Sets the validator-fn for an atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an Error. If the current state\n  is not acceptable to the new validator, an Error will be thrown and the\n  validator will not be changed.", :arglists ([iref val])}, :source "(defn\n set-validator!\n \"Sets the validator-fn for an atom. validator-fn must be nil or a\\n  side-effect-free fn of one argument, which will be passed the intended\\n  new state on any state change. If the new state is unacceptable, the\\n  validator-fn should return false or throw an Error. If the current state\\n  is not acceptable to the new validator, an Error will be thrown and the\\n  validator will not be changed.\"\n [iref val]\n (when\n  (and (some? val) (not (val (-deref iref))))\n  (throw (js/Error. \"Validator rejected reference state\")))\n (set! (.-validator iref) val))\n"} {:sym ident?, :meta {:doc "Return true if x is a symbol or keyword", :arglists ([x])}, :source "(defn\n ident?\n \"Return true if x is a symbol or keyword\"\n [x]\n (or (keyword? x) (symbol? x)))\n"} {:sym -meta, :meta {:doc "Returns the metadata of object o.", :arglists ([o])}, :protocol IMeta} {:sym swap!, :meta {:doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in.", :arglists [[a f] [a f x] [a f x y] [a f x y & more]]}, :source "(defn\n swap!\n \"Atomically swaps the value of atom to be:\\n  (apply f current-value-of-atom args). Note that f may be called\\n  multiple times, and thus should be free of side effects.  Returns\\n  the value that was swapped in.\"\n ([a f]\n  (if (instance? Atom a) (reset! a (f (.-state a))) (-swap! a f)))\n ([a f x]\n  (if (instance? Atom a) (reset! a (f (.-state a) x)) (-swap! a f x)))\n ([a f x y]\n  (if\n   (instance? Atom a)\n   (reset! a (f (.-state a) x y))\n   (-swap! a f x y)))\n ([a f x y & more]\n  (if\n   (instance? Atom a)\n   (reset! a (apply f (.-state a) x y more))\n   (-swap! a f x y more))))\n"} {:sym -chunked-next, :meta {:doc "Returns a new collection of coll without the first chunk.", :arglists ([coll])}, :protocol IChunkedNext} {:sym unchecked-subtract, :meta {:doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n unchecked-subtract\n \"If no ys are supplied, returns the negation of x, else subtracts\\n  the ys from x and returns the result.\"\n ([x] (cljs.core/unchecked-subtract x))\n ([x y] (cljs.core/unchecked-subtract x y))\n ([x y & more]\n  (reduce unchecked-subtract (cljs.core/unchecked-subtract x y) more)))\n"} {:sym IMap, :meta {:doc "Protocol for adding mapping functionality to collections."}, :methods (-dissoc)} {:sym cloneable?, :meta {:doc "Return true if x implements ICloneable protocol.", :arglists ([value])}, :source "(defn\n cloneable?\n \"Return true if x implements ICloneable protocol.\"\n [value]\n (satisfies? ICloneable value))\n"} {:sym qualified-ident?, :meta {:doc "Return true if x is a symbol or keyword with a namespace", :arglists ([x])}, :source "(defn\n qualified-ident?\n \"Return true if x is a symbol or keyword with a namespace\"\n [x]\n (boolean (and (ident? x) (namespace x) true)))\n"} {:sym hash-string*, :meta {:doc nil, :arglists ([s])}, :source "(defn\n hash-string*\n [s]\n (if-not\n  (nil? s)\n  (let\n   [len (.-length s)]\n   (if\n    (pos? len)\n    (loop\n     [i 0 hash 0]\n     (if\n      (< i len)\n      (recur (inc i) (+ (imul 31 hash) (.charCodeAt s i)))\n      hash))\n    0))\n  0))\n"} {:sym true?, :meta {:doc "Returns true if x is the value true, false otherwise.", :arglists ([x])}, :source "(defn\n true?\n \"Returns true if x is the value true, false otherwise.\"\n [x]\n (cljs.core/true? x))\n"} {:sym array, :meta {:doc "Creates a new javascript array.\n@param {...*} var_args", :arglists ([var-args])}, :source "(defn\n array\n \"Creates a new javascript array.\\n@param {...*} var_args\"\n [var-args]\n (let\n  [a (js/Array. (alength (cljs.core/js-arguments)))]\n  (loop\n   [i 0]\n   (if\n    (< i (alength a))\n    (do (aset a i (aget (cljs.core/js-arguments) i)) (recur (inc i)))\n    a))))\n"} {:sym -peek, :meta {:doc "Returns the item from the top of the stack. Is used by cljs.core/peek.", :arglists ([coll])}, :protocol IStack} {:sym ISeq, :meta {:doc "Protocol for collections to provide access to their items as sequences."}, :methods (-first -rest)} {:sym empty, :meta {:doc "Returns an empty collection of the same category as coll, or nil", :arglists ([coll])}, :source "(defn\n empty\n \"Returns an empty collection of the same category as coll, or nil\"\n [coll]\n (when-not (nil? coll) (-empty coll)))\n"} {:sym volatile!, :meta {:doc "Creates and returns a Volatile with an initial value of val.", :arglists ([val])}, :source "(defn\n volatile!\n \"Creates and returns a Volatile with an initial value of val.\"\n [val]\n (Volatile. val))\n"} {:sym /, :meta {:doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n /\n \"If no denominators are supplied, returns 1/numerator,\\n  else returns numerator divided by all of the denominators.\"\n ([x] (/ 1 x))\n ([x y] (cljs.core/divide x y))\n ([x y & more] (reduce / (/ x y) more)))\n"} {:sym bit-or, :meta {:doc "Bitwise or", :arglists [[x y] [x y & more]]}, :source "(defn\n bit-or\n \"Bitwise or\"\n ([x y] (cljs.core/bit-or x y))\n ([x y & more] (reduce bit-or (cljs.core/bit-or x y) more)))\n"} {:sym m3-fmix, :meta {:doc nil, :arglists ([h1 len])}, :source "(defn\n m3-fmix\n [h1 len]\n (as->\n  (int h1)\n  h1\n  (bit-xor h1 len)\n  (bit-xor h1 (unsigned-bit-shift-right h1 16))\n  (imul h1 (int 2246822507))\n  (bit-xor h1 (unsigned-bit-shift-right h1 13))\n  (imul h1 (int 3266489909))\n  (bit-xor h1 (unsigned-bit-shift-right h1 16))))\n"} {:sym vector, :meta {:doc "Creates a new vector containing the args.", :arglists ([& args])}, :source "(defn\n vector\n \"Creates a new vector containing the args.\"\n [& args]\n (if\n  (and (instance? IndexedSeq args) (zero? (.-i args)))\n  (.fromArray PersistentVector (.-arr args) true)\n  (vec args)))\n"} {:sym >=, :meta {:doc "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n >=\n \"Returns non-nil if nums are in monotonically non-increasing order,\\n  otherwise false.\"\n ([x] true)\n ([x y] (cljs.core/>= x y))\n ([x y & more]\n  (if\n   (cljs.core/>= x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (cljs.core/>= y (first more)))\n   false)))\n"} {:sym drop-last, :meta {:doc "Return a lazy sequence of all but the last n (default 1) items in coll", :arglists [[s] [n s]]}, :source "(defn\n drop-last\n \"Return a lazy sequence of all but the last n (default 1) items in coll\"\n ([s] (drop-last 1 s))\n ([n s] (map (fn [x _] x) s (drop n s))))\n"} {:sym object?, :meta {:doc "Returns true if x's constructor is Object", :arglists ([x])}, :source "(defn\n object?\n \"Returns true if x's constructor is Object\"\n [x]\n (if-not (nil? x) (identical? (.-constructor x) js/Object) false))\n"} {:sym not-empty, :meta {:doc "If coll is empty, returns nil, else coll", :arglists ([coll])}, :source "(defn\n not-empty\n \"If coll is empty, returns nil, else coll\"\n [coll]\n (when (seq coll) coll))\n"} {:sym partition, :meta {:doc "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition up to n items. In case there are\n  not enough padding elements, return a partition with less than n items.", :arglists [[n coll] [n step coll] [n step pad coll]]}, :source "(defn\n partition\n \"Returns a lazy sequence of lists of n items each, at offsets step\\n  apart. If step is not supplied, defaults to n, i.e. the partitions\\n  do not overlap. If a pad collection is supplied, use its elements as\\n  necessary to complete last partition up to n items. In case there are\\n  not enough padding elements, return a partition with less than n items.\"\n ([n coll] (partition n n coll))\n ([n step coll]\n  (lazy-seq\n   (when-let\n    [s (seq coll)]\n    (let\n     [p (take n s)]\n     (when\n      (== n (count p))\n      (cons p (partition n step (drop step s))))))))\n ([n step pad coll]\n  (lazy-seq\n   (when-let\n    [s (seq coll)]\n    (let\n     [p (take n s)]\n     (if\n      (== n (count p))\n      (cons p (partition n step pad (drop step s)))\n      (list (take n (concat p pad)))))))))\n"} {:sym DEMUNGE_PATTERN, :meta {}, :source "(def DEMUNGE_PATTERN nil)\n"} {:sym IAssociative, :meta {:doc "Protocol for adding associativity to collections."}, :methods (-assoc -contains-key?)} {:sym bit-flip, :meta {:doc "Flip bit at index n", :arglists ([x n])}, :source "(defn bit-flip \"Flip bit at index n\" [x n] (cljs.core/bit-flip x n))\n"} {:sym long-array, :meta {:doc "Creates an array of longs. Does not coerce array, provided for compatibility\n  with Clojure.", :arglists [[size-or-seq] [size init-val-or-seq]]}, :source "(defn\n long-array\n \"Creates an array of longs. Does not coerce array, provided for compatibility\\n  with Clojure.\"\n ([size-or-seq]\n  (if\n   (number? size-or-seq)\n   (long-array size-or-seq nil)\n   (into-array size-or-seq)))\n ([size init-val-or-seq]\n  (let\n   [a (make-array size)]\n   (if\n    (seq? init-val-or-seq)\n    (let\n     [s (seq init-val-or-seq)]\n     (loop\n      [i 0 s s]\n      (if\n       (and s (< i size))\n       (do (aset a i (first s)) (recur (inc i) (next s)))\n       a)))\n    (do (dotimes [i size] (aset a i init-val-or-seq)) a)))))\n"} {:sym ISeqable, :meta {:doc "Protocol for adding the ability to a type to be transformed into a sequence."}, :methods (-seq)} {:sym js-mod, :meta {:doc "Modulus of num and div with original javascript behavior. i.e. bug for negative numbers", :arglists ([n d])}, :source "(defn\n js-mod\n \"Modulus of num and div with original javascript behavior. i.e. bug for negative numbers\"\n [n d]\n (cljs.core/js-mod n d))\n"} {:sym integer?, :meta {:doc "Returns true if n is a JavaScript number with no decimal part.", :arglists ([n])}, :source "(defn\n integer?\n \"Returns true if n is a JavaScript number with no decimal part.\"\n [n]\n (and\n  (number? n)\n  (not (js/isNaN n))\n  (not (identical? n js/Infinity))\n  (== (js/parseFloat n) (js/parseInt n 10))))\n"} {:sym mapv, :meta {:doc "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.", :arglists [[f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]]}, :source "(defn\n mapv\n \"Returns a vector consisting of the result of applying f to the\\n  set of first items of each coll, followed by applying f to the set\\n  of second items in each coll, until any one of the colls is\\n  exhausted.  Any remaining items in other colls are ignored. Function\\n  f should accept number-of-colls arguments.\"\n ([f coll]\n  (->\n   (reduce (fn [v o] (conj! v (f o))) (transient []) coll)\n   persistent!))\n ([f c1 c2] (into [] (map f c1 c2)))\n ([f c1 c2 c3] (into [] (map f c1 c2 c3)))\n ([f c1 c2 c3 & colls] (into [] (apply map f c1 c2 c3 colls))))\n"} {:sym infinite?, :meta {:doc "Returns true for Infinity and -Infinity values.", :arglists ([x])}, :source "(defn\n infinite?\n \"Returns true for Infinity and -Infinity values.\"\n [x]\n (or\n  (identical? x js/Number.POSITIVE_INFINITY)\n  (identical? x js/Number.NEGATIVE_INFINITY)))\n"} {:sym ISequential, :meta {:doc "Marker interface indicating a persistent collection of sequential items"}, :methods ()} {:sym equiv-map, :meta {:doc "Test map equivalence. Returns true if x equals y, otherwise returns false.", :arglists ([x y])}, :source "(defn\n equiv-map\n \"Test map equivalence. Returns true if x equals y, otherwise returns false.\"\n [x y]\n (boolean\n  (when\n   (and (map? y) (not (record? y)))\n   (when\n    (== (count x) (count y))\n    (if\n     (satisfies? IKVReduce x)\n     (reduce-kv\n      (fn\n       [_ k v]\n       (if (= (get y k never-equiv) v) true (reduced false)))\n      true\n      x)\n     (every?\n      (fn [xkv] (= (get y (first xkv) never-equiv) (second xkv)))\n      x))))))\n"} {:sym object-array, :meta {:doc "Creates an array of objects. Does not coerce array, provided for compatibility\n  with Clojure.", :arglists [[size-or-seq] [size init-val-or-seq]]}, :source "(defn\n object-array\n \"Creates an array of objects. Does not coerce array, provided for compatibility\\n  with Clojure.\"\n ([size-or-seq]\n  (if\n   (number? size-or-seq)\n   (object-array size-or-seq nil)\n   (into-array size-or-seq)))\n ([size init-val-or-seq]\n  (let\n   [a (make-array size)]\n   (if\n    (seq? init-val-or-seq)\n    (let\n     [s (seq init-val-or-seq)]\n     (loop\n      [i 0 s s]\n      (if\n       (and s (< i size))\n       (do (aset a i (first s)) (recur (inc i) (next s)))\n       a)))\n    (do (dotimes [i size] (aset a i init-val-or-seq)) a)))))\n"} {:sym seq-iter, :meta {:doc nil, :arglists ([coll])}, :source "(defn seq-iter [coll] (SeqIter. INIT coll))\n"} {:sym IChunkedSeq, :meta {:doc "Protocol for accessing a collection as sequential chunks."}, :methods (-chunked-first -chunked-rest)} {:sym -next, :meta {:doc "Returns a new collection of coll without the first item. In contrast to\n     rest, it should return nil if there are no more items, e.g.\n     (next []) => nil\n     (next nil) => nil", :arglists ([coll])}, :protocol INext} {:sym flatten, :meta {:doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns nil.", :arglists ([x])}, :source "(defn\n flatten\n \"Takes any nested combination of sequential things (lists, vectors,\\n  etc.) and returns their contents as a single, flat sequence.\\n  (flatten nil) returns nil.\"\n [x]\n (filter\n  (fn* [p1__18134#] (not (sequential? p1__18134#)))\n  (rest (tree-seq sequential? seq x))))\n"} {:sym -dissoc, :meta {:doc "Returns a new collection of coll without the mapping for key k.", :arglists ([coll k])}, :protocol IMap} {:sym doubles, :meta {:doc nil, :arglists ([x])}, :source "(defn doubles [x] x)\n"} {:sym -contains-key?, :meta {:doc "Returns true if k is a key in coll.", :arglists ([coll k])}, :protocol IAssociative} {:sym ifn?, :meta {:doc "Returns true if f returns true for fn? or satisfies IFn.", :arglists ([f])}, :source "(defn\n ifn?\n \"Returns true if f returns true for fn? or satisfies IFn.\"\n [f]\n (or (fn? f) (satisfies? IFn f)))\n"} {:sym IAtom, :meta {:doc "Marker protocol indicating an atom."}, :methods ()} {:sym nat-int?, :meta {:doc "Return true if x satisfies int? and is a natural integer value.", :arglists ([x])}, :source "(defn\n nat-int?\n \"Return true if x satisfies int? and is a natural integer value.\"\n [x]\n (cond\n  (integer? x)\n  (or (not (neg? x)) (zero? x))\n  (instance? goog.math.Integer x)\n  (or (not (.isNegative x)) (.isZero x))\n  (instance? goog.math.Long x)\n  (or (not (.isNegative x)) (.isZero x))\n  :else\n  false))\n"} {:sym IWatchable, :meta {:doc "Protocol for types that can be watched. Currently only implemented by Atom."}, :methods (-add-watch -notify-watches -remove-watch)} {:sym subvec, :meta {:doc "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done.", :arglists [[v start] [v start end]]}, :source "(defn\n subvec\n \"Returns a persistent vector of the items in vector from\\n  start (inclusive) to end (exclusive).  If end is not supplied,\\n  defaults to (count vector). This operation is O(1) and very fast, as\\n  the resulting vector shares structure with the original and no\\n  trimming is done.\"\n ([v start] (subvec v start (count v)))\n ([v start end]\n  (assert (and (not (nil? start)) (not (nil? end))))\n  (build-subvec nil v start end nil)))\n"} {:sym -pop!, :meta {:doc "Returns tcoll with the last item removed from it.", :arglists ([tcoll])}, :protocol ITransientVector} {:sym partial, :meta {:doc "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args.", :arglists [[f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more]]}, :source "(defn\n partial\n \"Takes a function f and fewer than the normal arguments to f, and\\n  returns a fn that takes a variable number of additional args. When\\n  called, the returned function calls f with args + additional args.\"\n ([f] f)\n ([f arg1]\n  (fn\n   ([] (f arg1))\n   ([x] (f arg1 x))\n   ([x y] (f arg1 x y))\n   ([x y z] (f arg1 x y z))\n   ([x y z & args] (apply f arg1 x y z args))))\n ([f arg1 arg2]\n  (fn\n   ([] (f arg1 arg2))\n   ([x] (f arg1 arg2 x))\n   ([x y] (f arg1 arg2 x y))\n   ([x y z] (f arg1 arg2 x y z))\n   ([x y z & args] (apply f arg1 arg2 x y z args))))\n ([f arg1 arg2 arg3]\n  (fn\n   ([] (f arg1 arg2 arg3))\n   ([x] (f arg1 arg2 arg3 x))\n   ([x y] (f arg1 arg2 arg3 x y))\n   ([x y z] (f arg1 arg2 arg3 x y z))\n   ([x y z & args] (apply f arg1 arg2 arg3 x y z args))))\n ([f arg1 arg2 arg3 & more]\n  (fn [& args] (apply f arg1 arg2 arg3 (concat more args)))))\n"} {:sym chunked-seq?, :meta {:doc "Return true if x is satisfies IChunkedSeq.", :arglists ([x])}, :source "(defn\n chunked-seq?\n \"Return true if x is satisfies IChunkedSeq.\"\n [x]\n (implements? IChunkedSeq x))\n"} {:sym replicate, :meta {:doc "DEPRECATED: Use 'repeat' instead.\n  Returns a lazy seq of n xs.", :arglists ([n x])}, :source "(defn\n replicate\n \"DEPRECATED: Use 'repeat' instead.\\n  Returns a lazy seq of n xs.\"\n [n x]\n (take n (repeat x)))\n"} {:sym reduced, :meta {:doc "Wraps x in a way such that a reduce will terminate with the value x", :arglists ([x])}, :source "(defn\n reduced\n \"Wraps x in a way such that a reduce will terminate with the value x\"\n [x]\n (Reduced. x))\n"} {:sym ITransientSet, :meta {:doc "Protocol for adding set functionality to a transient collection."}, :methods (-disjoin!)} {:sym unchecked-byte, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-byte [x] x)\n"} {:sym every-pred, :meta {:doc "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates.", :arglists [[p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]]}, :source "(defn\n every-pred\n \"Takes a set of predicates and returns a function f that returns true if all of its\\n  composing predicates return a logical true value against all of its arguments, else it returns\\n  false. Note that f is short-circuiting in that it will stop execution on the first\\n  argument that triggers a logical false result against the original predicates.\"\n ([p]\n  (fn\n   ep1\n   ([] true)\n   ([x] (boolean (p x)))\n   ([x y] (boolean (and (p x) (p y))))\n   ([x y z] (boolean (and (p x) (p y) (p z))))\n   ([x y z & args] (boolean (and (ep1 x y z) (every? p args))))))\n ([p1 p2]\n  (fn\n   ep2\n   ([] true)\n   ([x] (boolean (and (p1 x) (p2 x))))\n   ([x y] (boolean (and (p1 x) (p1 y) (p2 x) (p2 y))))\n   ([x y z] (boolean (and (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z))))\n   ([x y z & args]\n    (boolean\n     (and\n      (ep2 x y z)\n      (every?\n       (fn* [p1__18121#] (and (p1 p1__18121#) (p2 p1__18121#)))\n       args))))))\n ([p1 p2 p3]\n  (fn\n   ep3\n   ([] true)\n   ([x] (boolean (and (p1 x) (p2 x) (p3 x))))\n   ([x y] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y))))\n   ([x y z]\n    (boolean\n     (and\n      (p1 x)\n      (p2 x)\n      (p3 x)\n      (p1 y)\n      (p2 y)\n      (p3 y)\n      (p1 z)\n      (p2 z)\n      (p3 z))))\n   ([x y z & args]\n    (boolean\n     (and\n      (ep3 x y z)\n      (every?\n       (fn*\n        [p1__18122#]\n        (and (p1 p1__18122#) (p2 p1__18122#) (p3 p1__18122#)))\n       args))))))\n ([p1 p2 p3 & ps]\n  (let\n   [ps (list* p1 p2 p3 ps)]\n   (fn\n    epn\n    ([] true)\n    ([x] (every? (fn* [p1__18123#] (p1__18123# x)) ps))\n    ([x y]\n     (every?\n      (fn* [p1__18124#] (and (p1__18124# x) (p1__18124# y)))\n      ps))\n    ([x y z]\n     (every?\n      (fn*\n       [p1__18125#]\n       (and (p1__18125# x) (p1__18125# y) (p1__18125# z)))\n      ps))\n    ([x y z & args]\n     (boolean\n      (and\n       (epn x y z)\n       (every? (fn* [p1__18126#] (every? p1__18126# args)) ps))))))))\n"} {:sym missing-protocol, :meta {:doc nil, :arglists ([proto obj])}, :source "(defn\n missing-protocol\n [proto obj]\n (let\n  [ty\n   (type obj)\n   ty\n   (if\n    (and ty (.-cljs$lang$type ty))\n    (.-cljs$lang$ctorStr ty)\n    (goog/typeOf obj))]\n  (js/Error.\n   (.join\n    (array\n     \"No protocol method \"\n     proto\n     \" defined for type \"\n     ty\n     \": \"\n     obj)\n    \"\"))))\n"} {:sym load-file, :meta {:doc nil, :arglists ([file])}, :source "(defn\n load-file\n [file]\n (when-not js/COMPILED (cljs.core/load-file* file)))\n"} {:sym distinct?, :meta {:doc "Returns true if no two of the arguments are =", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n distinct?\n \"Returns true if no two of the arguments are =\"\n ([x] true)\n ([x y] (not (= x y)))\n ([x y & more]\n  (if\n   (not (= x y))\n   (loop\n    [s #{x y} xs more]\n    (let\n     [x (first xs) etc (next xs)]\n     (if xs (if (contains? s x) false (recur (conj s x) etc)) true)))\n   false)))\n"} {:sym pos-int?, :meta {:doc "Return true if x satisfies int? and is positive.", :arglists ([x])}, :source "(defn\n pos-int?\n \"Return true if x satisfies int? and is positive.\"\n [x]\n (cond\n  (integer? x)\n  (pos? x)\n  (instance? goog.math.Integer x)\n  (and (not (.isNegative x)) (not (.isZero x)))\n  (instance? goog.math.Long x)\n  (and (not (.isNegative x)) (not (.isZero x)))\n  :else\n  false))\n"} {:sym unchecked-short, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-short [x] x)\n"} {:sym odd?, :meta {:doc "Returns true if n is odd, throws an exception if n is not an integer", :arglists ([n])}, :source "(defn\n odd?\n \"Returns true if n is odd, throws an exception if n is not an integer\"\n [n]\n (not (even? n)))\n"} {:sym reduceable?, :meta {:doc "Returns true if coll satisfies IReduce", :arglists ([x])}, :source "(defn\n reduceable?\n \"Returns true if coll satisfies IReduce\"\n [x]\n (satisfies? IReduce x))\n"} {:sym string-hash-cache, :meta {}, :source "(def string-hash-cache (js-obj))\n"} {:sym inc, :meta {:doc "Returns a number one greater than num.", :arglists ([x])}, :source "(defn\n inc\n \"Returns a number one greater than num.\"\n [x]\n (cljs.core/+ x 1))\n"} {:sym type->str, :meta {:doc nil, :arglists ([ty])}, :source "(defn type->str [ty] (if-let [s (.-cljs$lang$ctorStr ty)] s (str ty)))\n"} {:sym bit-clear, :meta {:doc "Clear bit at index n", :arglists ([x n])}, :source "(defn bit-clear \"Clear bit at index n\" [x n] (cljs.core/bit-clear x n))\n"} {:sym filter, :meta {:doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :arglists [[pred] [pred coll]]}, :source "(defn\n filter\n \"Returns a lazy sequence of the items in coll for which\\n  (pred item) returns true. pred must be free of side-effects.\\n  Returns a transducer when no collection is provided.\"\n ([pred]\n  (fn\n   [rf]\n   (fn\n    ([] (rf))\n    ([result] (rf result))\n    ([result input] (if (pred input) (rf result input) result)))))\n ([pred coll]\n  (lazy-seq\n   (when-let\n    [s (seq coll)]\n    (if\n     (chunked-seq? s)\n     (let\n      [c (chunk-first s) size (count c) b (chunk-buffer size)]\n      (dotimes\n       [i size]\n       (when (pred (-nth c i)) (chunk-append b (-nth c i))))\n      (chunk-cons (chunk b) (filter pred (chunk-rest s))))\n     (let\n      [f (first s) r (rest s)]\n      (if (pred f) (cons f (filter pred r)) (filter pred r))))))))\n"} {:sym -assoc-n!, :meta {:doc "Returns tcoll with value val added at position n.", :arglists ([tcoll n val])}, :protocol ITransientVector} {:sym IWithMeta, :meta {:doc "Protocol for adding metadata to an object."}, :methods (-with-meta)} {:sym list, :meta {:doc "Creates a new list containing the items.", :arglists ([& xs])}, :source "(defn\n list\n \"Creates a new list containing the items.\"\n [& xs]\n (let\n  [arr\n   (if\n    (and (instance? IndexedSeq xs) (zero? (.-i xs)))\n    (.-arr xs)\n    (let\n     [arr (array)]\n     (loop\n      [xs xs]\n      (if-not\n       (nil? xs)\n       (do (.push arr (-first xs)) (recur (-next xs)))\n       arr))))]\n  (loop\n   [i (alength arr) r ()]\n   (if (> i 0) (recur (dec i) (-conj r (aget arr (dec i)))) r))))\n"} {:sym +, :meta {:doc "Returns the sum of nums. (+) returns 0.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n +\n \"Returns the sum of nums. (+) returns 0.\"\n ([] 0)\n ([x] x)\n ([x y] (cljs.core/+ x y))\n ([x y & more] (reduce + (cljs.core/+ x y) more)))\n"} {:sym aset, :meta {:doc "Sets the value at the index/indices. Works on JavaScript arrays.\n  Returns val.", :arglists [[array idx val] [array idx idx2 & idxv]]}, :source "(defn\n aset\n \"Sets the value at the index/indices. Works on JavaScript arrays.\\n  Returns val.\"\n ([array idx val] (cljs.core/aset array idx val))\n ([array idx idx2 & idxv] (apply aset (aget array idx) idx2 idxv)))\n"} {:sym int-rotate-left, :meta {:doc nil, :arglists ([x n])}, :source "(defn\n int-rotate-left\n [x n]\n (bit-or (bit-shift-left x n) (unsigned-bit-shift-right x (- n))))\n"} {:sym keyword, :meta {:doc "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically.", :arglists [[name] [ns name]]}, :source "(defn\n keyword\n \"Returns a Keyword with the given namespace and name.  Do not use :\\n  in the keyword strings, it will be added automatically.\"\n ([name]\n  (cond\n   (keyword? name)\n   name\n   (symbol? name)\n   (Keyword.\n    (cljs.core/namespace name)\n    (cljs.core/name name)\n    (.-str name)\n    nil)\n   (string? name)\n   (let\n    [parts (.split name \"/\")]\n    (if\n     (== (alength parts) 2)\n     (Keyword. (aget parts 0) (aget parts 1) name nil)\n     (Keyword. nil (aget parts 0) name nil)))))\n ([ns name]\n  (let\n   [ns\n    (cond\n     (keyword? ns)\n     (cljs.core/name ns)\n     (symbol? ns)\n     (cljs.core/name ns)\n     :else\n     ns)\n    name\n    (cond\n     (keyword? name)\n     (cljs.core/name name)\n     (symbol? name)\n     (cljs.core/name name)\n     :else\n     name)]\n   (Keyword. ns name (str (when ns (str ns \"/\")) name) nil))))\n"} {:sym *ns*, :meta {:doc "Var bound to the current namespace. Only used for bootstrapping."}, :source "(def *ns* nil)\n"} {:sym *assert*, :meta {}, :source "(def *assert* true)\n"} {:sym ICollection, :meta {:doc "Protocol for adding to a collection."}, :methods (-conj)} {:sym chars, :meta {:doc nil, :arglists ([x])}, :source "(defn chars [x] x)\n"} {:sym next, :meta {:doc "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil", :arglists ([coll])}, :source "(defn\n next\n \"Returns a seq of the items after the first. Calls seq on its\\n  argument.  If there are no more items, returns nil\"\n [coll]\n (when-not\n  (nil? coll)\n  (if (implements? INext coll) (-next coll) (seq (rest coll)))))\n"} {:sym ASeq, :meta {:doc "Marker protocol indicating an array sequence."}, :methods ()} {:sym IFn, :meta {:doc "Protocol for adding the ability to invoke an object as a function.\n  For example, a vector can also be used to look up a value:\n  ([1 2 3 4] 1) => 2"}, :methods (-invoke)} {:sym -reset!, :meta {:doc "Sets the value of o to new-value.", :arglists ([o new-value])}, :protocol IReset} {:sym -rest, :meta {:doc "Returns a new collection of coll without the first item. It should\n     always return a seq, e.g.\n     (rest []) => ()\n     (rest nil) => ()", :arglists ([coll])}, :protocol ISeq} {:sym nil-iter, :meta {:doc nil, :arglists ([])}, :source "(defn\n nil-iter\n []\n (reify\n  Object\n  (hasNext [_] false)\n  (next [_] (js/Error. \"No such element\"))\n  (remove [_] (js/Error. \"Unsupported operation\"))))\n"} {:sym false?, :meta {:doc "Returns true if x is the value false, false otherwise.", :arglists ([x])}, :source "(defn\n false?\n \"Returns true if x is the value false, false otherwise.\"\n [x]\n (cljs.core/false? x))\n"} {:sym *print-readably*, :meta {:doc "When set to logical false, strings and characters will be printed with\n  non-alphanumeric characters converted to the appropriate escape sequences.\n\n  Defaults to true"}, :source "(def *print-readably* true)\n"} {:sym ints, :meta {:doc nil, :arglists ([x])}, :source "(defn ints [x] x)\n"} {:sym some-fn, :meta {:doc "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates.", :arglists [[p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]]}, :source "(defn\n some-fn\n \"Takes a set of predicates and returns a function f that returns the first logical true value\\n  returned by one of its composing predicates against any of its arguments, else it returns\\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\\n  argument that triggers a logical true result against the original predicates.\"\n ([p]\n  (fn\n   sp1\n   ([] nil)\n   ([x] (p x))\n   ([x y] (or (p x) (p y)))\n   ([x y z] (or (p x) (p y) (p z)))\n   ([x y z & args] (or (sp1 x y z) (some p args)))))\n ([p1 p2]\n  (fn\n   sp2\n   ([] nil)\n   ([x] (or (p1 x) (p2 x)))\n   ([x y] (or (p1 x) (p1 y) (p2 x) (p2 y)))\n   ([x y z] (or (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z)))\n   ([x y z & args]\n    (or\n     (sp2 x y z)\n     (some\n      (fn* [p1__18127#] (or (p1 p1__18127#) (p2 p1__18127#)))\n      args)))))\n ([p1 p2 p3]\n  (fn\n   sp3\n   ([] nil)\n   ([x] (or (p1 x) (p2 x) (p3 x)))\n   ([x y] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y)))\n   ([x y z]\n    (or\n     (p1 x)\n     (p2 x)\n     (p3 x)\n     (p1 y)\n     (p2 y)\n     (p3 y)\n     (p1 z)\n     (p2 z)\n     (p3 z)))\n   ([x y z & args]\n    (or\n     (sp3 x y z)\n     (some\n      (fn*\n       [p1__18128#]\n       (or (p1 p1__18128#) (p2 p1__18128#) (p3 p1__18128#)))\n      args)))))\n ([p1 p2 p3 & ps]\n  (let\n   [ps (list* p1 p2 p3 ps)]\n   (fn\n    spn\n    ([] nil)\n    ([x] (some (fn* [p1__18129#] (p1__18129# x)) ps))\n    ([x y]\n     (some (fn* [p1__18130#] (or (p1__18130# x) (p1__18130# y))) ps))\n    ([x y z]\n     (some\n      (fn*\n       [p1__18131#]\n       (or (p1__18131# x) (p1__18131# y) (p1__18131# z)))\n      ps))\n    ([x y z & args]\n     (or\n      (spn x y z)\n      (some (fn* [p1__18132#] (some p1__18132# args)) ps)))))))\n"} {:sym *flush-on-newline*, :meta {:doc "When set to true, output will be flushed whenever a newline is printed.\n\n  Defaults to true."}, :source "(def *flush-on-newline* true)\n"} {:sym to-array, :meta {:doc "Naive impl of to-array as a start.", :arglists ([s])}, :source "(defn\n to-array\n \"Naive impl of to-array as a start.\"\n [s]\n (let\n  [ary (array)]\n  (loop\n   [s (seq s)]\n   (if-not (nil? s) (do (. ary push (first s)) (recur (next s))) ary))))\n"} {:sym list?, :meta {:doc "Returns true if x implements IList", :arglists ([x])}, :source "(defn\n list?\n \"Returns true if x implements IList\"\n [x]\n (satisfies? IList x))\n"} {:sym array?, :meta {:doc "Returns true if x is a JavaScript array.", :arglists ([x])}, :source "(defn\n array?\n \"Returns true if x is a JavaScript array.\"\n [x]\n (if\n  (identical? *target* \"nodejs\")\n  (.isArray js/Array x)\n  (instance? js/Array x)))\n"} {:sym simple-ident?, :meta {:doc "Return true if x is a symbol or keyword without a namespace", :arglists ([x])}, :source "(defn\n simple-ident?\n \"Return true if x is a symbol or keyword without a namespace\"\n [x]\n (and (ident? x) (nil? (namespace x))))\n"} {:sym clone, :meta {:doc "Clone the supplied value which must implement ICloneable.", :arglists ([value])}, :source "(defn\n clone\n \"Clone the supplied value which must implement ICloneable.\"\n [value]\n (-clone value))\n"} {:sym bit-not, :meta {:doc "Bitwise complement", :arglists ([x])}, :source "(defn bit-not \"Bitwise complement\" [x] (cljs.core/bit-not x))\n"} {:sym byte, :meta {:doc nil, :arglists ([x])}, :source "(defn byte [x] x)\n"} {:sym max, :meta {:doc "Returns the greatest of the nums.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n max\n \"Returns the greatest of the nums.\"\n ([x] x)\n ([x y] (cljs.core/max x y))\n ([x y & more] (reduce max (cljs.core/max x y) more)))\n"} {:sym IComparable, :meta {:doc "Protocol for values that can be compared."}, :methods (-compare)} {:sym ==, :meta {:doc "Returns non-nil if nums all have the equivalent\n  value, otherwise false. Behavior on non nums is\n  undefined.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n ==\n \"Returns non-nil if nums all have the equivalent\\n  value, otherwise false. Behavior on non nums is\\n  undefined.\"\n ([x] true)\n ([x y] (-equiv x y))\n ([x y & more]\n  (if\n   (== x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (== y (first more)))\n   false)))\n"} {:sym count, :meta {:doc "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Maps", :arglists ([coll])}, :source "(defn\n count\n \"Returns the number of items in the collection. (count nil) returns\\n  0.  Also works on strings, arrays, and Maps\"\n [coll]\n (if-not\n  (nil? coll)\n  (cond\n   (implements? ICounted coll)\n   (-count coll)\n   (array? coll)\n   (alength coll)\n   (string? coll)\n   (.-length coll)\n   (implements? ISeqable coll)\n   (accumulating-seq-count coll)\n   :else\n   (-count coll))\n  0))\n"} {:sym -disjoin!, :meta {:doc "Returns tcoll without v.", :arglists ([tcoll v])}, :protocol ITransientSet} {:sym *loaded-libs*, :meta {}, :source "(defonce *loaded-libs* nil)\n"} {:sym apply, :meta {:doc "Applies fn f to the argument list formed by prepending intervening arguments to args.", :arglists [[f args] [f x args] [f x y args] [f x y z args] [f a b c d & args]]}, :source "(defn\n apply\n \"Applies fn f to the argument list formed by prepending intervening arguments to args.\"\n ([f args]\n  (if\n   (.-cljs$lang$applyTo f)\n   (let\n    [fixed-arity\n     (.-cljs$lang$maxFixedArity f)\n     bc\n     (bounded-count (inc fixed-arity) args)]\n    (if\n     (<= bc fixed-arity)\n     (apply-to f bc args)\n     (.cljs$lang$applyTo f args)))\n   (apply-to-simple f (seq args))))\n ([f x args]\n  (if\n   (.-cljs$lang$applyTo f)\n   (let\n    [arglist\n     (list* x args)\n     fixed-arity\n     (.-cljs$lang$maxFixedArity f)\n     bc\n     (inc (bounded-count fixed-arity args))]\n    (if\n     (<= bc fixed-arity)\n     (apply-to f bc arglist)\n     (.cljs$lang$applyTo f arglist)))\n   (apply-to-simple f x (seq args))))\n ([f x y args]\n  (if\n   (.-cljs$lang$applyTo f)\n   (let\n    [arglist\n     (list* x y args)\n     fixed-arity\n     (.-cljs$lang$maxFixedArity f)\n     bc\n     (+ 2 (bounded-count (dec fixed-arity) args))]\n    (if\n     (<= bc fixed-arity)\n     (apply-to f bc arglist)\n     (.cljs$lang$applyTo f arglist)))\n   (apply-to-simple f x y (seq args))))\n ([f x y z args]\n  (if\n   (.-cljs$lang$applyTo f)\n   (let\n    [arglist\n     (list* x y z args)\n     fixed-arity\n     (.-cljs$lang$maxFixedArity f)\n     bc\n     (+ 3 (bounded-count (- fixed-arity 2) args))]\n    (if\n     (<= bc fixed-arity)\n     (apply-to f bc arglist)\n     (.cljs$lang$applyTo f arglist)))\n   (apply-to-simple f x y z (seq args))))\n ([f a b c d & args]\n  (if\n   (.-cljs$lang$applyTo f)\n   (let\n    [spread-args\n     (spread args)\n     arglist\n     (cons a (cons b (cons c (cons d spread-args))))\n     fixed-arity\n     (.-cljs$lang$maxFixedArity f)\n     bc\n     (+ 4 (bounded-count (- fixed-arity 3) spread-args))]\n    (if\n     (<= bc fixed-arity)\n     (apply-to f bc arglist)\n     (.cljs$lang$applyTo f arglist)))\n   (apply-to-simple f a b c d (spread args)))))\n"} {:sym add-to-string-hash-cache, :meta {:doc nil, :arglists ([k])}, :source "(defn\n add-to-string-hash-cache\n [k]\n (let\n  [h (hash-string* k)]\n  (gobject/set string-hash-cache k h)\n  (set! string-hash-cache-count (inc string-hash-cache-count))\n  h))\n"} {:sym IChunkedNext, :meta {:doc "Protocol for accessing the chunks of a collection."}, :methods (-chunked-next)} {:sym interpose, :meta {:doc "Returns a lazy seq of the elements of coll separated by sep.\n  Returns a stateful transducer when no collection is provided.", :arglists [[sep] [sep coll]]}, :source "(defn\n interpose\n \"Returns a lazy seq of the elements of coll separated by sep.\\n  Returns a stateful transducer when no collection is provided.\"\n ([sep]\n  (fn\n   [rf]\n   (let\n    [started (volatile! false)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input]\n      (if\n       @started\n       (let\n        [sepr (rf result sep)]\n        (if (reduced? sepr) sepr (rf sepr input)))\n       (do (vreset! started true) (rf result input))))))))\n ([sep coll] (drop 1 (interleave (repeat sep) coll))))\n"} {:sym deref, :meta {:doc "Also reader macro: @var/@atom/@delay. Returns the\n   most-recently-committed value of ref. When applied to a var\n   or atom, returns its current state. When applied to a delay, forces\n   it if not already forced. See also - realized?.", :arglists ([o])}, :source "(defn\n deref\n \"Also reader macro: @var/@atom/@delay. Returns the\\n   most-recently-committed value of ref. When applied to a var\\n   or atom, returns its current state. When applied to a delay, forces\\n   it if not already forced. See also - realized?.\"\n [o]\n (-deref o))\n"} {:sym assoc, :meta {:doc "assoc[iate]. When applied to a map, returns a new map of the\n   same (hashed/sorted) type, that contains the mapping of key(s) to\n   val(s). When applied to a vector, returns a new vector that\n   contains val at index.", :arglists [[coll k v] [coll k v & kvs]]}, :source "(defn\n assoc\n \"assoc[iate]. When applied to a map, returns a new map of the\\n   same (hashed/sorted) type, that contains the mapping of key(s) to\\n   val(s). When applied to a vector, returns a new vector that\\n   contains val at index.\"\n ([coll k v] (if-not (nil? coll) (-assoc coll k v) (array-map k v)))\n ([coll k v & kvs]\n  (let\n   [ret (assoc coll k v)]\n   (if kvs (recur ret (first kvs) (second kvs) (nnext kvs)) ret))))\n"} {:sym transient, :meta {:doc "Returns a new, transient version of the collection, in constant time.", :arglists ([coll])}, :source "(defn\n transient\n \"Returns a new, transient version of the collection, in constant time.\"\n [coll]\n (-as-transient coll))\n"} {:sym -disjoin, :meta {:doc "Returns a new collection of coll that does not contain v.", :arglists ([coll v])}, :protocol ISet} {:sym chunk-cons, :meta {:doc nil, :arglists ([chunk rest])}, :source "(defn\n chunk-cons\n [chunk rest]\n (if (zero? (-count chunk)) rest (ChunkedCons. chunk rest nil nil)))\n"} {:sym drop-while, :meta {:doc "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided.", :arglists [[pred] [pred coll]]}, :source "(defn\n drop-while\n \"Returns a lazy sequence of the items in coll starting from the\\n  first item for which (pred item) returns logical false.  Returns a\\n  stateful transducer when no collection is provided.\"\n ([pred]\n  (fn\n   [rf]\n   (let\n    [da (volatile! true)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input]\n      (let\n       [drop? @da]\n       (if\n        (and drop? (pred input))\n        result\n        (do (vreset! da nil) (rf result input)))))))))\n ([pred coll]\n  (let\n   [step\n    (fn\n     [pred coll]\n     (let\n      [s (seq coll)]\n      (if (and s (pred (first s))) (recur pred (rest s)) s)))]\n   (lazy-seq (step pred coll)))))\n"} {:sym IWriter, :meta {:doc "Protocol for writing. Currently only implemented by StringBufferWriter."}, :methods (-flush -write)} {:sym *print-fn*, :meta {:doc "Each runtime environment provides a different way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed."}, :source "(defonce *print-fn* nil)\n"} {:sym compare, :meta {:doc "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Uses IComparable if available and google.array.defaultCompare for objects\n of the same type and special-cases nil to be less than any other object.", :arglists ([x y])}, :source "(defn\n compare\n \"Comparator. Returns a negative number, zero, or a positive number\\n  when x is logically 'less than', 'equal to', or 'greater than'\\n  y. Uses IComparable if available and google.array.defaultCompare for objects\\n of the same type and special-cases nil to be less than any other object.\"\n [x y]\n (cond\n  (identical? x y)\n  0\n  (nil? x)\n  -1\n  (nil? y)\n  1\n  (number? x)\n  (if\n   (number? y)\n   (garray/defaultCompare x y)\n   (throw (js/Error. (str \"Cannot compare \" x \" to \" y))))\n  (satisfies? IComparable x)\n  (-compare x y)\n  :else\n  (if\n   (and\n    (or (string? x) (array? x) (true? x) (false? x))\n    (identical? (type x) (type y)))\n   (garray/defaultCompare x y)\n   (throw (js/Error. (str \"Cannot compare \" x \" to \" y))))))\n"} {:sym complement, :meta {:doc "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value.", :arglists ([f])}, :source "(defn\n complement\n \"Takes a fn f and returns a fn that takes the same arguments as f,\\n  has the same effects, if any, and returns the opposite truth value.\"\n [f]\n (fn\n  ([] (not (f)))\n  ([x] (not (f x)))\n  ([x y] (not (f x y)))\n  ([x y & zs] (not (apply f x y zs)))))\n"} {:sym -assoc!, :meta {:doc "Returns a new transient collection of tcoll with a mapping from key to\n     val added to it.", :arglists ([tcoll key val])}, :protocol ITransientAssociative} {:sym *print-dup*, :meta {:doc "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false."}, :source "(def *print-dup* false)\n"} {:sym string-iter, :meta {:doc nil, :arglists ([x])}, :source "(defn string-iter [x] (StringIter. x 0))\n"} {:sym IDeref, :meta {:doc "Protocol for adding dereference functionality to a reference."}, :methods (-deref)} {:sym sequence, :meta {:doc "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments", :arglists [[coll] [xform coll] [xform coll & colls]]}, :source "(defn\n sequence\n \"Coerces coll to a (possibly empty) sequence, if it is not already\\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\\n  transducer is supplied, returns a lazy sequence of applications of\\n  the transform to the items in coll(s), i.e. to the set of first\\n  items of each coll, followed by the set of second\\n  items in each coll, until any one of the colls is exhausted.  Any\\n  remaining items in other colls are ignored. The transform should accept\\n  number-of-colls arguments\"\n ([coll] (if (seq? coll) coll (or (seq coll) ())))\n ([xform coll]\n  (or\n   (chunkIteratorSeq (.create TransformerIterator xform (iter coll)))\n   ()))\n ([xform coll & colls]\n  (or\n   (chunkIteratorSeq\n    (.createMulti\n     TransformerIterator\n     xform\n     (map iter (cons coll colls))))\n   ())))\n"} {:sym constantly, :meta {:doc "Returns a function that takes any number of arguments and returns x.", :arglists ([x])}, :source "(defn\n constantly\n \"Returns a function that takes any number of arguments and returns x.\"\n [x]\n (fn [& args] x))\n"} {:sym chunked-seq, :meta {:doc nil, :arglists [[vec i off] [vec node i off] [vec node i off meta]]}, :source "(defn\n chunked-seq\n ([vec i off] (ChunkedSeq. vec (array-for vec i) i off nil nil))\n ([vec node i off] (ChunkedSeq. vec node i off nil nil))\n ([vec node i off meta] (ChunkedSeq. vec node i off meta nil)))\n"} {:sym ISorted, :meta {:doc "Protocol for a collection which can represent their items\n  in a sorted manner. "}, :methods (-comparator -entry-key -sorted-seq -sorted-seq-from)} {:sym make-array, :meta {:doc "Construct a JavaScript array of the specified dimensions. Accepts ignored\n  type argument for compatibility with Clojure. Note that there is no efficient\n  way to allocate multi-dimensional arrays in JavaScript; as such, this function\n  will run in polynomial time when called with 3 or more arguments.", :arglists [[size] [type size] [type size & more-sizes]]}, :source "(defn\n make-array\n \"Construct a JavaScript array of the specified dimensions. Accepts ignored\\n  type argument for compatibility with Clojure. Note that there is no efficient\\n  way to allocate multi-dimensional arrays in JavaScript; as such, this function\\n  will run in polynomial time when called with 3 or more arguments.\"\n ([size] (js/Array. size))\n ([type size] (make-array size))\n ([type size & more-sizes]\n  (let\n   [dims more-sizes dimarray (make-array size)]\n   (dotimes\n    [i (alength dimarray)]\n    (aset dimarray i (apply make-array nil dims)))\n   dimarray)))\n"} {:sym shorts, :meta {:doc nil, :arglists ([x])}, :source "(defn shorts [x] x)\n"} {:sym *unchecked-if*, :meta {}, :source "(def *unchecked-if* false)\n"} {:sym enable-console-print!, :meta {:doc "Set *print-fn* to console.log", :arglists ([])}, :source "(defn\n enable-console-print!\n \"Set *print-fn* to console.log\"\n []\n (set! *print-newline* false)\n (set!\n  *print-fn*\n  (fn\n   [& args]\n   (.apply (.-log js/console) js/console (into-array args))))\n (set!\n  *print-err-fn*\n  (fn\n   [& args]\n   (.apply (.-error js/console) js/console (into-array args))))\n nil)\n"} {:sym -flush, :meta {:doc "Flush writer.", :arglists ([writer])}, :protocol IWriter} {:sym completing, :meta {:doc "Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument.", :arglists [[f] [f cf]]}, :source "(defn\n completing\n \"Takes a reducing function f of 2 args and returns a fn suitable for\\n  transduce by adding an arity-1 signature that calls cf (default -\\n  identity) on the result argument.\"\n ([f] (completing f identity))\n ([f cf] (fn ([] (f)) ([x] (cf x)) ([x y] (f x y)))))\n"} {:sym unchecked-negate-int, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-negate-int [x] (cljs.core/unchecked-negate-int x))\n"} {:sym hash-unordered-coll, :meta {:doc "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://clojure.org/data_structures#hash for full algorithms.", :arglists ([coll])}, :source "(defn\n hash-unordered-coll\n \"Returns the hash code, consistent with =, for an external unordered\\n   collection implementing Iterable. For maps, the iterator should\\n   return map entries whose hash is computed as\\n     (hash-ordered-coll [k v]).\\n   See http://clojure.org/data_structures#hash for full algorithms.\"\n [coll]\n (loop\n  [n 0 hash-code 0 coll (seq coll)]\n  (if-not\n   (nil? coll)\n   (recur\n    (inc n)\n    (bit-or (+ hash-code (hash (first coll))) 0)\n    (next coll))\n   (mix-collection-hash hash-code n))))\n"} {:sym repeat, :meta {:doc "Returns a lazy (infinite!, or length n if supplied) sequence of xs.", :arglists [[x] [n x]]}, :source "(defn\n repeat\n \"Returns a lazy (infinite!, or length n if supplied) sequence of xs.\"\n ([x] (lazy-seq (cons x (repeat x))))\n ([n x] (take n (repeat x))))\n"} {:sym unchecked-inc, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-inc [x] (cljs.core/unchecked-inc x))\n"} {:sym nthnext, :meta {:doc "Returns the nth next of coll, (seq coll) when n is 0.", :arglists ([coll n])}, :source "(defn\n nthnext\n \"Returns the nth next of coll, (seq coll) when n is 0.\"\n [coll n]\n (loop\n  [n n xs (seq coll)]\n  (if (and xs (pos? n)) (recur (dec n) (next xs)) xs)))\n"} {:sym get-validator, :meta {:doc "Gets the validator-fn for a var/ref/agent/atom.", :arglists ([iref])}, :source "(defn\n get-validator\n \"Gets the validator-fn for a var/ref/agent/atom.\"\n [iref]\n (.-validator iref))\n"} {:sym number?, :meta {:doc "Returns true if x is a JavaScript number.", :arglists ([x])}, :source "(defn\n number?\n \"Returns true if x is a JavaScript number.\"\n [x]\n (cljs.core/number? x))\n"} {:sym -conj!, :meta {:doc "Adds value val to tcoll and returns tcoll.", :arglists ([tcoll val])}, :protocol ITransientCollection} {:sym chunk-next, :meta {:doc nil, :arglists ([s])}, :source "(defn\n chunk-next\n [s]\n (if\n  (implements? IChunkedNext s)\n  (-chunked-next s)\n  (seq (-chunked-rest s))))\n"} {:sym not-any?, :meta {:doc "Returns false if (pred x) is logical true for any x in coll,\n  else true.", :arglists ([pred coll])}, :source "(defn\n not-any?\n \"Returns false if (pred x) is logical true for any x in coll,\\n  else true.\"\n [pred coll]\n (not (some pred coll)))\n"} {:sym into-array, :meta {:doc "Returns an array with components set to the values in aseq. Optional type\n  argument accepted for compatibility with Clojure.", :arglists [[aseq] [type aseq]]}, :source "(defn\n into-array\n \"Returns an array with components set to the values in aseq. Optional type\\n  argument accepted for compatibility with Clojure.\"\n ([aseq] (into-array nil aseq))\n ([type aseq] (reduce (fn [a x] (.push a x) a) (array) aseq)))\n"} {:sym -hash, :meta {:doc "Returns the hash code of o.", :arglists ([o])}, :protocol IHash} {:sym qualified-symbol?, :meta {:doc "Return true if x is a symbol with a namespace", :arglists ([x])}, :source "(defn\n qualified-symbol?\n \"Return true if x is a symbol with a namespace\"\n [x]\n (boolean (and (symbol? x) (namespace x) true)))\n"} {:sym -dissoc!, :meta {:doc "Returns a new transient collection of tcoll without the mapping for key.", :arglists ([tcoll key])}, :protocol ITransientMap} {:sym chunk-buffer, :meta {:doc nil, :arglists ([capacity])}, :source "(defn chunk-buffer [capacity] (ChunkBuffer. (make-array capacity) 0))\n"} {:sym seqable?, :meta {:doc "Return true if the seq function is supported for s", :arglists ([s])}, :source "(defn\n seqable?\n \"Return true if the seq function is supported for s\"\n [s]\n (or (satisfies? ISeqable s) (array? s) (string? s)))\n"} {:sym symbol?, :meta {:doc "Return true if x is a Symbol", :arglists ([x])}, :source "(defn symbol? \"Return true if x is a Symbol\" [x] (instance? Symbol x))\n"} {:sym m3-hash-unencoded-chars, :meta {:doc nil, :arglists ([in])}, :source "(defn\n m3-hash-unencoded-chars\n [in]\n (let\n  [h1\n   (loop\n    [i 1 h1 m3-seed]\n    (if\n     (< i (.-length in))\n     (recur\n      (+ i 2)\n      (m3-mix-H1\n       h1\n       (m3-mix-K1\n        (bit-or\n         (.charCodeAt in (dec i))\n         (bit-shift-left (.charCodeAt in i) 16)))))\n     h1))\n   h1\n   (if\n    (== (bit-and (.-length in) 1) 1)\n    (bit-xor h1 (m3-mix-K1 (.charCodeAt in (dec (.-length in)))))\n    h1)]\n  (m3-fmix h1 (imul 2 (.-length in)))))\n"} {:sym unchecked-char, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-char [x] x)\n"} {:sym system-time, :meta {:doc "Returns highest resolution time offered by host in milliseconds.", :arglists ([])}, :source "(defn\n system-time\n \"Returns highest resolution time offered by host in milliseconds.\"\n []\n (cond\n  (and (exists? js/performance) (not (nil? (. js/performance -now))))\n  (.now js/performance)\n  (and (exists? js/process) (not (nil? (. js/process -hrtime))))\n  (let\n   [t (.hrtime js/process)]\n   (/ (+ (* (aget t 0) 1.0E9) (aget t 1)) 1000000.0))\n  :else\n  (.getTime (js/Date.))))\n"} {:sym -invoke, :meta {:doc nil, :arglists ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest])}, :protocol IFn} {:sym coll?, :meta {:doc "Returns true if x satisfies ICollection", :arglists ([x])}, :source "(defn\n coll?\n \"Returns true if x satisfies ICollection\"\n [x]\n (if (nil? x) false (satisfies? ICollection x)))\n"} {:sym get-in, :meta {:doc "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key is not present,\n  or the not-found value if supplied.", :arglists [[m ks] [m ks not-found]]}, :source "(defn\n get-in\n \"Returns the value in a nested associative structure,\\n  where ks is a sequence of keys. Returns nil if the key is not present,\\n  or the not-found value if supplied.\"\n {:added \"1.2\", :static true}\n ([m ks] (reduce get m ks))\n ([m ks not-found]\n  (loop\n   [sentinel lookup-sentinel m m ks (seq ks)]\n   (if-not\n    (nil? ks)\n    (let\n     [m (get m (first ks) sentinel)]\n     (if\n      (identical? sentinel m)\n      not-found\n      (recur sentinel m (next ks))))\n    m))))\n"} {:sym fnext, :meta {:doc "Same as (first (next x))", :arglists ([coll])}, :source "(defn fnext \"Same as (first (next x))\" [coll] (first (next coll)))\n"} {:sym IList, :meta {:doc "Marker interface indicating a persistent list"}, :methods ()} {:sym -val, :meta {:doc "Returns the value of the map entry.", :arglists ([coll])}, :protocol IMapEntry} {:sym bytes, :meta {:doc nil, :arglists ([x])}, :source "(defn bytes [x] x)\n"} {:sym -seq, :meta {:doc "Returns a seq of o, or nil if o is empty.", :arglists ([o])}, :protocol ISeqable}), eval-soup.core ({:sym code->results, :meta {:doc "Evaluates each form, providing the results in a callback.\n  If any of the forms are strings, it will read them first.", :arglists [[forms cb] [forms cb {:keys [*current-ns *state custom-load timeout disable-timeout?], :or {*current-ns (atom (quote cljs.user)), *state *cljs-state, custom-load custom-load!, timeout 4000, disable-timeout? false}, :as opts}]]}, :source "(defn\n code->results\n \"Evaluates each form, providing the results in a callback.\\n  If any of the forms are strings, it will read them first.\"\n ([forms cb] (code->results forms cb {}))\n ([forms\n   cb\n   {:keys [*current-ns *state custom-load timeout disable-timeout?],\n    :or\n    {*current-ns (atom 'cljs.user),\n     *state *cljs-state,\n     custom-load custom-load!,\n     timeout 4000,\n     disable-timeout? false},\n    :as opts}]\n  (let\n   [forms\n    (mapv\n     (fn*\n      [p1__18138#]\n      (if\n       (string? p1__18138#)\n       (str->form @*current-ns p1__18138#)\n       p1__18138#))\n     forms)\n    init-forms\n    (vec\n     (concat\n      ['(ns cljs.user)]\n      (when-not\n       disable-timeout?\n       ['(def ps-last-time (atom 0))\n        '(defn\n          ps-reset-timeout!\n          []\n          (reset! ps-last-time (.getTime (js/Date.))))\n        '(defn\n          ps-check-for-timeout!\n          [timeout]\n          (when\n           (> (- (.getTime (js/Date.)) @ps-last-time) timeout)\n           (throw (js/Error. \"Execution timed out.\"))))])\n      ['(set! *print-err-fn* (fn [_])) (list 'ns @*current-ns)]))\n    timeout-cb\n    (fn\n     [results]\n     (eval-forms\n      (add-timeouts-if-necessary timeout forms results)\n      cb\n      *state\n      *current-ns\n      custom-load))\n    init-cb\n    (fn\n     [results]\n     (eval-forms\n      (if disable-timeout? forms (map wrap-macroexpand forms))\n      (if disable-timeout? cb timeout-cb)\n      *state\n      *current-ns\n      custom-load))]\n   (eval-forms init-forms init-cb *state *current-ns custom-load))))\n", :examples [{:doc "You can reference vars you previously made.", :with-callback callback, :body (code->results [(quote (def n 4)) (quote (conj [1 2 3] n))] callback), :body-str "(code->results ['(def n 4) '(conj [1 2 3] n)] callback)\n", :id "eval-soup.core/code->results/0"} {:doc "You can pass the code as strings too.", :with-callback callback, :body (code->results ["(def n 4)" "(conj [1 2 3] n)"] callback), :body-str "(code->results [\"(def n 4)\" \"(conj [1 2 3] n)\"] callback)\n", :id "eval-soup.core/code->results/1"} {:doc "If your code exceeds the timeout, you'll see an exception.\n   \n   You can turn off timeout protection by passing `:disable-timeout? true`\n   in the options map.", :with-callback callback, :body (code->results [(quote (while true))] callback {:timeout 1000}), :body-str "(code->results ['(while true)] callback {:timeout 1000})\n", :id "eval-soup.core/code->results/2"}]})}, :nses ({:var-syms [wrap-security code->results wrap-timeout eval_soup.core.proxy$java.lang.SecurityManager$ff19274a with-security], :type :clj, :sym eval-soup.core} {:var-syms [code->results], :type :cljs, :sym eval-soup.core}), :ns-meta nil, :vars [{:sym code->results, :meta {:arglists ([forms] [forms {:keys [timeout disable-timeout? disable-security?], :or {timeout 4000, disable-timeout? false, disable-security? false}, :as opts}]), :doc "Returns a vector of the evaluated result of each of the given forms.\n  If any of the forms are strings, it will read them first."}, :source "(defn code->results\n  \"Returns a vector of the evaluated result of each of the given forms.\n  If any of the forms are strings, it will read them first.\"\n  ([forms]\n   (code->results forms {}))\n  ([forms {:keys [timeout\n                  disable-timeout?\n                  disable-security?]\n           :or {timeout 4000\n                disable-timeout? false\n                disable-security? false}\n           :as opts}]\n   (let [opts {:timeout timeout\n               :disable-timeout? disable-timeout?\n               :disable-security? disable-security?}]\n     (loop [forms forms\n            results []\n            nspace (create-ns 'clj.user)]\n       (if-let [form (first forms)]\n         (let [[result current-ns] (eval-form form nspace opts)]\n           (recur (rest forms) (conj results result) current-ns))\n         results)))))", :spec nil, :examples [{:doc "You can reference vars you previously made.", :body (code->results [(quote (def n 4)) (quote (conj [1 2 3] n))]), :body-str "(code->results ['(def n 4) '(conj [1 2 3] n)])\n", :id "eval-soup.core/code->results/0"} {:doc "You can pass the code as strings too.", :body (code->results ["(def n 4)" "(conj [1 2 3] n)"]), :body-str "(code->results [\"(def n 4)\" \"(conj [1 2 3] n)\"])\n", :id "eval-soup.core/code->results/1"} {:doc "If your code exceeds the timeout, you'll see an exception.\n   \n   You can turn off timeout protection by passing `:disable-timeout? true`\n   in the options map.", :body (code->results [(quote (while true))] {:timeout 1000}), :body-str "(code->results ['(while true)] {:timeout 1000})\n", :id "eval-soup.core/code->results/2"} {:doc "If your code tries to exit, you'll see an exception.\n   \n   You can turn off exit protection by passing `:disable-security? true`\n   in the options map.", :body (code->results [(quote (System/exit 0))]), :body-str "(code->results ['(System/exit 0)])\n", :id "eval-soup.core/code->results/3"}]} {:sym with-security, :meta {:arglists ([& body]), :doc "Convenience macro that wraps the body with wrap-security\n  and then immediately executes it."}, :source "(defmacro with-security\n  \"Convenience macro that wraps the body with wrap-security\n  and then immediately executes it.\"\n  [& body]\n  `(apply (wrap-security (fn [] ~@body)) []))", :spec nil, :examples []} {:sym wrap-security, :meta {:arglists ([thunk]), :doc "Returns a function that wraps the given function in a sandbox.\n  It uses eval_soup/java.policy to define permissions. By default,\n  it only disallows exiting via System/exit."}, :source "(defn wrap-security\n  \"Returns a function that wraps the given function in a sandbox.\n  It uses eval_soup/java.policy to define permissions. By default,\n  it only disallows exiting via System/exit.\"\n  [thunk]\n  (fn []\n    (System/setProperty \"java.security.policy\"\n      (-> \"eval_soup/java.policy\" io/resource .toString))\n    (System/setSecurityManager\n      (proxy [SecurityManager] []\n        (checkExit [status#]\n          (throw (SecurityException. \"Exit not allowed.\")))))\n    (try (thunk)\n      (finally (System/setSecurityManager nil)))))", :spec nil, :examples []} {:sym wrap-timeout, :meta {:arglists ([thunk timeout]), :doc "Returns a function that wraps the given function in a timeout checker.\n  The timeout is specified in milliseconds. If the timeout is reached,\n  an exceptino will be thrown."}, :source "(defn wrap-timeout\n  \"Returns a function that wraps the given function in a timeout checker.\n  The timeout is specified in milliseconds. If the timeout is reached,\n  an exceptino will be thrown.\"\n  [thunk timeout]\n  (fn []\n    (thunk-timeout thunk timeout)))", :spec nil, :examples []}], :rel-path "../", :check-for-updates? false}</script>
        <script type="text/javascript" src="../main.js"></script>
    </body>
</html>
